# this 对象

箭头函数没有自己的 `this` 对象，箭头函数内部的 `this` 指向是固定的，就是定义时**上层作用域**（函数作用于，或者全局作用域）中的 `this`。

```javascript
var id = 21;

function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

foo.call({ id: 42 });
// id: 42
```

上面代码中，箭头函数的定义生效是在 `foo` 函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时 `this` 应该指向全局对象 `window`，这时应该输出 21。但是，箭头函数导致 `this` 总是指向函数定义生效时所在的对象（本例是 `{id: 42}`），所以打印出来的是 42。

由于箭头函数没有自己的 `this`，所以当然也就不能用 `call()`、`apply()`、`bind()` 这些方法去改变 `this` 的指向。

由于箭头函数的 `this` 指向是固定的，下面两个场合不应该使用箭头函数。

- 第一个场合是定义对象的方法，且该方法内部包括 `this`。
- 第二个场合是需要动态 `this` 的时候。

```javascript
const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
  }
}
```

上面代码中，调用 `cat.jumps()` 时，如果是普通函数，该方法内部的 `this` 指向 `cat`；如果写成上面那样的箭头函数，使得 `this` 指向全局对象，因此不会得到预期结果。这是因为**对象不构成单独的作用域**，导致 `jumps` 箭头函数定义时的作用域就是全局作用域。

## 参考

- [函数的扩展，阮一峰](https://es6.ruanyifeng.com/#docs/function)
