# 前端安全

## 概述

前端项目安全主要包括 XSS（跨站脚本攻击）、CSRF（跨站请求伪造）等。

## XSS

### XSS 介绍

XSS（Cross-site scripting，跨站脚本攻击）指攻击者通过向站点注入恶意脚本，使其在站点中执行，从而执行恶意操作的行为。

跨站脚本攻击跟浏览器的[同源策略][same-origin_policy]有关，所谓同源策略，指的是两个站点的协议、域名和端口号相同。只要三者中任意一个不同，就违背同源策略，也就是我们常说的“跨域”。比如，对于 `http://store.company.com/dir/page.html`，分析下面这几种情况。

- `http://store.company.com/dir2/other.html` 同源，只有 URL 路径不同。
- `http://store.company.com/dir/inner/another.html` 同源，只有 URL 路径不同。
- `https://store.company.com/page.html` 非同源，协议不同。
- `http://store.company.com:81/dir/page.html` 非同源，端口不同，示例站点端口号为 `80`，此端口号为 `81`。
- `http://news.company.com/dir/page.html` 非同源，域名不同。

同源策略的提出，主要是为了安全性的考虑，比如，它能够防止恶意站点从其他站点或者服务器窃取数据。具体来说，同源策略有下面这些限制。

- 无法接触非同源网页的 DOM。
- 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。
- 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。

XSS 攻击的成功实施必须满足两个条件。

1. 恶意代码被注入到站点。
2. 恶意代码没有被执行消毒操作，使其被当作脚本代码执行。

![XSS 攻击发生时，攻击者能够访问其他站点的 DOM、Cookie 和 Storage 数据](https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/XSS/xss.svg)

XSS 攻击通常分为三种类型：存储型 XSS (Stored XSS)、反射型 XSS (Reflected XSS)和基于 DOM 的 XSS (DOM-based XSS)。

### 客户端 XSS 攻击示例

在页面渲染过程中，采用客户端渲染（Client-side rendering，CSR）的站点（比如，使用 React 这样的框架），直接或者间接地通过 `document.createElement()` 之类的 web API 操作页面，XSS 攻击正是发生在这个过程中。

下面的示例中的代码，是 `https://my-bank.example.com/welcome` 站点中的一部分，用户登录之后，站点能访问到用户的登录信息并执行转账操作。用户登录之后，该站点尝试从 URL 查询参数中获取用户的信息，向用户展示一段欢迎信息。

```html
<h1 id="welcome"></h1>

<script>
  const params = new URLSearchParams(window.location.search);
   const user = params.get("user");
   const welcome = document.querySelector("#welcome");
   welcome.innerHTML = `Welcome back, ${user}!`;
</script>
```

攻击者向用户发送了一个这样的链接。

```html
<a href="https://my-bank.example.com/welcome?user=<img src=x onerror=alert('hello!')>">
  Get a free kitten!
</a>
```

用户点击这个链接之后，页面被加载，站点从 URL 中提取 `user` 信息，然而，该字段指向的是一段 HTML 代码 `<img src=x onerror=alert('hello!')>`，这行代码被 `innerHTML` 执行后，`<img>` 标签被创建，`<img>` 的 `src` 属性指向一个错误的地址，于是触发了 `onerror` 函数。最终造成的后果就是，`onerror` 中的恶意脚本被执行。

### 服务端 XSS 攻击示例

对于采用服务端渲染的（Server-side rendering，SSR）站点，服务器将数据注入到模板文件中，在这个过程中，也可能发生 XSS 攻击。下面这个服务器搜索的例子就演示了这种情况。

```html
<h1>Search</h1>

<form action="/results">
  <label for="mySearch">Search for an item:</label>
  <input id="mySearch" type="search" name="search" />
  <input type="submit" />
</form>
```

用户输入搜索内容并点击提交按钮，浏览器向 `results` 接口发出一个 GET 请求。

```http
https://example.org/results?search=bananas
```

服务器收到请求之后，查询数据库，将结果返回给用户。

```javascript
app.get("/results", (req, res) => {
  const searchQuery = req.query.search;
  const results = getResults(searchQuery);
  res.send(`
   <h1>You searched for ${searchQuery}</h1>
   <p>Here are the results: ${results}</p>`);
});
```

然而，攻击者可能发送一个这样的请求。

```html
<a href="http://example.org/results?search=<img src=x onerror=alert('hello')">
  Get a free kitten!</a
>
```

用户点击这个链接之后，服务器提取出来的搜索关键词是 `<img src=x onerror=alert('hello')`，这段代码被嵌入到返回的结果中，浏览器解析结果时，`onerror` 函数中的恶意脚本就会被执行。

### XSS 防护

#### 输入验证、过滤与消毒

对于输入的内容，通过白名单或者黑名单机制进行验证和过滤。

```javascript
function validateInput(input) {
  const allowedTags = ['p', 'br', 'strong', 'em'];
  const allowedAttributes = ['class', 'id'];
  // 实现白名单过滤逻辑
}

function sanitizeInput(input) {
  return input
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/javascript:/gi, '')
    .replace(/on\w+\s*=/gi, '');
}
```

消毒（Sanitization）指的是移除 HTML 字符串中不安全的代码的过程。在对输入消毒时，需要考虑到各种情况，因此，推荐使用 [DOMPurify] 这样的库来执行这一过程。

```html
<div>
  <img src="x" onerror="alert('hello!')" />
  <script>
    alert("hello!");
  </script>
</div>
```

上面这段代码，消毒后会变成下面的代码。

```html
<div>
  <img src="x" />
</div>
```

下面是一个在 React 中使用 DOMPurify 的例子。

```jsx
import DOMPurify from 'dompurify';

function SafeHtmlRenderer({ htmlContent }) {
  const sanitizedHtml = DOMPurify.sanitize(htmlContent, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'a'],
    ALLOWED_ATTR: ['href', 'class'],
    ALLOW_DATA_ATTR: false
  });
  
  return (
    <div 
      dangerouslySetInnerHTML={{ __html: sanitizedHtml }}
    />
  );
}
```

#### 输出编码

输出编码（Output encoding）指的是对输入的内容在输出到页面之前，对可能有潜在危险的内容进行转码的过程，使其最终被作为字符串而不是 HTML 或者脚本被执行。

输出编码包括了对输入的 HTML、URL 以及脚本等内容进行编码。

HTML 编码主要是对下面这些字符进行处理。

- 将 `<` 转为 `&lt;`。
- 将 `>` 转为 `&gt;`。
- 将 `'` 转为 `&#x27;`。
- 将 `"` 转为 `&quot;`。
- 将 `&` 转为 `&amp;`。

下面是一个封装的、对各种字符编码的工具方法。

```javascript
/**
 * XSS 防护输出编码器
 * 支持多种上下文环境的自动编码
 */
class XSSEncoder {
  constructor() {
    // 危险字符映射表
    this.dangerousChars = {
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;',
      '`': '&#x60;',
      '=': '&#x3D;'
    };

    // JavaScript 危险字符
    this.jsDangerousChars = {
      '\\': '\\\\',
      "'": "\\'",
      '"': '\\"',
      '\n': '\\n',
      '\r': '\\r',
      '\t': '\\t',
      '\b': '\\b',
      '\f': '\\f',
      '/': '\\/',
      '<': '\\u003c',
      '>': '\\u003e'
    };

    // URL 危险字符
    this.urlDangerousChars = {
      ' ': '%20',
      '!': '%21',
      '"': '%22',
      '#': '%23',
      '$': '%24',
      '%': '%25',
      '&': '%26',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '*': '%2A',
      '+': '%2B',
      ',': '%2C',
      '/': '%2F',
      ':': '%3A',
      ';': '%3B',
      '<': '%3C',
      '=': '%3D',
      '>': '%3E',
      '?': '%3F',
      '@': '%40',
      '[': '%5B',
      '\\': '%5C',
      ']': '%5D',
      '^': '%5E',
      '`': '%60',
      '{': '%7B',
      '|': '%7C',
      '}': '%7D',
      '~': '%7E'
    };
  }

  /**
   * HTML 实体编码
   * @param {string} input - 输入字符串
   * @param {boolean} strict - 是否严格模式（编码更多字符）
   * @returns {string} 编码后的字符串
   */
  htmlEncode(input, strict = false) {
    if (typeof input !== 'string') {
      input = String(input);
    }

    let result = input;
    
    // 基础危险字符编码
    for (const [char, encoded] of Object.entries(this.dangerousChars)) {
      result = result.replace(new RegExp(char.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), encoded);
    }

    // 严格模式：编码更多潜在危险字符
    if (strict) {
      const strictChars = {
        '(': '&#40;',
        ')': '&#41;',
        '[': '&#91;',
        ']': '&#93;',
        '{': '&#123;',
        '}': '&#125;',
        ';': '&#59;',
        ':': '&#58;',
        '!': '&#33;',
        '@': '&#64;',
        '#': '&#35;',
        '$': '&#36;',
        '%': '&#37;',
        '^': '&#94;',
        '*': '&#42;',
        '+': '&#43;',
        '=': '&#61;',
        '|': '&#124;',
        '\\': '&#92;',
        '`': '&#96;',
        '~': '&#126;'
      };

      for (const [char, encoded] of Object.entries(strictChars)) {
        result = result.replace(new RegExp(char.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), encoded);
      }
    }

    return result;
  }

  /**
   * JavaScript 字符串编码
   * @param {string} input - 输入字符串
   * @param {boolean} inAttribute - 是否在属性中使用
   * @returns {string} 编码后的字符串
   */
  jsEncode(input, inAttribute = false) {
    if (typeof input !== 'string') {
      input = String(input);
    }

    let result = input;

    // 基础 JavaScript 危险字符编码
    for (const [char, encoded] of Object.entries(this.jsDangerousChars)) {
      result = result.replace(new RegExp(char.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), encoded);
    }

    // 在属性中使用时的额外编码
    if (inAttribute) {
      result = result.replace(/"/g, '\\"');
    }

    return result;
  }

  /**
   * URL 编码
   * @param {string} input - 输入字符串
   * @param {boolean} strict - 是否严格模式
   * @returns {string} 编码后的字符串
   */
  urlEncode(input, strict = false) {
    if (typeof input !== 'string') {
      input = String(input);
    }

    if (strict) {
      // 使用 encodeURIComponent 进行严格编码
      return encodeURIComponent(input);
    }

    // 自定义编码，只编码危险字符
    let result = input;
    for (const [char, encoded] of Object.entries(this.urlDangerousChars)) {
      result = result.replace(new RegExp(char.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), encoded);
    }

    return result;
  }

  /**
   * CSS 编码
   * @param {string} input - 输入字符串
   * @returns {string} 编码后的字符串
   */
  cssEncode(input) {
    if (typeof input !== 'string') {
      input = String(input);
    }

    return input
      .replace(/\\/g, '\\\\')
      .replace(/'/g, "\\'")
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\A')
      .replace(/\r/g, '\\D')
      .replace(/\(/g, '\\28')
      .replace(/\)/g, '\\29')
      .replace(/</g, '\\3C')
      .replace(/>/g, '\\3E');
  }

  /**
   * 属性值编码
   * @param {string} input - 输入字符串
   * @param {string} quote - 引号类型 (' 或 ")
   * @returns {string} 编码后的字符串
   */
  attributeEncode(input, quote = '"') {
    if (typeof input !== 'string') {
      input = String(input);
    }

    let result = input;

    // HTML 实体编码
    result = this.htmlEncode(result);

    // 根据引号类型进行额外编码
    if (quote === '"') {
      result = result.replace(/"/g, '&quot;');
    } else if (quote === "'") {
      result = result.replace(/'/g, '&#x27;');
    }

    return result;
  }

  /**
   * 智能上下文编码
   * 根据上下文自动选择合适的编码方式
   * @param {string} input - 输入字符串
   * @param {string} context - 上下文类型 ('html', 'js', 'url', 'css', 'attribute')
   * @param {Object} options - 编码选项
   * @returns {string} 编码后的字符串
   */
  smartEncode(input, context = 'html', options = {}) {
    switch (context.toLowerCase()) {
      case 'html':
        return this.htmlEncode(input, options.strict);
      
      case 'js':
      case 'javascript':
        return this.jsEncode(input, options.inAttribute);
      
      case 'url':
        return this.urlEncode(input, options.strict);
      
      case 'css':
        return this.cssEncode(input);
      
      case 'attribute':
        return this.attributeEncode(input, options.quote);
      
      default:
        // 默认使用 HTML 编码
        return this.htmlEncode(input, options.strict);
    }
  }

  /**
   * 批量编码
   * @param {Object} data - 要编码的数据对象
   * @param {Object} encodingRules - 编码规则映射
   * @returns {Object} 编码后的数据对象
   */
  batchEncode(data, encodingRules = {}) {
    const result = {};

    for (const [key, value] of Object.entries(data)) {
      const rule = encodingRules[key] || { context: 'html', options: {} };
      
      if (typeof value === 'string') {
        result[key] = this.smartEncode(value, rule.context, rule.options);
      } else if (Array.isArray(value)) {
        result[key] = value.map(item => 
          typeof item === 'string' 
            ? this.smartEncode(item, rule.context, rule.options)
            : item
        );
      } else if (typeof value === 'object' && value !== null) {
        result[key] = this.batchEncode(value, rule.nestedRules || {});
      } else {
        result[key] = value;
      }
    }

    return result;
  }
}

// 创建全局实例
const xssEncoder = new XSSEncoder();

// 便捷方法
const htmlEncode = (input, strict = false) => xssEncoder.htmlEncode(input, strict);
const jsEncode = (input, inAttribute = false) => xssEncoder.jsEncode(input, inAttribute);
const urlEncode = (input, strict = false) => xssEncoder.urlEncode(input, strict);
const cssEncode = (input) => xssEncoder.cssEncode(input);
const attributeEncode = (input, quote = '"') => xssEncoder.attributeEncode(input, quote);
const smartEncode = (input, context = 'html', options = {}) => xssEncoder.smartEncode(input, context, options);
const batchEncode = (data, encodingRules = {}) => xssEncoder.batchEncode(data, encodingRules);

// 导出
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    XSSEncoder,
    xssEncoder,
    htmlEncode,
    jsEncode,
    urlEncode,
    cssEncode,
    attributeEncode,
    smartEncode,
    batchEncode
  };
}
```

按照输入代码被嵌入的位置，可以从下面三个方面考虑防护措施。

- HTML 上下文。用户输入的内容被嵌入到 HTML 元素标签内部（除 `<style>` 和 `<script>`），这些代码被当作 HTML 解析，编码工具大多能够处理这种情况。
- HTML 属性上下文。用户输入的内容被当作 HTML 属性解析，此时，恶意代码就可以通过 `onblur` 或者 `src` 之类的属性执行。

  比如，下面这行代码就是不安全的。

  ```html
  <div class={{ my_class }}>...</div>
  ```

  攻击者可以输入 `onmouseover=alert(1)` 之类的内容。要防止恶意脚本的执行，可以将其使用引号包裹起来，就像下面这样。

  ```html
  <div class="{{ my_class }}">...</div>
  ```

- JavaScript 和 CSS 上下文。讲内容嵌入到 `<style>` 和 `<script>` 是一种危险的行为，应该避免这种情况的发生。

#### 内容安全策略的处理

```html
<meta http-equiv="Content-Security-Policy" 
  content="
    default-src 'self'; 
    script-src 'self' 'unsafe-inline'; 
    style-src 'self' 'unsafe-inline';
    img-src 'self' data: https:;
  "
>
```

#### 启用 HTTP 安全头

```javascript
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  next();
});
```

#### 安全的 Cookie 处理

考虑启用下面三个 Cookie 中的属性。

- `httpOnly: true`
- `secure: true`
- `sameSite: 'strict'`

### React 中的 XSS 防护措施

#### JSX 会自动对输入转义

React 的框架会自动对嵌入到 JSX 语法中的内容进行处理。

```jsx
import React from "react";

export function App(props) {
  return <div>Hello, {props.name}!</div>;
}
```

比如，用户通过 `props.name` 输入了这样一行代码 `<img src=x onerror=alert('XSS!')>`，这行代码最终会被转为下面的字符串输出。

```test
Hello, <img src=x onerror=alert('XSS!')>!
```

#### 尽量避免使用 `dangerouslySetInnerHTML`

React 的 `dangerouslySetInnerHTML` 属性会绕过 React 的内置 XSS 防护，应该尽量避免使用。如果必须使用，请确保内容已经过适当的消毒处理。

```jsx
// 避免直接使用用户输入
function UnsafeComponent({ userContent }) {
  return <div dangerouslySetInnerHTML={{ __html: userContent }} />;
}

// 使用 DOMPurify 消毒
import DOMPurify from 'dompurify';

function SafeComponent({ userContent }) {
  const sanitizedContent = DOMPurify.sanitize(userContent, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em'],
    ALLOWED_ATTR: ['class']
  });
  
  return <div dangerouslySetInnerHTML={{ __html: sanitizedContent }} />;
}
```

#### 使用工具方法

下面的工具方法，是基于 `XSSEncoder` 工具方法的封装。

```javascript
import { useMemo } from 'react';
import { xssEncoder } from './xssEncoder';

/**
 * XSS 防护 Hook
 * @param {string} input - 输入内容
 * @param {string} context - 编码上下文
 * @param {Object} options - 编码选项
 * @returns {string} 编码后的内容
 */
export const useXSSProtection = (input, context = 'html', options = {}) => {
  return useMemo(() => {
    if (!input) return '';
    return xssEncoder.smartEncode(input, context, options);
  }, [input, context, options]);
};

/**
 * 批量 XSS 防护 Hook
 * @param {Object} data - 数据对象
 * @param {Object} encodingRules - 编码规则
 * @returns {Object} 编码后的数据
 */
export const useBatchXSSProtection = (data, encodingRules = {}) => {
  return useMemo(() => {
    if (!data) return {};
    return xssEncoder.batchEncode(data, encodingRules);
  }, [data, encodingRules]);
};
```

[same-origin_policy]: https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy
[DOMPurify]: https://github.com/cure53/DOMPurify

## CSRF

### CSRF 介绍

CSRF（Cross-site request forgery，跨站请求伪造）指攻击者利用合法的用户身份，向目标站点发起请求，从而执行恶意操作的行为。

```html
<form action="https://my-bank.example.org/transfer" method="POST">
  <input type="hidden" name="recipient" value="attacker" />
  <input type="hidden" name="amount" value="1000" />
</form>

<script>
  document.querySelector("form").submit();
</script>
```

比如，攻击者诱导用户进入自己创建的恶意站点，页面内部有个 `<form>` 表单，当页面加载时，表单中的数据被提交到 `my-bank.example.org`，如果用户之前在这个银行网站登录过，就会留下 cookie 信息，此时，表单数据提交时，用户的 cookie 信息会一并携带至服务器，服务器就可能认为是用户主动发起的转账请求，于是执行转账操作，从而给用户造成损失。

![攻击者通过 CSRF 攻击，模拟用户身份，执行了转账操作](https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/CSRF/csrf-form-post.svg)

上面的 `<form>` 表单是一个 POST 请求的例子，攻击者还可以利用 `<img>` 标签发起 GET 请求。

```html
<img src="https://my-bank.example.org/transfer?recipient=attacker&amount=1000" />
```

如果站点使用 HTTP 通信，且仅使用 cookie 作为验证用户身份的手段，CSRF 就可能发生。

### CSRF 防护

#### CSRF Token

CSRF Token 是最常用的 CSRF 防护方法。服务器为每个用户会话生成一个唯一的、不可预测的 token，并将其包含在表单中。当用户提交表单时，服务器验证 token 是否有效。

```javascript
// 服务端实现
const crypto = require('crypto');

// 生成 CSRF token
function generateCSRFToken(sessionId) {
  return crypto.randomBytes(32).toString('hex');
}

// 验证 CSRF token
function verifyCSRFToken(sessionId, token) {
  const storedToken = getStoredToken(sessionId);
  return storedToken && storedToken === token;
}

// Express.js 中间件
app.use((req, res, next) => {
  if (req.method === 'GET') {
    const token = generateCSRFToken(req.sessionID);
    req.session.csrfToken = token;
    res.locals.csrfToken = token;
  }
  next();
});
```

```jsx
// 前端实现
import React, { useState, useEffect } from 'react';

function TransferForm() {
  const [csrfToken, setCsrfToken] = useState('');
  const [formData, setFormData] = useState({
    recipient: '',
    amount: ''
  });

  useEffect(() => {
    // 获取 CSRF token
    fetch('/api/csrf-token')
      .then(res => res.json())
      .then(data => setCsrfToken(data.token));
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    const response = await fetch('/api/transfer', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken
      },
      body: JSON.stringify(formData)
    });

    if (response.ok) {
      alert('转账成功');
    } else {
      alert('转账失败');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="hidden" name="csrfToken" value={csrfToken} />
      <input
        type="text"
        placeholder="收款人"
        value={formData.recipient}
        onChange={(e) => setFormData({...formData, recipient: e.target.value})}
      />
      <input
        type="number"
        placeholder="金额"
        value={formData.amount}
        onChange={(e) => setFormData({...formData, amount: e.target.value})}
      />
      <button type="submit">转账</button>
    </form>
  );
}
```

#### 双重 Token 验证

双重 Token 验证使用两个 token：一个存储在 cookie 中，另一个存储在表单中。服务器验证两个 token 是否匹配。

```javascript
// 服务端实现
app.post('/api/transfer', (req, res) => {
  const cookieToken = req.cookies.csrfToken;
  const formToken = req.body.csrfToken;
  
  if (!cookieToken || !formToken || cookieToken !== formToken) {
    return res.status(403).json({ error: 'CSRF token 验证失败' });
  }
  
  // 处理转账逻辑
  processTransfer(req.body);
  res.json({ success: true });
});
```

#### Referer、Origin 检查

检查请求的 Referer 和 Origin 头部，确保请求来自同源。

```javascript
app.use((req, res, next) => {
  const referer = req.get('Referer');
  const origin = req.get('Origin');
  const host = req.get('Host');
  
  // 检查 Referer
  if (referer && !referer.startsWith(`https://${host}`)) {
    return res.status(403).json({ error: '无效的 Referer' });
  }
  
  // 检查 Origin
  if (origin && origin !== `https://${host}`) {
    return res.status(403).json({ error: '无效的 Origin' });
  }
  
  next();
});
```

#### SameSite Cookie

设置 Cookie 的 SameSite 属性，限制跨站请求携带 Cookie。

```javascript
app.use(session({
  cookie: {
    secure: true,        // 仅 HTTPS
    httpOnly: true,      // 防止 XSS
    sameSite: 'strict'   // 防止 CSRF
  }
}));
```

- `strict` 完全禁止跨站请求携带 Cookie
- `lax` 允许 GET 请求携带 Cookie，禁止 POST 请求
- `none` 允许所有跨站请求携带 Cookie（需要 secure 属性）

## 点击劫持

### 点击劫持介绍

点击劫持（Clickjacking）是一种视觉欺骗攻击，攻击者通过透明的 iframe 或 CSS 技术，诱导用户点击看似无害的元素，实际上点击的是攻击者隐藏的恶意元素。

```html
<!-- 攻击者页面 -->
<div style="position: relative; width: 300px; height: 200px;">
  <iframe src="https://victim-site.com/transfer" 
          style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.1; z-index: 1;">
  </iframe>
  <div style="position: absolute; top: 50px; left: 50px; z-index: 2;">
    <button>点击获得免费礼品！</button>
  </div>
</div>
```

### 点击劫持防护

#### X-Frame-Options 头部

```javascript
// 服务端设置
app.use((req, res, next) => {
  res.setHeader('X-Frame-Options', 'DENY'); // 完全禁止嵌入
  // 或者 res.setHeader('X-Frame-Options', 'SAMEORIGIN'); // 只允许同源嵌入
  next();
});
```

#### Content Security Policy (CSP)

```html
<meta http-equiv="Content-Security-Policy" content="frame-ancestors 'none';">
```

#### JavaScript 防护

```javascript
// 检测是否被嵌入到 iframe 中
if (window.top !== window.self) {
  // 被嵌入到 iframe 中，可能是点击劫持攻击
  window.top.location = window.self.location;
}

// 或者使用更严格的检测
if (window.top !== window.self) {
  document.body.style.display = 'none';
  alert('此页面不允许在 iframe 中显示');
}
```

## 其他安全考虑

### HTTPS 强制使用

确保所有通信都使用 HTTPS，防止中间人攻击和数据泄露。

```javascript
// Express.js 强制 HTTPS
app.use((req, res, next) => {
  if (req.header('x-forwarded-proto') !== 'https') {
    res.redirect(`https://${req.header('host')}${req.url}`);
  } else {
    next();
  }
});

// 设置安全头
app.use((req, res, next) => {
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  next();
});
```

### 速率限制

防止暴力攻击和 DoS 攻击。

```javascript
const rateLimit = require('express-rate-limit');

// 登录速率限制
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 5, // 最多5次尝试
  message: '登录尝试次数过多，请15分钟后再试',
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/login', loginLimiter);

// API 速率限制
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 最多100次请求
  message: '请求过于频繁，请稍后再试',
});

app.use('/api', apiLimiter);
```

### 环境变量安全

敏感信息使用环境变量存储。

```javascript
// .env 文件
DATABASE_URL=mongodb://localhost:27017/myapp
JWT_SECRET=your-super-secret-jwt-key
API_KEY=your-api-key

// 使用环境变量
const config = {
  database: process.env.DATABASE_URL,
  jwtSecret: process.env.JWT_SECRET,
  apiKey: process.env.API_KEY
};
```

## 参考

- [Cross-site scripting (XSS)](https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/XSS), MDN
- [Cross-site request forgery (CSRF)](https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/CSRF), MDN
- [Same-origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy), MDN
- [Content Security Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP), MDN
- [同源限制](https://wangdoc.com/javascript/bom/same-origin), 阮一峰
- [前端安全系列（一）：如何防止XSS攻击？](https://tech.meituan.com/2018/09/27/fe-security.html), 美团技术团队
- [前端安全系列（二）：如何防止CSRF攻击？](https://tech.meituan.com/2018/10/11/fe-security-csrf.html), 美团技术团队
- [OWASP Top 10](https://owasp.org/www-project-top-ten/), OWASP Foundation
- [React Security Best Practices](https://reactjs.org/docs/security.html), React Documentation
