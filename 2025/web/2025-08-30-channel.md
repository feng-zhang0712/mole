# Channel API

## Channel Messaging API

### Channel Messaging API 介绍

Channel Messaging API 是 Web 平台提供的一种跨浏览上下文通信的机制，允许两个运行在不同浏览上下文中的独立脚本进行直接通信，这些脚本需要附加到同一个文档上（比如，两个 IFrame，或者主文档和一个 IFrame，通过 SharedWorker 连接的两个文档，或者两个 Worker），它们通过双向通道（或管道）相互传递消息，每个端点都有一个端口。

Channel Messaging API 采用**异步**通信机制，通信过程不会阻塞主线程，但受**同源策略**的限制。

### MessageChannel 基本使用

`MessageChannel()` 构造函数创建一个消息通道，生成的实例对象有两个属性 `port1` 和 `port2`。使用 `window.postMessage(message, [port2])` 将端口转移到另一个浏览上下文，之后他们就可以通过两个端口进行通信。

- `port1` MessagePort 对象，通道的第一个端口
- `port2` MessagePort 对象，通道的第二个端口

```javascript
const channel = new MessageChannel();

window.postMessage('Hello from the main page!', '*', [channel.port2]);

channel.port1.onmessage = function (event) {
  document.querySelector('p').innerHTML = event.data;
};
```

上面代码创建了一个 `channel` 实例对象，并将 `channel.port2` 通过 `postMessage()` 方法传递给了其他上下文，之后，其他上下文在收到消息后，就可以获取到 `port2` 端口，之后双方就可以通过 `port1` 和 `port2` 端口进行通信。

#### MessageChannel 示例和应用场景

MessageChannel 可以模拟实现 `setTimeout`，并且相比于后者，MessageChannel 没有最低延迟，也不会被浏览器节流，运行更稳定。下面是 React 中使用 MessageChannel 实现的[定时器][react-timer]。

```javascript
let enqueueTask;

if (typeof MessageChannel !== 'undefined') {
  enqueueTask = function (callback) {
    const channel = new MessageChannel();
    channel.port1.onmessage = function () {
      channel.port1.close();
      callback();
    }
    channel.port2.postMessage(undefined);
  }
}
```

MessageChannel 执行的是异步宏任务操作，下面一个使用的例子。

```js
if (enqueueTask) {
  enqueueTask(() => {
    console.log('in enqueueTask');
  });
}

Promise.resolve().then(() => console.log('Promise done!'))

console.log('start');

// start
// Promise done!
// in enqueueTask
```

[react-timer]: https://github.com/facebook/react/blob/cc015840ef72d48de86778785894c7ca44f4f856/packages/scheduler/src/forks/Scheduler.js#L532

### MessagePort

MessagePort 接口代表通过 `MessageChannel()` 构造函数创建的 channel 对象的端口。

#### 实例方法

MessagePort 接口有三个方法。

`postMessage()` 方法向另一个端口发送消息。

```js
postMessage(message)
postMessage(message, transfer)
postMessage(message, options)
```

- `message` 向对方发送的数据，可以是任意类型，但受[结构化克隆算法]的限制，如果是对象，会被[结构化克隆算法]处理。在接收端，通过回调函数的 `event.data` 来获取。该参数必须指定，如果没有数据要发送，可指定为 `null` 或者 `undefined`。
- `transfer` 可选的可转移对象数组，用于将当前上下文环境中的对象，转移到目标上下文，一旦转移完成，这些对象在当前上下文就不可用。注意，这些对象必须挂载到第一个参数对象中。
- `options` 可选的配置对象，该对象只有一个 `transfer` 属性，其作用跟上面的 `transfer` 一致。

下面是一个使用可转移对象的例子。

```javascript
// 发送 ArrayBuffer
const buffer = new ArrayBuffer(1024);
const uint8Array = new Uint8Array(buffer);
uint8Array.fill(42);

port.postMessage({
  type: 'arrayBuffer',
  buffer: buffer
}, [buffer]);

// 注意：buffer 在发送后在当前上下文中变为不可用
console.log(buffer.byteLength); // 0
```

[结构化克隆算法]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm

`start()` 开始发送消息，只有设置了 `addEventListener` 的端口才需要执行这个方法，如果指定了 `onmessage` 回调函数，则不需要执行该方法。

```js
// 不需要手动执行 start() 方法
channel.port1.onmessage = function (event) {
  para.innerHTML = event.data;
};

// 需要手动执行 start() 方法
channel.port1.addEventListener(
  'message',
  function (event) {
    // ...
  },
  false,
);

channel.port1.start();
```

`close()` 停止该端口发送消息。

#### 事件

`message` 事件在接收到另一个端口发来的消息时触发。

```js
addEventListener('message', event => { })
onmessage = event => {
  // event.data
  // event.origin
  // event.source
  // event.ports
  // event.lastEventId
}
```

- `data` 发送方发送的数据。
- `origin` 发送方的域名。
- `source` 发送方的引用。
- `ports` MessagePort 对象数组。
- `lastEventId` 事件 ID 字符串。

`messageerror` 事件在接受到一个不可序列化的数据时触发，该事件不能被取消且不会冒泡。

## 参考

- [Channel Messaging API](https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API), MDN
- [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), MDN
- [MessagePort](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort), MDN
