# 策略模式

## 一、介绍

策略模式（Strategy Pattern）是一种**行为型**设计模式，它定义了一系列算法，并将每一个算法封装起来，使它们可以互相替换。策略模式让算法的变化不会影响到使用算法的客户。

策略模式的核心思想是，将算法从使用算法的对象中分离出来，通过定义一系列算法类，使得算法可以独立于使用它的客户而变化。这样可以避免使用多重条件语句，同时提供更好的扩展性。

通过策略模式，可以实现算法的动态切换、消除条件语句和提高代码的可维护性等功能。不过，使用策略模式，会增加类的数量，造成系统复杂性增加，以及可能过度设计等。

策略模式中有三个参与者。

- **策略**（Strategy）：定义所有支持的算法的公共接口。Context 使用这个接口来调用某个 ConcreteStrategy 定义的算法。
- **具体策略**（ConcreteStrategy）：以 Strategy 接口实现某具体算法。
- **上下文**（Context）：维护对策略对象的引用，可以定义一个接口来让策略访问它的数据。

## 二、伪代码实现

```typescript
interface Strategy {
  execute(a: number, b: number): number;
}

class ConcreteStrategyA implements Strategy {
  public execute(a: number, b: number): number {
    return a + b;
  }
}

class ConcreteStrategyB implements Strategy {
  public execute(a: number, b: number): number {
    return a - b;
  }
}

class ConcreteStrategyC implements Strategy {
  public execute(a: number, b: number): number {
    return a * b;
  }
}

class Context {
  private strategy: Strategy;

  constructor(strategy: Strategy) {
    this.strategy = strategy;
  }

  public setStrategy(strategy: Strategy) {
    this.strategy = strategy;
  }

  public executeStrategy(a: number, b: number): number {
    return this.strategy.execute(a, b);
  }
}
```

下面是一个示例代码。

```typescript
const context = new Context(new ConcreteStrategyA());
console.log("10 + 5 = " + context.executeStrategy(10, 5));

context.setStrategy(new ConcreteStrategyB());
console.log("10 - 5 = " + context.executeStrategy(10, 5));

context.setStrategy(new ConcreteStrategyC());
console.log("10 * 5 = " + context.executeStrategy(10, 5));
```

## 三、React 中的策略模式应用

### 3.1 表单验证策略 - 验证算法策略

表单验证可以通过策略模式实现不同的验证算法。

```typescript
interface ValidationStrategy {
  validate(value: string): { isValid: boolean; message: string };
}

class EmailValidationStrategy implements ValidationStrategy {
  validate(value: string): { isValid: boolean; message: string } {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const isValid = emailRegex.test(value);
    return {
      isValid,
      message: isValid ? '' : 'Please enter a valid email address'
    };
  }
}

class PasswordValidationStrategy implements ValidationStrategy {
  validate(value: string): { isValid: boolean; message: string } {
    const hasMinLength = value.length >= 8;
    const hasUpperCase = /[A-Z]/.test(value);
    const hasLowerCase = /[a-z]/.test(value);
    const hasNumber = /\d/.test(value);
    
    const isValid = hasMinLength && hasUpperCase && hasLowerCase && hasNumber;
    return {
      isValid,
      message: isValid ? '' : 'Password must be at least 8 characters with uppercase, lowercase, and number'
    };
  }
}

class ValidationContext {
  private strategy: ValidationStrategy;

  constructor(strategy: ValidationStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: ValidationStrategy) {
    this.strategy = strategy;
  }

  validate(value: string) {
    return this.strategy.validate(value);
  }
}
```

下面是示例代码。

```jsx
const FormField: React.FC<{ 
  type: 'email' | 'password';
  value: string;
  onChange: (value: string) => void;
}> = ({ type, value, onChange }) => {
  const [error, setError] = useState('');
  
  const validationContext = useMemo(() => {
    const strategies = {
      email: new EmailValidationStrategy(),
      password: new PasswordValidationStrategy(),
    };
    return new ValidationContext(strategies[type]);
  }, [type]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    onChange(newValue);
    
    const validation = validationContext.validate(newValue);
    setError(validation.message);
  };

  return (
    <div>
      <input
        type={type === 'password' ? 'password' : 'text'}
        value={value}
        onChange={handleChange}
        placeholder={`Enter ${type}`}
      />
      {error && <span className="error">{error}</span>}
    </div>
  );
};

const Form: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  return (
    <form>
      <FormField type="email" value={email} onChange={setEmail} />
      <FormField type="password" value={password} onChange={setPassword} />
    </form>
  );
};
```

### 3.2 排序策略 - 排序算法策略

排序功能可以通过策略模式实现不同的排序算法。

```typescript
interface SortStrategy {
  sort<T>(array: T[]): T[];
}

class BubbleSortStrategy implements SortStrategy {
  sort<T>(array: T[]): T[] {
    const result = [...array];
    for (let i = 0; i < result.length; i++) {
      for (let j = 0; j < result.length - i - 1; j++) {
        if (result[j] > result[j + 1]) {
          [result[j], result[j + 1]] = [result[j + 1], result[j]];
        }
      }
    }
    return result;
  }
}

class QuickSortStrategy implements SortStrategy {
  sort<T>(array: T[]): T[] {
    if (array.length <= 1) return array;
    
    const pivot = array[Math.floor(array.length / 2)];
    const left = array.filter(item => item < pivot);
    const right = array.filter(item => item > pivot);
    
    return [...this.sort(left), pivot, ...this.sort(right)];
  }
}

class MergeSortStrategy implements SortStrategy {
  sort<T>(array: T[]): T[] {
    if (array.length <= 1) return array;
    
    const mid = Math.floor(array.length / 2);
    const left = this.sort(array.slice(0, mid));
    const right = this.sort(array.slice(mid));
    
    return this.merge(left, right);
  }

  private merge<T>(left: T[], right: T[]): T[] {
    const result: T[] = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
      if (left[i] <= right[j]) {
        result.push(left[i]);
        i++;
      } else {
        result.push(right[j]);
        j++;
      }
    }
    
    return result.concat(left.slice(i), right.slice(j));
  }
}

class SortContext {
  private strategy: SortStrategy;

  constructor(strategy: SortStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: SortStrategy) {
    this.strategy = strategy;
  }

  sort<T>(array: T[]): T[] {
    return this.strategy.sort(array);
  }
}
```

下面是示例代码。

```jsx
const SortableList: React.FC<{ items: number[] }> = ({ items }) => {
  const [sortedItems, setSortedItems] = useState(items);
  const [sortStrategy, setSortStrategy] = useState<'bubble' | 'quick' | 'merge'>('bubble');

  const sortContext = useMemo(() => {
    const strategies = {
      bubble: new BubbleSortStrategy(),
      quick: new QuickSortStrategy(),
      merge: new MergeSortStrategy(),
    };
    return new SortContext(strategies[sortStrategy]);
  }, [sortStrategy]);

  const handleSort = () => {
    const sorted = sortContext.sort([...items]);
    setSortedItems(sorted);
  };

  return (
    <div>
      <div>
        <label>Sort Strategy:</label>
        <select value={sortStrategy} onChange={(e) => setSortStrategy(e.target.value as any)}>
          <option value="bubble">Bubble Sort</option>
          <option value="quick">Quick Sort</option>
          <option value="merge">Merge Sort</option>
        </select>
        <button onClick={handleSort}>Sort</button>
      </div>
      <ul>
        {sortedItems.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
};
```

### 3.3 主题策略 - 主题切换策略

主题切换可以通过策略模式实现不同的主题算法。

```typescript
interface ThemeStrategy {
  getTheme(): { backgroundColor: string; textColor: string; accentColor: string };
}

class LightThemeStrategy implements ThemeStrategy {
  getTheme() {
    return {
      backgroundColor: '#ffffff',
      textColor: '#333333',
      accentColor: '#007bff'
    };
  }
}

class DarkThemeStrategy implements ThemeStrategy {
  getTheme() {
    return {
      backgroundColor: '#1a1a1a',
      textColor: '#ffffff',
      accentColor: '#00d4ff'
    };
  }
}

class ThemeContext {
  private strategy: ThemeStrategy;

  constructor(strategy: ThemeStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: ThemeStrategy) {
    this.strategy = strategy;
  }

  getTheme() {
    return this.strategy.getTheme();
  }
}
```

下面是示例代码。

```jsx
const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [themeType, setThemeType] = useState<'light' | 'dark';
  
  const themeContext = useMemo(() => {
    const strategies = {
      light: new LightThemeStrategy(),
      dark: new DarkThemeStrategy(),
    };
    return new ThemeContext(strategies[themeType]);
  }, [themeType]);

  const theme = themeContext.getTheme();

  return (
    <div style={{ backgroundColor: theme.backgroundColor, color: theme.textColor }}>
      <div>
        <label>Theme:</label>
        <select value={themeType} onChange={e => setThemeType(e.target.value as any)}>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
      </div>
      {children}
    </div>
  );
};

const App: React.FC = () => {
  return (
    <ThemeProvider>
      <h1>Welcome to our app</h1>
      <p>This is some content with different themes.</p>
      <button style={{ backgroundColor: '#007bff', color: 'white' }}>
        Click me
      </button>
    </ThemeProvider>
  );
};
```
