# 观察者模式与发布-订阅

## 一、观察者模式

### 一、介绍

观察者模式是一种**行为型**设计模式，它定义了一种**一对多**的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象的状态发生变化时，所有观察者都会收到通知并自动更新。

观察者模式中，有四个参与者。

- **主题**（Subject）：被观察的对象，维护观察者列表，提供添加、删除和通知观察者的方法。
- **具体主题**（ConcreteSubject）：具体被观察的对象，维护状态，状态改变时通知观察者。
- **观察者**（Observer）：观察主题的对象，定义更新接口。
- **具体观察者**（ConcreteObserver）：具体的观察者，实现更新接口。

观察者模式的优点是符合**开闭原则**，并且具有松耦合和可扩展的特点。缺点是，如果观察者没有正确移除，可能导致内存泄漏。如果观察者和主题之间的关系处理不当，还可以导致循环依赖，进而导致无限递归。观察者被通知的顺序也具有不确定性。

观察者模式适合多种场景，比如，事件绑定、消息推送、事件处理系统，以及一个对象的状态改变需要通知或改变其他对象时。都可以使用此模式。

### 二、代码实现

#### 2.1 TypeScript 实现

```typescript
interface Subject<T> {
  attach(observer: Observer<T>): void;
  detach(observer: Observer<T>): void;
  notify(data: T): void;
}

class ConcreteSubject<T> implements Subject<T> {
  private observers: Observer<T>[] = [];
  private state: T;

  constructor(initialState: T) {
    this.state = initialState;
  }

  attach(observer: Observer<T>): void {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
    }
  }

  detach(observer: Observer<T>): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  notify(data: T): void {
    this.observers.forEach(observer => observer.update(data));
  }

  updateState(state: T): void {
    this.state = state;
    this.notify(state);
  }
}

interface Observer<T> {
  update(data: T): void;
}

class ConcreteObserver<T> implements Observer<T> {
  private name: string;
  private callback?: (data: T) => void;

  constructor(name: string, callback?: (data: T) => void) {
    this.name = name;
    this.callback = callback;
  }

  update(data: T): void {
    if (this.callback) {
      this.callback(data);
    }
  }
}
```

下面是一个示例代码。

```typescript
const subject = new ConcreteSubject();

const observer1 = new ConcreteObserver('观察者1');
const observer2 = new ConcreteObserver('观察者2');
const observer3 = new ConcreteObserver('观察者3');

subject.attach(observer1);
subject.attach(observer2);
subject.attach(observer3);

subject.updateState({ payload: 'Hello World' });

subject.detach(observer2);

subject.updateState({ payload: 'Goodbye' });
```

#### 2.2 JavaScript 实现

```javascript
class Subject {
  constructor() {
    this.observers = [];
  }

  attach(observer) {
    const isExist = this.observers.includes(observer);
    if (isExist) return;
    this.observers.push(observer);
  }

  detach(observer) {
    const observerIndex = this.observers.indexOf(observer);
    if (observerIndex === -1) return;
    this.observers.splice(observerIndex, 1);
  }

  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class ConcreteSubject extends Subject {
  constructor() {
    super();
    this.state = null;
  }

  someBusinessLogic(state) {
    this.state = state;
    this.notify(state);
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) { }
}

class ConcreteObserver extends Observer {
  constructor(name) {
    super(name);
  }

  update(data) {
    super.update(data);
    // ...
  }
}
```

### 三、应用场景

#### 3.1 React Context API

React Context API 是观察者模式的典型实现。

```typescript
// 创建 Context（Subject）
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = React.createContext<ThemeContextType>({
  theme: 'light',
  toggleTheme: () => {},
});

// Provider 组件（Subject 实现）
const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  const toggleTheme = useCallback(() => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  }, []);

  const contextValue = useMemo(() => ({
    theme,
    toggleTheme
  }), [theme, toggleTheme]);

  return (
    <ThemeContext.Provider value={contextValue}>
      {children}
    </ThemeContext.Provider>
  );
};

// Consumer 组件（Observer 实现）
const ThemedButton: React.FC = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);
  
  return (
    <button 
      onClick={toggleTheme}
      style={{ 
        backgroundColor: theme === 'light' ? '#fff' : '#333',
        color: theme === 'light' ? '#333' : '#fff'
      }}
    >
      Current theme: {theme}
    </button>
  );
};

// 使用示例
const App: React.FC = () => {
  return (
    <ThemeProvider>
      <div>
        <ThemedButton />
      </div>
    </ThemeProvider>
  );
};
```

#### 3.2 React State 管理

```typescript
// 自定义 Hook 实现观察者模式
function useObservableState<T>(initialState: T) {
  const [state, setState] = useState<T>(initialState);
  const observers = useRef<Set<(state: T) => void>>(new Set());

  const subscribe = useCallback((observer: (state: T) => void) => {
    observers.current.add(observer);
    return () => observers.current.delete(observer);
  }, []);

  const updateState = useCallback((newState: T | ((prev: T) => T)) => {
    const actualNewState = typeof newState === 'function' 
      ? (newState as (prev: T) => T)(state) 
      : newState;
    
    setState(actualNewState);
    
    // 通知所有观察者
    observers.current.forEach(observer => {
      try {
        observer(actualNewState);
      } catch (error) {
        console.error('Error in observer:', error);
      }
    });
  }, [state]);

  return { state, updateState, subscribe };
}

// 使用示例
const UserProfile: React.FC = () => {
  const { state: user, updateState: updateUser, subscribe } = useObservableState<User>({
    id: '',
    name: '',
    email: ''
  });

  useEffect(() => {
    // 订阅用户状态变化
    const unsubscribe = subscribe((newUser) => {
      console.log('User state changed:', newUser);
      // 可以在这里执行副作用，比如更新localStorage
      localStorage.setItem('user', JSON.stringify(newUser));
    });

    return unsubscribe;
  }, [subscribe]);

  const handleLogin = () => {
    updateUser({
      id: '1',
      name: 'John Doe',
      email: 'john@example.com'
    });
  };

  return (
    <div>
      <p>User: {user.name}</p>
      <button onClick={handleLogin}>Login</button>
    </div>
  );
};
```

#### 3.3 React Event System

```typescript
// React事件系统的观察者模式实现
class ReactEventEmitter {
  private events = new Map<string, Set<Function>>();

  addEventListener(event: string, handler: Function) {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    this.events.get(event)!.add(handler);
  }

  removeEventListener(event: string, handler: Function) {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.delete(handler);
    }
  }

  emit(event: string, data?: any) {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error('Error in event handler:', error);
        }
      });
    }
  }
}

// 在React组件中使用
const EventComponent: React.FC = () => {
  const eventEmitter = useRef(new ReactEventEmitter());
  const [message, setMessage] = useState('');

  useEffect(() => {
    const handleCustomEvent = (data: any) => {
      setMessage(data.message);
    };

    eventEmitter.current.addEventListener('custom-event', handleCustomEvent);

    return () => {
      eventEmitter.current.removeEventListener('custom-event', handleCustomEvent);
    };
  }, []);

  const triggerEvent = () => {
    eventEmitter.current.emit('custom-event', { message: 'Hello from event!' });
  };

  return (
    <div>
      <p>Message: {message}</p>
      <button onClick={triggerEvent}>Trigger Event</button>
    </div>
  );
};
```

#### 3..4 父子组件通信

```typescript
const ParentComponent: React.FC = () => {
  const [data, setData] = useState('');

  const handleChildUpdate = (newData: string) => {
    setData(newData);
  };

  return (
    <div>
      <p>Parent data: {data}</p>
      <ChildComponent onUpdate={handleChildUpdate} />
    </div>
  );
};

const ChildComponent: React.FC<{ onUpdate: (data: string) => void }> = ({ onUpdate }) => {
  const handleClick = () => {
    onUpdate('Updated from child');
  };

  return <button onClick={handleClick}>Update Parent</button>;
};
```

#### 3.5 消息推送系统

```javascript
class MessageCenter {
  constructor() {
    this.subscribers = new Map();
  }

  // 订阅消息
  subscribe(topic, callback) {
    if (!this.subscribers.has(topic)) {
      this.subscribers.set(topic, []);
    }
    this.subscribers.get(topic).push(callback);
  }

  // 取消订阅
  unsubscribe(topic, callback) {
    if (!this.subscribers.has(topic)) return;
    const callbacks = this.subscribers.get(topic);
    const index = callbacks.indexOf(callback);
    if (index > -1) {
      callbacks.splice(index, 1);
    }
  }

  // 发布消息
  publish(topic, data) {
    if (!this.subscribers.has(topic)) return;
    this.subscribers.get(topic).forEach(callback => callback(data));
  }
}

const messageCenter = new MessageCenter();

messageCenter.subscribe('userLogin', (user) => {
  console.log('用户登录:', user);
});
messageCenter.subscribe('userLogin', (user) => {
  console.log('更新用户信息:', user);
});

messageCenter.publish('userLogin', { id: 1, name: 'John' });
```

#### 3.6 Web APIs

像 `IntersectionObserver` 这样的浏览器 API 允许组件观察 DOM 元素的变化，例如可见性或大小。

## 二、发布-订阅

### 2.1 介绍

发布-订阅（Publish–subscribe pattern）是一种**基于事件的通信机制**，它定义了一种**一对多**或**多对多**的依赖关系。

发布-订阅模式将发布者与订阅者解耦，他们之间没有直接的依赖关系。发布者不需要知道订阅者是谁，甚至也不需要知道订阅者是否存在；同样地，订阅者也不需要知道发布者是谁，甚至发布者是否存在。

发布-订阅模式的关键在于中间角色事件中心（Event Bus），负责事件的接收和分发工作。

发布-订阅模式有三个主要组成部分：发布者、订阅者和事件中心。

- **发布者**（Publisher）：向事件中心发送事件或消息。
- **订阅者**（Subscriber）：向事件中心注册感兴趣的事件，处理接收到的消息以及取消订阅。
- **事件中心**（Event Bus）：管理事件注册，维护订阅关系。接收发布者的事件并将其分发给符合条件的订阅者。

发布订阅模式，符合以下设计原则。

- 单一职责：每个发布者和订阅者只负责自己的职责。
- 开闭原则：对扩展开放，对修改关闭。
- 依赖倒置：依赖抽象而不是具体实现。
- 接口隔离：使用小而精确的接口。

### 2.2 代码实现

```typescript
type EventType = string | symbol;
type EventHandler<T = any> = (data: T) => void;
type EventMap = Map<EventType, Set<EventHandler>>;

interface IEventBus {
  subscribe<T>(event: EventType, handler: EventHandler<T>): void;
  unsubscribe<T>(event: EventType, handler: EventHandler<T>): void;
  publish<T>(event: EventType, data?: T): void;
  clear(): void;
}

class EventBus implements IEventBus {
  private events: EventMap = new Map();

  subscribe<T>(event: EventType, handler: EventHandler<T>): void {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    this.events.get(event)!.add(handler);
  }

  unsubscribe<T>(event: EventType, handler: EventHandler<T>): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.delete(handler);
      if (handlers.size === 0) {
        this.events.delete(event);
      }
    }
  }

  publish<T>(event: EventType, data?: T): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Error in event handler for ${String(event)}:`, error);
        }
      });
    }
  }

  clear(): void {
    this.events.clear();
  }
}

interface IPublisher {
  publish<T>(event: EventType, data?: T): void;
}

class Publisher implements IPublisher {
  constructor(private eventBus: EventBus) {}
  publish<T>(event: EventType, data?: T): void {
    this.eventBus.publish(event, data);
  }
}

interface ISubscriber {
  subscribe<T>(event: EventType, handler: EventHandler<T>): void;
  unsubscribe<T>(event: EventType, handler: EventHandler<T>): void;
}

class Subscriber implements ISubscriber {
  private handlers: Map<EventType, EventHandler> = new Map();

  constructor(private eventBus: EventBus) {}

  subscribe<T>(event: EventType, handler: EventHandler<T>): void {
    this.handlers.set(event, handler);
    this.eventBus.subscribe(event, handler);
  }

  unsubscribe<T>(event: EventType, handler: EventHandler<T>): void {
    this.handlers.delete(event);
    this.eventBus.unsubscribe(event, handler);
  }

  unsubscribeAll(): void {
    this.handlers.forEach((handler, event) => {
      this.eventBus.unsubscribe(event, handler);
    });
    this.handlers.clear();
  }
}
```

下面是一个示例代码。

```typescript
enum EventTypes {
  USER_LOGIN = 'user:login',
  USER_LOGOUT = 'user:logout',
}

interface UserLoginData {
  userId: string;
}

const eventBus = new EventBus();
  
const pub = new Publisher(eventBus);

const sub1 = new Subscriber(eventBus);
const sub2 = new Subscriber(eventBus);

sub1.subscribe(EventTypes.USER_LOGIN, (data: UserLoginData) => {
  console.log('Subscriber 1: User logged in', data);
});

sub2.subscribe(EventTypes.USER_LOGIN, (data: UserLoginData) => {
  console.log('Subscriber 2: User logged in', data);
});

pub.publish(EventTypes.USER_LOGIN, {
  userId: '123',
});

sub1.unsubscribeAll();
```

### 2.3 应用

#### （1）全局事件总线

```typescript
class GlobalEventBus {
  private static instance: GlobalEventBus;
  private events = new Map<string, Set<Function>>();
  private subscriptionId = 0;
  private subscriptions = new Map<string, { event: string; handler: Function }>();

  static getInstance(): GlobalEventBus {
    if (!GlobalEventBus.instance) {
      GlobalEventBus.instance = new GlobalEventBus();
    }
    return GlobalEventBus.instance;
  }

  subscribe(event: string, handler: Function): string {
    const subscriptionId = `sub_${++this.subscriptionId}`;
    
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    
    this.events.get(event)!.add(handler);
    this.subscriptions.set(subscriptionId, { event, handler });
    
    return subscriptionId;
  }

  unsubscribe(subscriptionId: string): boolean {
    const subscription = this.subscriptions.get(subscriptionId);
    if (subscription) {
      const { event, handler } = subscription;
      const handlers = this.events.get(event);
      if (handlers) {
        handlers.delete(handler);
        if (handlers.size === 0) {
          this.events.delete(event);
        }
      }
      this.subscriptions.delete(subscriptionId);
      return true;
    }
    return false;
  }

  publish(event: string, data?: any): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error('Error in event handler:', error);
        }
      });
    }
  }

  clear(): void {
    this.events.clear();
    this.subscriptions.clear();
  }
}

function useEventBus() {
  const eventBus = useRef(GlobalEventBus.getInstance());
  const subscriptions = useRef<Set<string>>(new Set());

  const subscribe = useCallback((event: string, handler: Function): string => {
    const subscriptionId = eventBus.current.subscribe(event, handler);
    subscriptions.current.add(subscriptionId);
    return subscriptionId;
  }, []);

  const unsubscribe = useCallback((subscriptionId: string) => {
    eventBus.current.unsubscribe(subscriptionId);
    subscriptions.current.delete(subscriptionId);
  }, []);

  const publish = useCallback((event: string, data?: any) => {
    eventBus.current.publish(event, data);
  }, []);

  useEffect(() => {
    return () => {
      subscriptions.current.forEach(subscriptionId => {
        eventBus.current.unsubscribe(subscriptionId);
      });
      subscriptions.current.clear();
    };
  }, []);

  return { subscribe, unsubscribe, publish };
}
```

#### （2）状态管理库集成

基于发布-订阅模式的状态管理。

```typescript
class EventBasedStore<T> {
  private state: T;
  private eventBus: GlobalEventBus;
  private subscribers = new Set<(state: T) => void>();

  constructor(initialState: T) {
    this.state = initialState;
    this.eventBus = GlobalEventBus.getInstance();
    
    this.eventBus.subscribe('state:changed', (newState: T) => {
      this.state = newState;
      this.notifySubscribers();
    });
  }

  subscribe(callback: (state: T) => void): () => void {
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }

  private notifySubscribers(): void {
    this.subscribers.forEach(callback => {
      try {
        callback(this.state);
      } catch (error) {
        console.error('Error in state subscriber:', error);
      }
    });
  }

  setState(updater: (state: T) => T): void {
    const newState = updater(this.state);
    this.eventBus.publish('state:changed', newState);
  }

  getState(): T {
    return this.state;
  }
}

function useEventStore<T>(store: EventBasedStore<T>): [T, (updater: (state: T) => T) => void] {
  const [state, setState] = useState<T>(store.getState());

  useEffect(() => {
    return store.subscribe(setState);
  }, [store]);

  const updateState = useCallback((updater: (state: T) => T) => {
    store.setState(updater);
  }, [store]);

  return [state, updateState];
}
```

示例代码。

```typescript
interface AppState {
  user: User | null;
  theme: 'light' | 'dark';
  notifications: Notification[];
}

const appStore = new EventBasedStore<AppState>({
  user: null,
  theme: 'light',
  notifications: []
});

const AppComponent: React.FC = () => {
  const [state, setState] = useEventStore(appStore);

  const login = (user: User) => {
    setState(prev => ({ ...prev, user }));
  };

  const toggleTheme = () => {
    setState(prev => ({ ...prev, theme: prev.theme === 'light' ? 'dark' : 'light' }));
  };

  return (
    <div className={`app ${state.theme}`}>
      {state.user ? (
        <div>
          <p>Welcome, {state.user.name}!</p>
          <button onClick={toggleTheme}>Toggle Theme</button>
        </div>
      ) : (
        <button onClick={() => login({ id: '1', name: 'John' })}>Login</button>
      )}
    </div>
  );
};
```

#### （3）组件间通信

父子组件通信。

```typescript
const ParentComponent: React.FC = () => {
  const { subscribe, publish } = useEventBus();
  const [childData, setChildData] = useState('');

  useEffect(() => {
    const handleChildMessage = (data: any) => {
      setChildData(data.message);
    };

    const subscriptionId = subscribe('child:message', handleChildMessage);
    return () => unsubscribe(subscriptionId);
  }, []);

  const sendToChild = () => {
    publish('parent:message', { message: 'Hello from parent!' });
  };

  return (
    <div>
      <p>Child data: {childData}</p>
      <button onClick={sendToChild}>Send to Child</button>
      <Child />
    </div>
  );
};

const ChildComponent: React.FC = () => {
  const { subscribe, publish } = useEventBus();
  const [parentData, setParentData] = useState('');

  useEffect(() => {
    const handleParentMessage = (data: any) => {
      setParentData(data.message);
    };

    const subscriptionId = subscribe('parent:message', handleParentMessage);
    return () => unsubscribe(subscriptionId);
  }, []);

  const sendToParent = () => {
    publish('child:message', { message: 'Hello from child!' });
  };

  return (
    <div>
      <p>Parent data: {parentData}</p>
      <button onClick={sendToParent}>Send to Parent</button>
    </div>
  );
};
```

#### （4）跨组件通信

```typescript
const HeaderComponent: React.FC = () => {
  const { publish } = useEventBus();

  const handleSearch = (query: string) => {
    publish('search:query', { query, timestamp: Date.now() });
  };

  return (
    <header>
      <SearchBar onSearch={handleSearch} />
    </header>
  );
};

const SidebarComponent: React.FC = () => {
  const { subscribe } = useEventBus();
  const [searchResults, setSearchResults] = useState([]);

  useEffect(() => {
    const subscriptionId = subscribe('search:query', (data) => {
      performSearch(data.query).then(results => {
        setSearchResults(results);
      });
    });

    return () => subscriptionId && unsubscribe(subscriptionId);
  }, []);

  return (
    <aside>
      <SearchResults results={searchResults} />
    </aside>
  );
};
```

#### （5）防抖和节流

```typescript
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

function useThrottle<T>(value: T, delay: number): T {
  const [throttledValue, setThrottledValue] = useState<T>(value);
  const lastRun = useRef(Date.now());

  useEffect(() => {
    const handler = setTimeout(() => {
      if (Date.now() - lastRun.current >= delay) {
        setThrottledValue(value);
        lastRun.current = Date.now();
      }
    }, delay - (Date.now() - lastRun.current));

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return throttledValue;
}
```

下面是一个使用示例。

```typescript
const SearchComponent: React.FC = () => {
  const { publish } = useEventBus();
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 300);

  useEffect(() => {
    if (debouncedQuery) {
      publish('search:query', { query: debouncedQuery });
    }
  }, [debouncedQuery, publish]);

  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="Search..."
    />
  );
};
```

#### （6）错误处理

```typescript
// 带错误处理的 EventBus
class RobustEventBus implements IEventBus {
  private events = new Map<EventType, Set<EventHandler>>();
  private errorHandlers = new Set<(error: Error, event: EventType) => void>();

  onError(handler: (error: Error, event: EventType) => void): void {
    this.errorHandlers.add(handler);
  }

  offError(handler: (error: Error, event: EventType) => void): void {
    this.errorHandlers.delete(handler);
  }

  publish<T>(event: EventType, data?: T): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          this.handleError(error as Error, event);
        }
      });
    }
  }

  private handleError(error: Error, event: EventType): void {
    this.errorHandlers.forEach(handler => {
      try {
        handler(error, event);
      } catch (handlerError) {
        console.error('Error in error handler:', handlerError);
      }
    });
  }
}
```

## 三、观察者模式与发布-订阅的对比

- 耦合度：观察者模式**耦合度高**（直接依赖）；发布-订阅模式的**耦合度低**（通过事件中心解耦）。
- 通信方式：观察者模式直接调用；发布-订阅模式基于**事件驱动**。
- 角色关系：观察者模式是一种**一对多**的关系；发布-订阅模式是一种**一对多**，或者**多对多**的关系。
- 实现复杂度：观察者模式简单；发布-订阅模式复杂。
- 扩展性：观察者模式较差；发布-订阅模式较好。
- 性能：观察者模式较好；发布-订阅模式稍差。
