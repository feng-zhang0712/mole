# 观察者模式与发布-订阅

## 一、观察者模式

### 1.1 介绍

观察者模式是一种**行为型**设计模式，它定义了一种**一对多**的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象的状态发生变化时，所有观察者都会收到通知并自动更新。

观察者模式中，有四个参与者。

- **主题**（Subject）：被观察的对象，维护观察者列表，提供添加、删除和通知观察者的方法。
- **具体主题**（ConcreteSubject）：具体被观察的对象，维护状态，状态改变时通知观察者。
- **观察者**（Observer）：观察主题的对象，定义更新接口。
- **具体观察者**（ConcreteObserver）：具体的观察者，实现更新接口。

观察者模式的优点是符合**开闭原则**，并且具有松耦合和可扩展的特点。缺点是，如果观察者没有正确移除，可能导致内存泄漏。如果观察者和主题之间的关系处理不当，还可以导致循环依赖，进而导致无限递归。观察者被通知的顺序也具有不确定性。

观察者模式适合多种场景，比如，事件绑定、消息推送、事件处理系统，以及一个对象的状态改变需要通知或改变其他对象时。都可以使用此模式。

### 1.2 代码实现

#### （1）TypeScript 实现

```typescript
interface Subject<T> {
  attach(observer: Observer<T>): void;
  detach(observer: Observer<T>): void;
  notify(data: T): void;
}

class ConcreteSubject<T> implements Subject<T> {
  private observers: Observer<T>[] = [];
  private state: T;

  constructor(initialState: T) {
    this.state = initialState;
  }

  attach(observer: Observer<T>): void {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
    }
  }

  detach(observer: Observer<T>): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  notify(data: T): void {
    this.observers.forEach(observer => observer.update(data));
  }

  someBusinessLogic(state: T): void {
    this.state = state;
    this.notify(state);
  }
}

interface Observer<T> {
  update(data: T): void;
}

class ConcreteObserver<T> implements Observer<T> {
  private name: string;
  private callback?: (data: T) => void;

  constructor(name: string, callback?: (data: T) => void) {
    this.name = name;
    this.callback = callback;
  }

  update(data: T): void {
    if (this.callback) {
      this.callback(data);
    }
  }
}
```

下面是一个示例代码。

```typescript
const subject = new ConcreteSubject();

const observer1 = new ConcreteObserver('观察者1');
const observer2 = new ConcreteObserver('观察者2');
const observer3 = new ConcreteObserver('观察者3');

subject.attach(observer1);
subject.attach(observer2);
subject.attach(observer3);

subject.someBusinessLogic({
  payload: 'Hello World',
});

subject.detach(observer2);

subject.someBusinessLogic({
  payload: 'Goodbye',
});
```

#### （2）JavaScript 实现

```javascript
class Subject {
  constructor() {
    this.observers = [];
  }

  attach(observer) {
    const isExist = this.observers.includes(observer);
    if (isExist) return;
    this.observers.push(observer);
  }

  detach(observer) {
    const observerIndex = this.observers.indexOf(observer);
    if (observerIndex === -1) return;
    this.observers.splice(observerIndex, 1);
  }

  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class ConcreteSubject extends Subject {
  constructor() {
    super();
    this.state = null;
  }

  someBusinessLogic(state) {
    this.state = state;
    this.notify(state);
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) { }
}

class ConcreteObserver extends Observer {
  constructor(name) {
    super(name);
  }

  update(data) {
    super.update(data);
    // ...
  }
}
```

## 二、应用场景

### 2.1 React Context API

React Context API 是观察者模式的典型实现。

```typescript
// 创建 Context（Subject）
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = React.createContext<ThemeContextType>({
  theme: 'light',
  toggleTheme: () => {},
});

// Provider 组件（Subject 实现）
const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  const toggleTheme = useCallback(() => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  }, []);

  const contextValue = useMemo(() => ({
    theme,
    toggleTheme
  }), [theme, toggleTheme]);

  return (
    <ThemeContext.Provider value={contextValue}>
      {children}
    </ThemeContext.Provider>
  );
};

// Consumer 组件（Observer 实现）
const ThemedButton: React.FC = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);
  
  return (
    <button 
      onClick={toggleTheme}
      style={{ 
        backgroundColor: theme === 'light' ? '#fff' : '#333',
        color: theme === 'light' ? '#333' : '#fff'
      }}
    >
      Current theme: {theme}
    </button>
  );
};

// 使用示例
const App: React.FC = () => {
  return (
    <ThemeProvider>
      <div>
        <ThemedButton />
      </div>
    </ThemeProvider>
  );
};
```

### 2.2 React State 管理

```typescript
// 自定义 Hook 实现观察者模式
function useObservableState<T>(initialState: T) {
  const [state, setState] = useState<T>(initialState);
  const observers = useRef<Set<(state: T) => void>>(new Set());

  const subscribe = useCallback((observer: (state: T) => void) => {
    observers.current.add(observer);
    return () => observers.current.delete(observer);
  }, []);

  const updateState = useCallback((newState: T | ((prev: T) => T)) => {
    const actualNewState = typeof newState === 'function' 
      ? (newState as (prev: T) => T)(state) 
      : newState;
    
    setState(actualNewState);
    
    // 通知所有观察者
    observers.current.forEach(observer => {
      try {
        observer(actualNewState);
      } catch (error) {
        console.error('Error in observer:', error);
      }
    });
  }, [state]);

  return { state, updateState, subscribe };
}

// 使用示例
const UserProfile: React.FC = () => {
  const { state: user, updateState: updateUser, subscribe } = useObservableState<User>({
    id: '',
    name: '',
    email: ''
  });

  useEffect(() => {
    // 订阅用户状态变化
    const unsubscribe = subscribe((newUser) => {
      console.log('User state changed:', newUser);
      // 可以在这里执行副作用，比如更新localStorage
      localStorage.setItem('user', JSON.stringify(newUser));
    });

    return unsubscribe;
  }, [subscribe]);

  const handleLogin = () => {
    updateUser({
      id: '1',
      name: 'John Doe',
      email: 'john@example.com'
    });
  };

  return (
    <div>
      <p>User: {user.name}</p>
      <button onClick={handleLogin}>Login</button>
    </div>
  );
};
```

### 2.3 React Event System

```typescript
// React事件系统的观察者模式实现
class ReactEventEmitter {
  private events = new Map<string, Set<Function>>();

  addEventListener(event: string, handler: Function) {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    this.events.get(event)!.add(handler);
  }

  removeEventListener(event: string, handler: Function) {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.delete(handler);
    }
  }

  emit(event: string, data?: any) {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error('Error in event handler:', error);
        }
      });
    }
  }
}

// 在React组件中使用
const EventComponent: React.FC = () => {
  const eventEmitter = useRef(new ReactEventEmitter());
  const [message, setMessage] = useState('');

  useEffect(() => {
    const handleCustomEvent = (data: any) => {
      setMessage(data.message);
    };

    eventEmitter.current.addEventListener('custom-event', handleCustomEvent);

    return () => {
      eventEmitter.current.removeEventListener('custom-event', handleCustomEvent);
    };
  }, []);

  const triggerEvent = () => {
    eventEmitter.current.emit('custom-event', { message: 'Hello from event!' });
  };

  return (
    <div>
      <p>Message: {message}</p>
      <button onClick={triggerEvent}>Trigger Event</button>
    </div>
  );
};
```

### 2.4 父子组件通信

```typescript
const ParentComponent: React.FC = () => {
  const [data, setData] = useState('');

  const handleChildUpdate = (newData: string) => {
    setData(newData);
  };

  return (
    <div>
      <p>Parent data: {data}</p>
      <ChildComponent onUpdate={handleChildUpdate} />
    </div>
  );
};

const ChildComponent: React.FC<{ onUpdate: (data: string) => void }> = ({ onUpdate }) => {
  const handleClick = () => {
    onUpdate('Updated from child');
  };

  return <button onClick={handleClick}>Update Parent</button>;
};
```

### 2.5 消息推送系统

```javascript
class MessageCenter {
  constructor() {
    this.subscribers = new Map();
  }

  // 订阅消息
  subscribe(topic, callback) {
    if (!this.subscribers.has(topic)) {
      this.subscribers.set(topic, []);
    }
    this.subscribers.get(topic).push(callback);
  }

  // 取消订阅
  unsubscribe(topic, callback) {
    if (!this.subscribers.has(topic)) return;
    const callbacks = this.subscribers.get(topic);
    const index = callbacks.indexOf(callback);
    if (index > -1) {
      callbacks.splice(index, 1);
    }
  }

  // 发布消息
  publish(topic, data) {
    if (!this.subscribers.has(topic)) return;
    this.subscribers.get(topic).forEach(callback => callback(data));
  }
}

const messageCenter = new MessageCenter();

messageCenter.subscribe('userLogin', (user) => {
  console.log('用户登录:', user);
});
messageCenter.subscribe('userLogin', (user) => {
  console.log('更新用户信息:', user);
});

messageCenter.publish('userLogin', { id: 1, name: 'John' });
```

### 2.6 Web APIs

像 `IntersectionObserver` 这样的浏览器 API 允许组件观察 DOM 元素的变化，例如可见性或大小。

## 二、发布-订阅

### 2.1 介绍

发布-订阅（Publish–subscribe pattern）是一种**基于事件的通信机制**，它定义了一种**一对多**或**多对多**的依赖关系。

发布-订阅模式将发布者与订阅者解耦，他们之间没有直接的依赖关系。发布者不需要知道订阅者是谁，甚至也不需要知道订阅者是否存在；同样地，订阅者也不需要知道发布者是谁，甚至发布者是否存在。

发布-订阅模式的关键在于中间角色事件中心（Event Bus），负责事件的接收和分发工作。

发布-订阅模式有三个主要组成部分：**发布者**、**订阅者**和**事件中心**。

- **发布者**（Publisher）：向事件中心发送事件或消息。
- **订阅者**（Subscriber）：向事件中心注册感兴趣的事件，处理接收到的消息以及取消订阅。
- **事件中心**（Event Bus）：管理事件注册，维护订阅关系。接收发布者的事件并将其分发给符合条件的订阅者。

发布订阅模式，符合以下设计原则。

- 单一职责：每个发布者和订阅者只负责自己的职责。
- 开闭原则：对扩展开放，对修改关闭。
- 依赖倒置：依赖抽象而不是具体实现。
- 接口隔离：使用小而精确的接口。

### 2.2 代码实现

```typescript
type EventType = string | symbol;
type EventHandler<T = any> = (data: T) => void;
type EventMap = Map<EventType, Set<EventHandler>>;

// 事件中心接口
interface IEventBus {
  subscribe<T>(event: EventType, handler: EventHandler<T>): void;
  unsubscribe<T>(event: EventType, handler: EventHandler<T>): void;
  publish<T>(event: EventType, data?: T): void;
  clear(): void;
}

// 事件中心实现
class EventBus implements IEventBus {
  private events: EventMap = new Map();

  subscribe<T>(event: EventType, handler: EventHandler<T>): void {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    this.events.get(event)!.add(handler);
  }

  unsubscribe<T>(event: EventType, handler: EventHandler<T>): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.delete(handler);
      if (handlers.size === 0) {
        this.events.delete(event);
      }
    }
  }

  publish<T>(event: EventType, data?: T): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Error in event handler for ${String(event)}:`, error);
        }
      });
    }
  }

  clear(): void {
    this.events.clear();
  }

  getSubscriberCount(event: EventType): number {
    return this.events.get(event)?.size || 0;
  }

  hasSubscribers(event: EventType): boolean {
    return this.getSubscriberCount(event) > 0;
  }
}

// 发布者接口
interface IPublisher {
  publish<T>(event: EventType, data?: T): void;
}

class Publisher implements IPublisher {
  constructor(private eventBus: EventBus) {}

  publish<T>(event: EventType, data?: T): void {
    this.eventBus.publish(event, data);
  }
}

// 订阅者接口
interface ISubscriber {
  subscribe<T>(event: EventType, handler: EventHandler<T>): void;
  unsubscribe<T>(event: EventType, handler: EventHandler<T>): void;
}

class Subscriber implements ISubscriber {
  private handlers: Map<EventType, EventHandler> = new Map();

  constructor(private eventBus: EventBus) {}

  subscribe<T>(event: EventType, handler: EventHandler<T>): void {
    this.handlers.set(event, handler);
    this.eventBus.subscribe(event, handler);
  }

  unsubscribe<T>(event: EventType, handler: EventHandler<T>): void {
    this.handlers.delete(event);
    this.eventBus.unsubscribe(event, handler);
  }

  unsubscribeAll(): void {
    this.handlers.forEach((handler, event) => {
      this.eventBus.unsubscribe(event, handler);
    });
    this.handlers.clear();
  }
}
```

下面是一个高级实现（支持异步和错误处理）。

```typescript
// 异步事件处理器类型
type AsyncEventHandler<T = any> = (data: T) => Promise<void> | void;

// 事件选项接口
interface EventOptions {
  once?: boolean; // 是否只执行一次
  priority?: number; // 优先级
  timeout?: number; // 超时时间
}

// 事件订阅信息
interface SubscriptionInfo {
  handler: AsyncEventHandler;
  options: EventOptions;
  id: string;
}

// 高级事件中心
class AdvancedEventBus implements IEventBus {
  private events: Map<EventType, SubscriptionInfo[]> = new Map();
  private subscriptionId = 0;

  subscribe<T>(
    event: EventType, 
    handler: AsyncEventHandler<T>, 
    options: EventOptions = {}
  ): string {
    const subscriptionId = this.generateSubscriptionId();
    const subscriptionInfo: SubscriptionInfo = {
      handler,
      options: { once: false, priority: 0, timeout: 5000, ...options },
      id: subscriptionId
    };

    if (!this.events.has(event)) {
      this.events.set(event, []);
    }

    const subscriptions = this.events.get(event)!;
    subscriptions.push(subscriptionInfo);
    
    // 按优先级排序
    subscriptions.sort((a, b) => (b.options.priority || 0) - (a.options.priority || 0));

    return subscriptionId;
  }

  async publish<T>(event: EventType, data?: T): Promise<void> {
    const subscriptions = this.events.get(event);
    if (!subscriptions || subscriptions.length === 0) {
      return;
    }

    const promises: Promise<void>[] = [];
    const toRemove: string[] = [];

    for (const subscription of subscriptions) {
      const promise = this.executeHandler(subscription, data);
      promises.push(promise);

      if (subscription.options.once) {
        toRemove.push(subscription.id);
      }
    }

    // 移除一次性订阅
    toRemove.forEach(id => this.removeSubscription(event, id));

    // 等待所有处理器完成
    await Promise.allSettled(promises);
  }

  // 执行事件处理器
  private async executeHandler<T>(subscription: SubscriptionInfo, data?: T): Promise<void> {
    const { handler, options } = subscription;
    
    try {
      if (options.timeout) {
        await Promise.race([
          handler(data),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Handler timeout')), options.timeout)
          )
        ]);
      } else {
        await handler(data);
      }
    } catch (error) {
      console.error(`Error in event handler ${subscription.id}:`, error);
    }
  }

  unsubscribeById(event: EventType, subscriptionId: string): boolean {
    return this.removeSubscription(event, subscriptionId);
  }

  private removeSubscription(event: EventType, subscriptionId: string): boolean {
    const subscriptions = this.events.get(event);
    if (!subscriptions) {
      return false;
    }

    const index = subscriptions.findIndex(sub => sub.id === subscriptionId);
    if (index !== -1) {
      subscriptions.splice(index, 1);
      if (subscriptions.length === 0) {
        this.events.delete(event);
      }
      return true;
    }
    return false;
  }

  private generateSubscriptionId(): string {
    return `sub_${++this.subscriptionId}_${Date.now()}`;
  }

  unsubscribe<T>(event: EventType, handler: AsyncEventHandler<T>): void {
    const subscriptions = this.events.get(event);
    if (subscriptions) {
      const index = subscriptions.findIndex(sub => sub.handler === handler);
      if (index !== -1) {
        subscriptions.splice(index, 1);
        if (subscriptions.length === 0) {
          this.events.delete(event);
        }
      }
    }
  }

  clear(): void {
    this.events.clear();
  }
}
```

下面是示例代码。

```typescript
// 定义事件类型
enum EventTypes {
  USER_LOGIN = 'user:login',
  USER_LOGOUT = 'user:logout',
  DATA_UPDATED = 'data:updated',
  ERROR_OCCURRED = 'error:occurred'
}

// 定义事件数据类型
interface UserLoginData {
  userId: string;
  username: string;
  timestamp: Date;
}

interface DataUpdateData {
  table: string;
  recordId: string;
  changes: Record<string, any>;
}

async function example() {
  const eventBus = new AdvancedEventBus();
  
  const publisher = new Publisher(eventBus);
  const subscriber1 = new Subscriber(eventBus);
  const subscriber2 = new Subscriber(eventBus);

  // 订阅事件
  subscriber1.subscribe(EventTypes.USER_LOGIN, async (data: UserLoginData) => {
    console.log('Subscriber 1: User logged in', data);
    await new Promise(resolve => setTimeout(resolve, 100));
  });

  subscriber2.subscribe(EventTypes.USER_LOGIN, (data: UserLoginData) => {
    console.log('Subscriber 2: User logged in', data);
  });

  // 高级订阅（一次性，高优先级）
  const subscriptionId = eventBus.subscribe(
    EventTypes.USER_LOGIN,
    async (data: UserLoginData) => {
      console.log('High priority subscriber: User logged in', data);
    },
    { once: true, priority: 10 }
  );

  // 发布事件
  const loginData: UserLoginData = {
    userId: '123',
    username: 'john_doe',
    timestamp: new Date()
  };

  await publisher.publish(EventTypes.USER_LOGIN, loginData);

  // 取消订阅
  subscriber1.unsubscribeAll();
  eventBus.unsubscribeById(EventTypes.USER_LOGIN, subscriptionId);
}

// 运行示例
example().catch(console.error);
```

### 2.3 高级特性实现

#### （1）异步事件处理

```typescript
// 异步事件处理器
type AsyncEventHandler<T = any> = (data: T) => Promise<void> | void;

// 事件选项
interface EventOptions {
  once?: boolean;           // 是否只执行一次
  priority?: number;        // 优先级
  timeout?: number;         // 超时时间
  retry?: number;           // 重试次数
}

// 高级事件中心
class AdvancedEventBus {
  private events = new Map<EventType, Array<{
    handler: AsyncEventHandler;
    options: EventOptions;
    id: string;
  }>>();
  private subscriptionId = 0;

  // 订阅事件
  subscribe<T>(
    event: EventType, 
    handler: AsyncEventHandler<T>, 
    options: EventOptions = {}
  ): string {
    const subscriptionId = `sub_${++this.subscriptionId}_${Date.now()}`;
    const subscriptionInfo = {
      handler,
      options: { 
        once: false, 
        priority: 0, 
        timeout: 5000, 
        retry: 0,
        ...options 
      },
      id: subscriptionId
    };

    if (!this.events.has(event)) {
      this.events.set(event, []);
    }

    const subscriptions = this.events.get(event)!;
    subscriptions.push(subscriptionInfo);
    
    // 按优先级排序
    subscriptions.sort((a, b) => (b.options.priority || 0) - (a.options.priority || 0));

    return subscriptionId;
  }

  // 发布事件
  async publish<T>(event: EventType, data?: T): Promise<void> {
    const subscriptions = this.events.get(event);
    if (!subscriptions || subscriptions.length === 0) return;

    const promises: Promise<void>[] = [];
    const toRemove: string[] = [];

    for (const subscription of subscriptions) {
      const promise = this.executeHandler(subscription, data);
      promises.push(promise);

      if (subscription.options.once) {
        toRemove.push(subscription.id);
      }
    }

    // 移除一次性订阅
    toRemove.forEach(id => this.removeSubscription(event, id));

    // 等待所有处理器完成
    await Promise.allSettled(promises);
  }

  // 执行处理器
  private async executeHandler<T>(
    subscription: { handler: AsyncEventHandler; options: EventOptions; id: string }, 
    data?: T
  ): Promise<void> {
    const { handler, options } = subscription;
    
    let retryCount = 0;
    const maxRetries = options.retry || 0;

    while (retryCount <= maxRetries) {
      try {
        if (options.timeout) {
          await Promise.race([
            handler(data),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('Handler timeout')), options.timeout)
            )
          ]);
        } else {
          await handler(data);
        }
        break; // 成功执行，跳出重试循环
      } catch (error) {
        retryCount++;
        if (retryCount > maxRetries) {
          console.error(`Error in event handler ${subscription.id} after ${maxRetries} retries:`, error);
          throw error;
        }
        // 等待一段时间后重试
        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
      }
    }
  }

  // 移除订阅
  private removeSubscription(event: EventType, subscriptionId: string): boolean {
    const subscriptions = this.events.get(event);
    if (!subscriptions) return false;

    const index = subscriptions.findIndex(sub => sub.id === subscriptionId);
    if (index !== -1) {
      subscriptions.splice(index, 1);
      if (subscriptions.length === 0) {
        this.events.delete(event);
      }
      return true;
    }
    return false;
  }

  // 通过ID取消订阅
  unsubscribeById(event: EventType, subscriptionId: string): boolean {
    return this.removeSubscription(event, subscriptionId);
  }

  // 获取订阅者数量
  getSubscriberCount(event: EventType): number {
    return this.events.get(event)?.length || 0;
  }

  // 检查是否有订阅者
  hasSubscribers(event: EventType): boolean {
    return this.getSubscriberCount(event) > 0;
  }
}
```

#### （2）事件过滤和中间件

```typescript
// 事件中间件类型
type EventMiddleware<T = any> = (
  event: EventType, 
  data: T, 
  next: () => Promise<void>
) => Promise<void>;

// 事件过滤器
type EventFilter<T = any> = (event: EventType, data: T) => boolean;

// 带中间件的事件中心
class MiddlewareEventBus extends AdvancedEventBus {
  private middlewares: EventMiddleware[] = [];
  private filters: EventFilter[] = [];

  // 添加中间件
  use(middleware: EventMiddleware): void {
    this.middlewares.push(middleware);
  }

  // 添加过滤器
  addFilter(filter: EventFilter): void {
    this.filters.push(filter);
  }

  // 重写发布方法，支持中间件和过滤
  async publish<T>(event: EventType, data?: T): Promise<void> {
    // 应用过滤器
    for (const filter of this.filters) {
      if (!filter(event, data)) {
        console.log(`Event ${String(event)} filtered out`);
        return;
      }
    }

    // 应用中间件
    if (this.middlewares.length > 0) {
      await this.applyMiddlewares(event, data, 0);
    } else {
      await super.publish(event, data);
    }
  }

  // 应用中间件
  private async applyMiddlewares<T>(
    event: EventType, 
    data: T, 
    index: number
  ): Promise<void> {
    if (index >= this.middlewares.length) {
      await super.publish(event, data);
      return;
    }

    const middleware = this.middlewares[index];
    await middleware(event, data, () => 
      this.applyMiddlewares(event, data, index + 1)
    );
  }
}
```

#### （3）事件持久化和重放

```typescript
// 事件记录
interface EventRecord {
  id: string;
  event: EventType;
  data: any;
  timestamp: number;
  metadata?: Record<string, any>;
}

// 持久化事件中心
class PersistentEventBus extends MiddlewareEventBus {
  private eventHistory: EventRecord[] = [];
  private maxHistorySize: number;
  private isReplaying = false;

  constructor(maxHistorySize = 1000) {
    super();
    this.maxHistorySize = maxHistorySize;
  }

  // 重写发布方法，记录事件
  async publish<T>(event: EventType, data?: T): Promise<void> {
    if (!this.isReplaying) {
      this.recordEvent(event, data);
    }
    await super.publish(event, data);
  }

  // 记录事件
  private recordEvent<T>(event: EventType, data?: T): void {
    const record: EventRecord = {
      id: `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      event,
      data,
      timestamp: Date.now(),
      metadata: {
        subscriberCount: this.getSubscriberCount(event)
      }
    };

    this.eventHistory.push(record);

    // 限制历史记录大小
    if (this.eventHistory.length > this.maxHistorySize) {
      this.eventHistory.shift();
    }
  }

  // 重放事件
  async replayEvents(
    filter?: (record: EventRecord) => boolean,
    fromTimestamp?: number
  ): Promise<void> {
    this.isReplaying = true;
    
    try {
      const eventsToReplay = this.eventHistory.filter(record => {
        if (fromTimestamp && record.timestamp < fromTimestamp) {
          return false;
        }
        return filter ? filter(record) : true;
      });

      for (const record of eventsToReplay) {
        await super.publish(record.event, record.data);
      }
    } finally {
      this.isReplaying = false;
    }
  }

  getEventHistory(): EventRecord[] {
    return [...this.eventHistory];
  }

  clearHistory(): void {
    this.eventHistory = [];
  }

  exportHistory(): string {
    return JSON.stringify(this.eventHistory, null, 2);
  }

  importHistory(historyJson: string): void {
    try {
      const history = JSON.parse(historyJson);
      this.eventHistory = history;
    } catch (error) {
      console.error('Failed to import event history:', error);
    }
  }
}
```

### 2.4 应用

#### （1）全局事件总线

```typescript
// 全局事件总线实现
class GlobalEventBus {
  private static instance: GlobalEventBus;
  private events = new Map<string, Set<Function>>();
  private subscriptionId = 0;
  private subscriptions = new Map<string, { event: string; handler: Function }>();

  static getInstance(): GlobalEventBus {
    if (!GlobalEventBus.instance) {
      GlobalEventBus.instance = new GlobalEventBus();
    }
    return GlobalEventBus.instance;
  }

  subscribe(event: string, handler: Function): string {
    const subscriptionId = `sub_${++this.subscriptionId}`;
    
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    
    this.events.get(event)!.add(handler);
    this.subscriptions.set(subscriptionId, { event, handler });
    
    return subscriptionId;
  }

  unsubscribe(subscriptionId: string): boolean {
    const subscription = this.subscriptions.get(subscriptionId);
    if (subscription) {
      const { event, handler } = subscription;
      const handlers = this.events.get(event);
      if (handlers) {
        handlers.delete(handler);
        if (handlers.size === 0) {
          this.events.delete(event);
        }
      }
      this.subscriptions.delete(subscriptionId);
      return true;
    }
    return false;
  }

  publish(event: string, data?: any): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error('Error in event handler:', error);
        }
      });
    }
  }

  clear(): void {
    this.events.clear();
    this.subscriptions.clear();
  }
}

// React Hook封装
function useEventBus() {
  const eventBus = useRef(GlobalEventBus.getInstance());
  const subscriptions = useRef<Set<string>>(new Set());

  const subscribe = useCallback((event: string, handler: Function): string => {
    const subscriptionId = eventBus.current.subscribe(event, handler);
    subscriptions.current.add(subscriptionId);
    return subscriptionId;
  }, []);

  const unsubscribe = useCallback((subscriptionId: string) => {
    eventBus.current.unsubscribe(subscriptionId);
    subscriptions.current.delete(subscriptionId);
  }, []);

  const publish = useCallback((event: string, data?: any) => {
    eventBus.current.publish(event, data);
  }, []);

  // 组件卸载时清理订阅
  useEffect(() => {
    return () => {
      subscriptions.current.forEach(subscriptionId => {
        eventBus.current.unsubscribe(subscriptionId);
      });
      subscriptions.current.clear();
    };
  }, []);

  return { subscribe, unsubscribe, publish };
}
```

#### （2）状态管理库集成

```typescript
// 基于发布-订阅模式的状态管理
class EventBasedStore<T> {
  private state: T;
  private eventBus: GlobalEventBus;
  private subscribers = new Set<(state: T) => void>();

  constructor(initialState: T) {
    this.state = initialState;
    this.eventBus = GlobalEventBus.getInstance();
    
    // 订阅状态变更事件
    this.eventBus.subscribe('state:changed', (newState: T) => {
      this.state = newState;
      this.notifySubscribers();
    });
  }

  getState(): T {
    return this.state;
  }

  setState(updater: (state: T) => T): void {
    const newState = updater(this.state);
    this.eventBus.publish('state:changed', newState);
  }

  subscribe(callback: (state: T) => void): () => void {
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }

  private notifySubscribers(): void {
    this.subscribers.forEach(callback => {
      try {
        callback(this.state);
      } catch (error) {
        console.error('Error in state subscriber:', error);
      }
    });
  }
}

// React Hook
function useEventStore<T>(store: EventBasedStore<T>): [T, (updater: (state: T) => T) => void] {
  const [state, setState] = useState<T>(store.getState());

  useEffect(() => {
    const unsubscribe = store.subscribe(setState);
    return unsubscribe;
  }, [store]);

  const updateState = useCallback((updater: (state: T) => T) => {
    store.setState(updater);
  }, [store]);

  return [state, updateState];
}

// 使用示例
interface AppState {
  user: User | null;
  theme: 'light' | 'dark';
  notifications: Notification[];
}

const appStore = new EventBasedStore<AppState>({
  user: null,
  theme: 'light',
  notifications: []
});

const AppComponent: React.FC = () => {
  const [state, setState] = useEventStore(appStore);

  const login = (user: User) => {
    setState(prev => ({ ...prev, user }));
  };

  const toggleTheme = () => {
    setState(prev => ({ ...prev, theme: prev.theme === 'light' ? 'dark' : 'light' }));
  };

  return (
    <div className={`app ${state.theme}`}>
      {state.user ? (
        <div>
          <p>Welcome, {state.user.name}!</p>
          <button onClick={toggleTheme}>Toggle Theme</button>
        </div>
      ) : (
        <button onClick={() => login({ id: '1', name: 'John' })}>Login</button>
      )}
    </div>
  );
};
```

#### （3）组件间通信

```typescript
// 父子组件通信
const ParentComponent: React.FC = () => {
  const { publish } = useEventBus();
  const [childData, setChildData] = useState('');

  useEffect(() => {
    const handleChildMessage = (data: any) => {
      setChildData(data.message);
    };

    const subscriptionId = subscribe('child:message', handleChildMessage);
    return () => unsubscribe(subscriptionId);
  }, []);

  const sendToChild = () => {
    publish('parent:message', { message: 'Hello from parent!' });
  };

  return (
    <div>
      <p>Child data: {childData}</p>
      <button onClick={sendToChild}>Send to Child</button>
      <ChildComponent />
    </div>
  );
};

const ChildComponent: React.FC = () => {
  const { subscribe, publish } = useEventBus();
  const [parentData, setParentData] = useState('');

  useEffect(() => {
    const handleParentMessage = (data: any) => {
      setParentData(data.message);
    };

    const subscriptionId = subscribe('parent:message', handleParentMessage);
    return () => unsubscribe(subscriptionId);
  }, []);

  const sendToParent = () => {
    publish('child:message', { message: 'Hello from child!' });
  };

  return (
    <div>
      <p>Parent data: {parentData}</p>
      <button onClick={sendToParent}>Send to Parent</button>
    </div>
  );
};
```

#### （4）路由级事件系统

```typescript
// 路由级事件系统
class RouteEventSystem {
  private eventBus = GlobalEventBus.getInstance();
  private currentRoute = '';

  constructor() {
    // 监听路由变化
    window.addEventListener('popstate', this.handleRouteChange.bind(this));
  }

  private handleRouteChange() {
    const newRoute = window.location.pathname;
    if (newRoute !== this.currentRoute) {
      this.currentRoute = newRoute;
      this.eventBus.publish('route:changed', { 
        from: this.currentRoute, 
        to: newRoute 
      });
    }
  }

  navigate(to: string) {
    window.history.pushState({}, '', to);
    this.handleRouteChange();
  }

  subscribeToRouteChange(handler: (data: any) => void): string {
    return this.eventBus.subscribe('route:changed', handler);
  }

  unsubscribeFromRouteChange(subscriptionId: string): boolean {
    return this.eventBus.unsubscribe(subscriptionId);
  }
}

// React Hook
function useRouteEvents() {
  const routeSystem = useRef(new RouteEventSystem());
  const [currentRoute, setCurrentRoute] = useState(window.location.pathname);

  useEffect(() => {
    const handleRouteChange = (data: any) => {
      setCurrentRoute(data.to);
    };

    const subscriptionId = routeSystem.current.subscribeToRouteChange(handleRouteChange);
    return () => routeSystem.current.unsubscribeFromRouteChange(subscriptionId);
  }, []);

  const navigate = useCallback((to: string) => {
    routeSystem.current.navigate(to);
  }, []);

  return { currentRoute, navigate };
}

// 使用示例
const NavigationComponent: React.FC = () => {
  const { currentRoute, navigate } = useRouteEvents();

  return (
    <nav>
      <p>Current route: {currentRoute}</p>
      <button onClick={() => navigate('/home')}>Home</button>
      <button onClick={() => navigate('/about')}>About</button>
      <button onClick={() => navigate('/contact')}>Contact</button>
    </nav>
  );
};
```

#### （5）全局状态管理

```typescript
const GlobalStateManager: React.FC = () => {
  const { publish, subscribe } = useEventBus();

  useEffect(() => {
    const loginSubscription = subscribe('user:login', (userData) => {
      console.log('User logged in:', userData);
      publish('state:user:update', userData);
    });

    const themeSubscription = subscribe('theme:toggle', (theme) => {
      console.log('Theme changed:', theme);
      publish('state:theme:update', theme);
    });

    return () => {
      loginSubscription && unsubscribe(loginSubscription);
      themeSubscription && unsubscribe(themeSubscription);
    };
  }, []);

  return null;
};
```

#### （6）跨组件通信

```typescript
const HeaderComponent: React.FC = () => {
  const { publish } = useEventBus();

  const handleSearch = (query: string) => {
    publish('search:query', { query, timestamp: Date.now() });
  };

  return (
    <header>
      <SearchBar onSearch={handleSearch} />
    </header>
  );
};

const SidebarComponent: React.FC = () => {
  const { subscribe } = useEventBus();
  const [searchResults, setSearchResults] = useState([]);

  useEffect(() => {
    const searchSubscription = subscribe('search:query', (data) => {
      performSearch(data.query).then(results => {
        setSearchResults(results);
      });
    });

    return () => searchSubscription && unsubscribe(searchSubscription);
  }, []);

  return (
    <aside>
      <SearchResults results={searchResults} />
    </aside>
  );
};
```

#### （7）实时数据同步

```typescript
const RealTimeDataComponent: React.FC = () => {
  const { subscribe, publish } = useEventBus();
  const [data, setData] = useState([]);

  useEffect(() => {
    const dataSubscription = subscribe('data:updated', (newData) => {
      setData(prev => [...prev, newData]);
    });

    const deleteSubscription = subscribe('data:deleted', (id) => {
      setData(prev => prev.filter(item => item.id !== id));
    });

    return () => {
      dataSubscription && unsubscribe(dataSubscription);
      deleteSubscription && unsubscribe(deleteSubscription);
    };
  }, []);

  const addData = (newItem: any) => {
    publish('data:updated', newItem);
  };

  const removeData = (id: string) => {
    publish('data:deleted', id);
  };

  return (
    <div>
      <button onClick={() => addData({ id: Date.now(), name: 'New Item' })}>
        Add Item
      </button>
      {data.map(item => (
        <div key={item.id}>
          {item.name}
          <button onClick={() => removeData(item.id)}>Delete</button>
        </div>
      ))}
    </div>
  );
};
```

#### （8）内存泄漏防护

```typescript
// 自动清理订阅的 Hook
function useAutoCleanupEventBus() {
  const { subscribe, unsubscribe, publish } = useEventBus();
  const subscriptions = useRef<Set<string>>(new Set());

  const safeSubscribe = useCallback((event: string, handler: Function): string => {
    const subscriptionId = subscribe(event, handler);
    subscriptions.current.add(subscriptionId);
    return subscriptionId;
  }, [subscribe]);

  const safeUnsubscribe = useCallback((subscriptionId: string) => {
    unsubscribe(subscriptionId);
    subscriptions.current.delete(subscriptionId);
  }, [unsubscribe]);

  useEffect(() => {
    return () => {
      subscriptions.current.forEach(subscriptionId => {
        unsubscribe(subscriptionId);
      });
      subscriptions.current.clear();
    };
  }, [unsubscribe]);

  return { subscribe: safeSubscribe, unsubscribe: safeUnsubscribe, publish };
}
```

#### （9）事件防抖和节流

```typescript
// 防抖 Hook
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// 节流 Hook
function useThrottle<T>(value: T, delay: number): T {
  const [throttledValue, setThrottledValue] = useState<T>(value);
  const lastRun = useRef(Date.now());

  useEffect(() => {
    const handler = setTimeout(() => {
      if (Date.now() - lastRun.current >= delay) {
        setThrottledValue(value);
        lastRun.current = Date.now();
      }
    }, delay - (Date.now() - lastRun.current));

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return throttledValue;
}

// 在事件系统中使用
const SearchComponent: React.FC = () => {
  const { publish } = useEventBus();
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 300);

  useEffect(() => {
    if (debouncedQuery) {
      publish('search:query', { query: debouncedQuery });
    }
  }, [debouncedQuery, publish]);

  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="Search..."
    />
  );
};
```

#### （10）性能优化

```typescript
// 性能优化的 EventBus
class OptimizedEventBus implements IEventBus {
  private events = new Map<EventType, Set<EventHandler>>();
  private weakMap = new WeakMap<object, Set<EventType>>();

  subscribe<T>(event: EventType, handler: EventHandler<T>): void {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    this.events.get(event)!.add(handler);
  }

  subscribeWithCleanup<T>(
    event: EventType, 
    handler: EventHandler<T>, 
    context: object
  ): void {
    this.subscribe(event, handler);
    
    if (!this.weakMap.has(context)) {
      this.weakMap.set(context, new Set());
    }
    this.weakMap.get(context)!.add(event);
  }

  cleanup(context: object): void {
    const events = this.weakMap.get(context);
    if (events) {
      events.forEach(event => this.events.delete(event));
      this.weakMap.delete(context);
    }
  }
}
```

#### （11）错误处理

```typescript
// 带错误处理的 EventBus
class RobustEventBus implements IEventBus {
  private events = new Map<EventType, Set<EventHandler>>();
  private errorHandlers = new Set<(error: Error, event: EventType) => void>();

  onError(handler: (error: Error, event: EventType) => void): void {
    this.errorHandlers.add(handler);
  }

  offError(handler: (error: Error, event: EventType) => void): void {
    this.errorHandlers.delete(handler);
  }

  publish<T>(event: EventType, data?: T): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          this.handleError(error as Error, event);
        }
      });
    }
  }

  private handleError(error: Error, event: EventType): void {
    this.errorHandlers.forEach(handler => {
      try {
        handler(error, event);
      } catch (handlerError) {
        console.error('Error in error handler:', handlerError);
      }
    });
  }
}
```

#### （12）消息队列

```typescript
class MessageQueue {
  private eventBus = new EventBus();
  private queue: Array<{ event: string; data: any; timestamp: number }> = [];

  sendMessage(event: string, data: any) {
    const message = { event, data, timestamp: Date.now() };
    this.queue.push(message);
    this.eventBus.publish(event, data);
  }

  processMessage(handler: (message: any) => void) {
    this.eventBus.subscribe('message:process', handler);
  }
}
```

#### （13）日志系统

```typescript
// 日志系统
class LogSystem {
  private eventBus = new EventBus();

  // 记录日志
  log(level: 'info' | 'warn' | 'error', message: string, data?: any) {
    this.eventBus.publish('log:record', { level, message, data, timestamp: new Date() });
  }

  // 订阅日志
  onLog(handler: (logEntry: any) => void) {
    this.eventBus.subscribe('log:record', handler);
  }
}
```

### 三、观察者模式与发布-订阅的对比

- 耦合度：观察者模式**耦合度高**（直接依赖）；发布-订阅模式的**耦合度低**（通过事件中心解耦）。
- 通信方式：观察者模式直接调用；发布-订阅模式基于**事件驱动**。
- 角色关系：观察者模式是一种**一对多**的关系；发布-订阅模式是一种**一对多**，或者**多对多**的关系。
- 实现复杂度：观察者模式简单；发布-订阅模式复杂。
- 扩展性：观察者模式较差；发布-订阅模式较好。
- 性能：观察者模式较好；发布-订阅模式稍差。
