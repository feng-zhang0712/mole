# 中介者模式

## 一、介绍

中介者模式是一种行为型设计模式，用一个中介对象来封装一系列的对象交互。在中介者模式中，对象间的通信过程被封装在一个中介者对象之中。对象之间不直接交互，而是通过中介者进行交互。从而减少可交互对象间的依赖，降低耦合。

中介者模式符合单一职责原则、开闭原则、依赖倒置原则和迪米特法则。

中介者模式符合以下设计原则。

- 单一职责原则：中介者专注于协调对象间的交互，每个同事对象专注于自己的业务逻辑。职责分离，代码更易维护。
- 开闭原则：新增同事对象时，不需要修改现有的同事对象代码。只需要在中介者中注册新的同事对象。
- 依赖倒置原则：同事对象依赖于中介者抽象，而不是具体实现。降低了对象间的耦合度。
- 迪米特法则：同事对象之间不直接通信，通过中介者进行交互。减少了对象间的直接依赖。

中介者模式中的参与者主要有 Mediator（中介者）和 Colleague（同事）。

- **中介者**（Mediator）：定义中介者接口。
- **具体中介者**（ConcreteMediator）：实现中介者接口，协调各个同事对象。
- **同事**（Colleague）：需要相互交互的对象，定义与中介者交互的接口。
- **具体同事对象**（ConcreteColleague）：实现同事接口，处理具体的业务逻辑。

## 二、代码实现

```typescript
type MediatorEvent = string | symbol;
type MediatorEventHandler<T = any> = (sender: Colleague, data: T) => void;
type MediatorEventMap = Map<MediatorEvent, Set<MediatorEventHandler>>;

interface Mediator {
  register(colleague: Colleague): void;
  unregister(colleague: Colleague): void;
  notify(sender: Colleague, event: MediatorEvent, data?: any): void;
}

class ConcreteMediator implements Mediator {
  protected colleagues: Map<string, Colleague> = new Map();

  register(colleague: Colleague): void {
    if (!this.colleagues.has(colleague.id)) return;
    this.colleagues.set(colleague.id, colleague);
    colleague.setMediator(this);
  }

  unregister(colleague: Colleague): void {
    if (!this.colleagues.has(colleague.id)) return;
    this.colleagues.delete(colleague.id);
    colleague.setMediator(null);
  }

  notify(sender: Colleague, event: MediatorEvent, data?: any): void {
    switch (event) {
      case 'sync': {
        const col = this.colleagues.get(data.targetId);
        if (col) {
          col.receive('sync', data);
        }
      }
        break;
      default: { // 除'update'事件外，其他情况广播给所有其他同事对象。
        Array.from(this.colleagues.values()).forEach(col => {
          if (col.id !== sender.id) {
            col.receive(event, data);
          }
        });
      }
    }
  }
}

interface Colleague {
  id: string;
  setMediator(mediator: Mediator): void;
  receive(event: MediatorEvent, data?: any): void;
}

class ConcreteColleague implements Colleague {
  public id: string;
  protected state: any = {};
  protected mediator: Mediator | null = null;

  private eventHandlers: Map<MediatorEvent, (data?: any) => void> = new Map();

  constructor(id: string) {
    this.id = id;
    this.setupEventHandlers();
  }

  setMediator(mediator: Mediator | null): void {
    this.mediator = mediator;
  }

  notify(event: MediatorEvent, data?: any): void {
    if (this.mediator) {
      this.mediator.notify(this, event, data);
    }
  }

  receive(event: MediatorEvent, data?: any): void {
    const handler = this.eventHandlers.get(event);
    if (handler) {
      try {
        handler(data);
      } catch (error) {
        console.error(`Error in event handler for ${String(event)}:`, error);
      }
    }
  }

  setState(state: any): void {
    const oldState = this.state;
    this.state = { ...this.state, ...state };
    this.notify('state:changed', {
      oldState,
      newState: this.state,
    });
  }

  private setupEventHandlers(): void {
    this.eventHandlers.set('update', this.setState);
    this.eventHandlers.set('sync', this.setState);
  }
}
```

使用示例。

```typescript
const mediator = new ConcreteMediator();

const c1 = new ConcreteColleague('c1');
const c2 = new ConcreteColleague('c2');
const c3 = new ConcreteColleague('c3');

mediator.register(c1);
mediator.register(c2);
mediator.register(c3);

c1.notify('update', { value: 'Hello from c1' });
c2.notify('sync', {
  targetId: 'c3',
  value: 'Sync data',
});
```

## 三、适用场景

当对象之间交互复杂、耦合度高、交互逻辑分散或者需要统一管理时，就可以考虑使用中介者模式。
