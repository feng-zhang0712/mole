# 策略模式

## 一、介绍

策略模式（Strategy Pattern）是一种**行为型**设计模式，它定义了一系列算法，并将每一个算法封装起来，使它们可以互相替换。策略模式让算法的变化不会影响到使用算法的客户。

策略模式的核心思想是，将算法从使用算法的对象中分离出来，通过定义一系列算法类，使得算法可以独立于使用它的客户而变化。这样可以避免使用多重条件语句，同时提供更好的扩展性。

通过策略模式，可以实现算法的动态切换、消除条件语句和提高代码的可维护性等功能。不过，使用策略模式，会增加类的数量，造成系统复杂性增加，以及可能过度设计等。

策略模式中有三个参与者。

- **上下文**（Context）：维护对策略对象的引用，可以定义一个接口来让策略访问它的数据。
- **策略**（Strategy）：定义所有支持的算法的公共接口。Context 使用这个接口来调用某个 ConcreteStrategy 定义的算法。
- **具体策略**（ConcreteStrategy）：以 Strategy 接口实现某具体算法。

## 二、伪代码实现

```typescript
interface Strategy {
  execute(a: number, b: number): number;
}

class ConcreteStrategyA implements Strategy {
  public execute(a: number, b: number): number {
    return a + b;
  }
}

class ConcreteStrategyB implements Strategy {
  public execute(a: number, b: number): number {
    return a - b;
  }
}

class ConcreteStrategyC implements Strategy {
  public execute(a: number, b: number): number {
    return a * b;
  }
}

class Context {
  private strategy: Strategy;

  constructor(strategy: Strategy) {
    this.strategy = strategy;
  }

  public setStrategy(strategy: Strategy) {
    this.strategy = strategy;
  }

  public executeStrategy(a: number, b: number): number {
    return this.strategy.execute(a, b);
  }
}
```

下面是一个示例代码。

```typescript
const context = new Context(new ConcreteStrategyA());
console.log("10 + 5 = " + context.executeStrategy(10, 5));

context.setStrategy(new ConcreteStrategyB());
console.log("10 - 5 = " + context.executeStrategy(10, 5));

context.setStrategy(new ConcreteStrategyC());
console.log("10 * 5 = " + context.executeStrategy(10, 5));
```

## 三、React 中的策略模式应用

### 3.1 表单验证策略 - 验证算法策略

表单验证可以通过策略模式实现不同的验证算法。

```typescript
// 抽象验证策略
interface ValidationStrategy {
  validate(value: string): { isValid: boolean; message: string };
}

// 具体验证策略 - 邮箱验证
class EmailValidationStrategy implements ValidationStrategy {
  validate(value: string): { isValid: boolean; message: string } {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const isValid = emailRegex.test(value);
    return {
      isValid,
      message: isValid ? '' : 'Please enter a valid email address'
    };
  }
}

// 具体验证策略 - 密码验证
class PasswordValidationStrategy implements ValidationStrategy {
  validate(value: string): { isValid: boolean; message: string } {
    const hasMinLength = value.length >= 8;
    const hasUpperCase = /[A-Z]/.test(value);
    const hasLowerCase = /[a-z]/.test(value);
    const hasNumber = /\d/.test(value);
    
    const isValid = hasMinLength && hasUpperCase && hasLowerCase && hasNumber;
    return {
      isValid,
      message: isValid ? '' : 'Password must be at least 8 characters with uppercase, lowercase, and number'
    };
  }
}

// 具体验证策略 - 手机号验证
class PhoneValidationStrategy implements ValidationStrategy {
  validate(value: string): { isValid: boolean; message: string } {
    const phoneRegex = /^\d{11}$/;
    const isValid = phoneRegex.test(value);
    return {
      isValid,
      message: isValid ? '' : 'Please enter a valid 11-digit phone number'
    };
  }
}

// 验证上下文
class ValidationContext {
  private strategy: ValidationStrategy;

  constructor(strategy: ValidationStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: ValidationStrategy) {
    this.strategy = strategy;
  }

  validate(value: string) {
    return this.strategy.validate(value);
  }
}
```

下面是示例代码。

```typescript
// 使用验证策略
const FormField: React.FC<{ 
  type: 'email' | 'password' | 'phone';
  value: string;
  onChange: (value: string) => void;
}> = ({ type, value, onChange }) => {
  const [error, setError] = useState('');
  
  const validationContext = useMemo(() => {
    const strategies = {
      email: new EmailValidationStrategy(),
      password: new PasswordValidationStrategy(),
      phone: new PhoneValidationStrategy(),
    };
    return new ValidationContext(strategies[type]);
  }, [type]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    onChange(newValue);
    
    const validation = validationContext.validate(newValue);
    setError(validation.message);
  };

  return (
    <div>
      <input
        type={type === 'password' ? 'password' : 'text'}
        value={value}
        onChange={handleChange}
        placeholder={`Enter ${type}`}
      />
      {error && <span className="error">{error}</span>}
    </div>
  );
};

const Form: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [phone, setPhone] = useState('');

  return (
    <form>
      <FormField type="email" value={email} onChange={setEmail} />
      <FormField type="password" value={password} onChange={setPassword} />
      <FormField type="phone" value={phone} onChange={setPhone} />
    </form>
  );
};
```

### 3.2 排序策略 - 排序算法策略

排序功能可以通过策略模式实现不同的排序算法。

```typescript
// 抽象排序策略
interface SortStrategy {
  sort<T>(array: T[]): T[];
}

// 具体排序策略 - 冒泡排序
class BubbleSortStrategy implements SortStrategy {
  sort<T>(array: T[]): T[] {
    const result = [...array];
    for (let i = 0; i < result.length; i++) {
      for (let j = 0; j < result.length - i - 1; j++) {
        if (result[j] > result[j + 1]) {
          [result[j], result[j + 1]] = [result[j + 1], result[j]];
        }
      }
    }
    return result;
  }
}

// 具体排序策略 - 快速排序
class QuickSortStrategy implements SortStrategy {
  sort<T>(array: T[]): T[] {
    if (array.length <= 1) return array;
    
    const pivot = array[Math.floor(array.length / 2)];
    const left = array.filter(item => item < pivot);
    const right = array.filter(item => item > pivot);
    
    return [...this.sort(left), pivot, ...this.sort(right)];
  }
}

// 具体排序策略 - 归并排序
class MergeSortStrategy implements SortStrategy {
  sort<T>(array: T[]): T[] {
    if (array.length <= 1) return array;
    
    const mid = Math.floor(array.length / 2);
    const left = this.sort(array.slice(0, mid));
    const right = this.sort(array.slice(mid));
    
    return this.merge(left, right);
  }

  private merge<T>(left: T[], right: T[]): T[] {
    const result: T[] = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
      if (left[i] <= right[j]) {
        result.push(left[i]);
        i++;
      } else {
        result.push(right[j]);
        j++;
      }
    }
    
    return result.concat(left.slice(i), right.slice(j));
  }
}

// 排序上下文
class SortContext {
  private strategy: SortStrategy;

  constructor(strategy: SortStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: SortStrategy) {
    this.strategy = strategy;
  }

  sort<T>(array: T[]): T[] {
    return this.strategy.sort(array);
  }
}
```

下面是示例代码。

```typescript
// 使用排序策略
const SortableList: React.FC<{ items: number[] }> = ({ items }) => {
  const [sortedItems, setSortedItems] = useState(items);
  const [sortStrategy, setSortStrategy] = useState<'bubble' | 'quick' | 'merge'>('bubble');

  const sortContext = useMemo(() => {
    const strategies = {
      bubble: new BubbleSortStrategy(),
      quick: new QuickSortStrategy(),
      merge: new MergeSortStrategy(),
    };
    return new SortContext(strategies[sortStrategy]);
  }, [sortStrategy]);

  const handleSort = () => {
    const sorted = sortContext.sort([...items]);
    setSortedItems(sorted);
  };

  return (
    <div>
      <div>
        <label>Sort Strategy:</label>
        <select value={sortStrategy} onChange={(e) => setSortStrategy(e.target.value as any)}>
          <option value="bubble">Bubble Sort</option>
          <option value="quick">Quick Sort</option>
          <option value="merge">Merge Sort</option>
        </select>
        <button onClick={handleSort}>Sort</button>
      </div>
      <ul>
        {sortedItems.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
};
```

### 3.3 支付策略 - 支付方式策略

支付功能可以通过策略模式实现不同的支付方式。

```typescript
// 抽象支付策略
interface PaymentStrategy {
  pay(amount: number): { success: boolean; message: string };
}

// 具体支付策略 - 信用卡支付
class CreditCardPaymentStrategy implements PaymentStrategy {
  constructor(private cardNumber: string, private cvv: string) {}

  pay(amount: number): { success: boolean; message: string } {
    // 模拟信用卡支付逻辑
    const isValid = this.cardNumber.length === 16 && this.cvv.length === 3;
    return {
      success: isValid,
      message: isValid ? `Paid $${amount} with credit card` : 'Invalid credit card information'
    };
  }
}

// 具体支付策略 - 支付宝支付
class AlipayPaymentStrategy implements PaymentStrategy {
  constructor(private accountId: string) {}

  pay(amount: number): { success: boolean; message: string } {
    // 模拟支付宝支付逻辑
    const isValid = this.accountId.length > 0;
    return {
      success: isValid,
      message: isValid ? `Paid $${amount} with Alipay` : 'Invalid Alipay account'
    };
  }
}

// 具体支付策略 - 微信支付
class WeChatPaymentStrategy implements PaymentStrategy {
  constructor(private openId: string) {}

  pay(amount: number): { success: boolean; message: string } {
    // 模拟微信支付逻辑
    const isValid = this.openId.length > 0;
    return {
      success: isValid,
      message: isValid ? `Paid $${amount} with WeChat Pay` : 'Invalid WeChat account'
    };
  }
}

// 支付上下文
class PaymentContext {
  private strategy: PaymentStrategy;

  constructor(strategy: PaymentStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: PaymentStrategy) {
    this.strategy = strategy;
  }

  pay(amount: number) {
    return this.strategy.pay(amount);
  }
}
```

下面是示例代码。

```typescript
// 使用支付策略
const PaymentForm: React.FC = () => {
  const [paymentMethod, setPaymentMethod] = useState<'credit' | 'alipay' | 'wechat'>('credit');
  const [amount, setAmount] = useState(100);
  const [result, setResult] = useState('');

  const handlePayment = () => {
    let strategy: PaymentStrategy;
    
    switch (paymentMethod) {
      case 'credit':
        strategy = new CreditCardPaymentStrategy('1234567890123456', '123');
        break;
      case 'alipay':
        strategy = new AlipayPaymentStrategy('alipay_account_123');
        break;
      case 'wechat':
        strategy = new WeChatPaymentStrategy('wechat_openid_123');
        break;
      default:
        strategy = new CreditCardPaymentStrategy('1234567890123456', '123');
    }

    const paymentContext = new PaymentContext(strategy);
    const paymentResult = paymentContext.pay(amount);
    setResult(paymentResult.message);
  };

  return (
    <div>
      <div>
        <label>Payment Method:</label>
        <select value={paymentMethod} onChange={(e) => setPaymentMethod(e.target.value as any)}>
          <option value="credit">Credit Card</option>
          <option value="alipay">Alipay</option>
          <option value="wechat">WeChat Pay</option>
        </select>
      </div>
      <div>
        <label>Amount:</label>
        <input
          type="number"
          value={amount}
          onChange={(e) => setAmount(Number(e.target.value))}
        />
      </div>
      <button onClick={handlePayment}>Pay</button>
      {result && <div>{result}</div>}
    </div>
  );
};
```

### 3.4 主题策略 - 主题切换策略

主题切换可以通过策略模式实现不同的主题算法。

```typescript
// 抽象主题策略
interface ThemeStrategy {
  getTheme(): { backgroundColor: string; textColor: string; accentColor: string };
}

// 具体主题策略 - 浅色主题
class LightThemeStrategy implements ThemeStrategy {
  getTheme() {
    return {
      backgroundColor: '#ffffff',
      textColor: '#333333',
      accentColor: '#007bff'
    };
  }
}

// 具体主题策略 - 深色主题
class DarkThemeStrategy implements ThemeStrategy {
  getTheme() {
    return {
      backgroundColor: '#1a1a1a',
      textColor: '#ffffff',
      accentColor: '#00d4ff'
    };
  }
}

// 具体主题策略 - 高对比度主题
class HighContrastThemeStrategy implements ThemeStrategy {
  getTheme() {
    return {
      backgroundColor: '#000000',
      textColor: '#ffffff',
      accentColor: '#ffff00'
    };
  }
}

// 主题上下文
class ThemeContext {
  private strategy: ThemeStrategy;

  constructor(strategy: ThemeStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: ThemeStrategy) {
    this.strategy = strategy;
  }

  getTheme() {
    return this.strategy.getTheme();
  }
}
```

下面是示例代码。

```typescript
// 使用主题策略
const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [themeType, setThemeType] = useState<'light' | 'dark' | 'highContrast'>('light');
  
  const themeContext = useMemo(() => {
    const strategies = {
      light: new LightThemeStrategy(),
      dark: new DarkThemeStrategy(),
      highContrast: new HighContrastThemeStrategy(),
    };
    return new ThemeContext(strategies[themeType]);
  }, [themeType]);

  const theme = themeContext.getTheme();

  return (
    <div style={{ backgroundColor: theme.backgroundColor, color: theme.textColor }}>
      <div>
        <label>Theme:</label>
        <select value={themeType} onChange={(e) => setThemeType(e.target.value as any)}>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
          <option value="highContrast">High Contrast</option>
        </select>
      </div>
      {children}
    </div>
  );
};

const App: React.FC = () => {
  return (
    <ThemeProvider>
      <h1>Welcome to our app</h1>
      <p>This is some content with different themes.</p>
      <button style={{ backgroundColor: '#007bff', color: 'white' }}>
        Click me
      </button>
    </ThemeProvider>
  );
};
```

### 3.5 数据导出策略 - 导出格式策略

数据导出可以通过策略模式实现不同的导出格式。

```typescript
// 抽象导出策略
interface ExportStrategy {
  export(data: any[]): string;
}

// 具体导出策略 - JSON格式
class JsonExportStrategy implements ExportStrategy {
  export(data: any[]): string {
    return JSON.stringify(data, null, 2);
  }
}

// 具体导出策略 - CSV格式
class CsvExportStrategy implements ExportStrategy {
  export(data: any[]): string {
    if (data.length === 0) return '';
    
    const headers = Object.keys(data[0]);
    const csvRows = [
      headers.join(','),
      ...data.map(row => headers.map(header => row[header]).join(','))
    ];
    
    return csvRows.join('\n');
  }
}

// 具体导出策略 - XML格式
class XmlExportStrategy implements ExportStrategy {
  export(data: any[]): string {
    const xmlItems = data.map(item => {
      const itemXml = Object.entries(item)
        .map(([key, value]) => `  <${key}>${value}</${key}>`)
        .join('\n');
      return `<item>\n${itemXml}\n</item>`;
    }).join('\n');
    
    return `<?xml version="1.0" encoding="UTF-8"?>\n<data>\n${xmlItems}\n</data>`;
  }
}

// 导出上下文
class ExportContext {
  private strategy: ExportStrategy;

  constructor(strategy: ExportStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: ExportStrategy) {
    this.strategy = strategy;
  }

  export(data: any[]): string {
    return this.strategy.export(data);
  }
}
```

下面是示例代码。

```typescript
// 使用导出策略
const DataExporter: React.FC<{ data: any[] }> = ({ data }) => {
  const [exportFormat, setExportFormat] = useState<'json' | 'csv' | 'xml'>('json');
  const [exportedData, setExportedData] = useState('');

  const exportContext = useMemo(() => {
    const strategies = {
      json: new JsonExportStrategy(),
      csv: new CsvExportStrategy(),
      xml: new XmlExportStrategy(),
    };
    return new ExportContext(strategies[exportFormat]);
  }, [exportFormat]);

  const handleExport = () => {
    const exported = exportContext.export(data);
    setExportedData(exported);
  };

  return (
    <div>
      <div>
        <label>Export Format:</label>
        <select value={exportFormat} onChange={(e) => setExportFormat(e.target.value as any)}>
          <option value="json">JSON</option>
          <option value="csv">CSV</option>
          <option value="xml">XML</option>
        </select>
        <button onClick={handleExport}>Export</button>
      </div>
      {exportedData && (
        <pre style={{ backgroundColor: '#f5f5f5', padding: '10px' }}>
          {exportedData}
        </pre>
      )}
    </div>
  );
};
```

### 3.6 缓存策略 - 缓存算法策略

缓存功能可以通过策略模式实现不同的缓存算法。

```typescript
// 抽象缓存策略
interface CacheStrategy {
  get(key: string): any;
  set(key: string, value: any): void;
  clear(): void;
}

// 具体缓存策略 - LRU缓存
class LRUCacheStrategy implements CacheStrategy {
  private cache = new Map<string, any>();
  private maxSize: number;

  constructor(maxSize: number = 100) {
    this.maxSize = maxSize;
  }

  get(key: string): any {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return null;
  }

  set(key: string, value: any): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }

  clear(): void {
    this.cache.clear();
  }
}

// 具体缓存策略 - 简单缓存
class SimpleCacheStrategy implements CacheStrategy {
  private cache = new Map<string, any>();

  get(key: string): any {
    return this.cache.get(key) || null;
  }

  set(key: string, value: any): void {
    this.cache.set(key, value);
  }

  clear(): void {
    this.cache.clear();
  }
}

// 缓存上下文
class CacheContext {
  private strategy: CacheStrategy;

  constructor(strategy: CacheStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: CacheStrategy) {
    this.strategy = strategy;
  }

  get(key: string): any {
    return this.strategy.get(key);
  }

  set(key: string, value: any): void {
    this.strategy.set(key, value);
  }

  clear(): void {
    this.strategy.clear();
  }
}
```

下面是示例代码。

```typescript
// 使用缓存策略
const CacheDemo: React.FC = () => {
  const [cacheType, setCacheType] = useState<'simple' | 'lru'>('simple');
  const [key, setKey] = useState('');
  const [value, setValue] = useState('');
  const [result, setResult] = useState('');

  const cacheContext = useMemo(() => {
    const strategies = {
      simple: new SimpleCacheStrategy(),
      lru: new LRUCacheStrategy(5),
    };
    return new CacheContext(strategies[cacheType]);
  }, [cacheType]);

  const handleSet = () => {
    cacheContext.set(key, value);
    setResult(`Set ${key} = ${value}`);
  };

  const handleGet = () => {
    const result = cacheContext.get(key);
    setResult(`Get ${key} = ${result}`);
  };

  const handleClear = () => {
    cacheContext.clear();
    setResult('Cache cleared');
  };

  return (
    <div>
      <div>
        <label>Cache Type:</label>
        <select value={cacheType} onChange={(e) => setCacheType(e.target.value as any)}>
          <option value="simple">Simple Cache</option>
          <option value="lru">LRU Cache</option>
        </select>
      </div>
      <div>
        <input
          placeholder="Key"
          value={key}
          onChange={(e) => setKey(e.target.value)}
        />
        <input
          placeholder="Value"
          value={value}
          onChange={(e) => setValue(e.target.value)}
        />
        <button onClick={handleSet}>Set</button>
        <button onClick={handleGet}>Get</button>
        <button onClick={handleClear}>Clear</button>
      </div>
      {result && <div>{result}</div>}
    </div>
  );
};
```
