# 从输入 URL 到页面显示，这个过程经历了什么？

## 介绍

当用户在浏览器地址栏输入 URL 并按下回车键时，浏览器会执行一系列复杂的操作来加载和显示网页。这个过程可以分为多个阶段，每个阶段都有其特定的任务和机制。

## URL 解析

URL（Unique Resource Locator，统一资源定位符）由多个部分组成，以 `http://www.example.com:80/docs/web/api/url?key1=value1&key2=value2#what_is_a_url` 为例。

- 协议：`http` 部分。
- 域名：`www.example.com`
- 端口号：`80`
- 路径：`/docs/web/api/url`
- 查询参数：`?key1=value1&key2=value2`
- 锚点：`#what_is_a_url`

URL 中只能包含合法的字符，合法字符由两种类型的字符组成：元字符和语义字符。

- **元字符**：`:`、`/`、`@`、`?`、`=`、`&`、`#`、`+`、`$`、`;` 和 `,`。
- **语义字符**：`A-Z`、`a-z`、`0-9`、`-`、`_`、`.`、`*`、`'`、`!`、`~` 和 `()`。

凡是不在元字符和语义字符之内的，都属于非法字符，都需要被转义，规则是将每个字节转为百分号（`%`）加上两个大写的十六进制字母。

比如，UTF-8 的操作系统上，`http://www.example.com/search?q=春节` 这个 URL 之中，汉字“春节”不是 URL 的合法字符，所以被浏览器自动转成 `http://www.example.com/search?q=%E6%98%A5%E8%8A%82`。其中，“春”转成了 `%E6%98%A5`，“节”转成了 `%E8%8A%82`。这是因为“春”和“节”的 UTF-8 编码分别是 `E6 98 A5` 和 `E8 8A 82`，将每个字节前面加上百分号，就构成了 URL 编码。

用户在浏览器地址栏中输入的字符可能是非法的，此时，浏览器有两种处理策略。

一种情况是，用户在浏览器中输入的地址格式不正确，比如 “春节”，此时，浏览器认为用户输入的是关键字（词），然后就会使用默认的搜索引擎，对关键字进行搜索，此时浏览器会构造一个 GET 请求，请求地址就像这样 `http://www.example.com/search?q=春节`。

另一种情况是，用户在地址栏中输入的 URL 格式正确，但是包含非法字符，比如用户直接将 `http://www.example.com/search?q=春节` 这串字符粘贴在地址栏，此时，浏览器就会按照上面介绍的规则，对非法字符“春节”进行编码。

注意，许多浏览器允许在输入地址时，省略协议和域名的一部分，浏览器会自动对其进行补全。比如，直接输入 `example.com` 是被允许的，补全后的地址是 `http://www.example.com`。

浏览器将 URL 地址拆分成不同的部分，在后续处理中，每一部分都有其作用。比如，浏览器发现使用的协议是 `http` ，之后在同服务器进行连接时，就会执行 TCP 的三报文握手过程，如果使用的是 `https` 协议，还要另外执行 TLS/SSL 的验证过程。

## DNS 查询

DNS（Domain Name System，域名系统）是将域名映射为 IP 地址的过程。

首先检查浏览器的 DNS 缓存，接着检查操作系统的 DNS 缓存，最后检查路由器的 DNS 缓存。这个过程中，只要任何一步命中缓存，就将 IP 地址返回，如果没有命中，就会向本地 DNS 服务器发送查询请求。

首先，本地 DNS 服务器向根域名服务器（Root DNS Server）查询，根服务器返回顶级域名服务器（TLD Server）的地址，然后本地 DNS 服务器向 TLD 服务器查询，TLD 服务器返回权威域名服务器（Authoritative DNS Server）的地址，最后，本地 DNS 服务器向权威域名服务器查询，权威服务器返回最终的 IP 地址。

## TCP 连接建立

TCP 连接建立过程中要使用下面几个首部字段。

- **同步 SYN**（SYNchronization）：在连接建立时用来同步序号。当 `SYN = 1` 而 `ACK = 0` 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 `SYN = 1` 和 `ACK = 1`。因此，`SYN = 1` 就表示这是一个连接请求或连接接受报文。
- **确认 ACK**（ACKnowledgment）：仅当 `ACK = 1` 时确认号字段才有效。当 `ACK = 0` 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 `ACK = 1`。
- **确认号**：占 4 字节，是**期望收到对方下一个报文段的第一个数据字节的序号**。若确认号 = `N`，则表明：到序号 `N - 1` 为止的所有数据都已正确收到。
- **序号**：占 4 字节。序号范围是[0, $2^{32}$ - 1]，共 $2^{32}$（即 4 294 967 296）个序号。序号增加到 $2^{32}$ − 1 后，下一个序号就又回到 0。也就是说，序号使用 $mod 2^{32}$ 运算。TCP 是面向字节流的。在一个 TCP 连接中传送的字节流中的**每个字节都按顺序编号**。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值指的是**本报文段**所发送的数据的第一个字节的序号。这个字段的名称也叫做“**报文段序号**”。
- **终止 FIN**（FINish）：用来释放一个连接。当 `FIN = 1` 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。

### TCP 连接建立过程

TCP 建立连接的过程叫作握手，握手需要在客户和服务器之间交换三个 TCP 报文段。

![用三报文握手建立 TCP 连接](/2025/assets/computer-network/the-process-of-three-packet-handshake.png)

1. 假定客户端（以下代指 A）和服务器（以下代指 B）最初都处于 **CLOSED**（关闭）状态，并分别创建传输控制块 TCB。之后，服务器处于 **LISTEN**（收听）状态，等待客户端的连接请求。
2. 客户端向服务器发出连接请求报文段，请求首部中的同步位 `SYN = 1`，初始序号 `seq = x`。客户端进入 **SYN-SENT**（同步已发送）状态。
3. 服务器收到连接请求报文段后，如同意建立连接，则向客户端发送确认。在确认报文段中 `SYN = 1`、`ACK = 1`，确认号是 `ack = x + 1`，同时设置自己的初始序号 `seq = y`。服务器进入 **SYN-RCVD**（同步收到）状态。
4. 客户端收到服务器的确认后，还要向服务器给出确认。确认报文段的 `ACK = 1`，确认号 `ack = y + 1`，而自己的序号 `seq = x + 1`。至此，TCP 连接建立，客户端进入 **ESTABLISHED** （已建立连接）状态。在这种情况下，下一个数据报文段的序号仍是 `seq = x + 1`。
5. 服务器收到客户端的确认后，也进入 **ESTABLISHED** 状态。

上面给出的连接建立过程叫作**三报文握手**。注意，上图中服务器发送给客户端的报文段，也可以拆成两个报文段。可以先发送一个确认报文段（`ACK = 1`，`ack = x + 1`），然后再发送一个同步报文段（`SYN = 1`，`seq = y`）。这样的过程就变成了四报文握手，但效果是一样的。

注意，TCP 规定，`SYN` 报文段不能携带数据，但要消耗掉一个序号；`ACK` 报文段可以携带数据，但如果不携带数据则不消耗序号。

注：传输控制块 TCB（Transmission Control Block）存储了每个连接中的一些重要信息，比如，TCP 连接表，指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等。

### 为什么是三报文握手？

为什么客户端最后还要发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误。

所谓“已失效的连接请求报文段”是这样产生的。正常情况下，客户端发出连接请求，但因连接请求报文丢失而未收到确认。于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。客户端共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务器，没有“已失效的连接请求报文段”。

现假定出现一种异常情况，即客户端发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到达服务器。本来这是一个早已失效的报文段。但服务器收到此失效的连接请求报文段后，就误认为是客户端又发出一次新的连接请求。于是就向客户端发出确认报文段，同意建立连接。假定不采用报文握手，那么只要服务器发出确认，新的连接就建立了。

由于现在客户端并没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据。但服务器却以为新的运输连接已经建立了，并一直等待客户端发来数据。服务器的许多资源就这样白白浪费了。

采用三报文握手的办法，可以防止上述现象的发生。例如在刚才的异常情况下，客户端不会向服务器的确认发出确认。由于收不到确认，就知道客户端并没有要求建立连接。

## 客户端请求

## 服务器响应

## TCP 链接释放

TCP 链接释放过程中用到的首部字段，除了上面介绍的几个，还有个**终止 FIN**（FINish）字段，该字段用来释放一个连接。当 `FIN = 1` 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。

### TCP 链接释放过程

![TCP 连接释放的过程](/2025/assets/computer-network/the-process-of-releasing-the-tcp-connection.png)

开始时客户端（以下代指 A）和服务器（以下代指 B）都处于 **ESTABLISHED** 状态。

1. 客户端发出连接释放报文段，首部的 `FIN = 1`，序号 `seq = u`，它等于前面已传送过的数据的最后一个字节的序号加 1。客户端进入 **FIN-WAIT-1**（终止等待 1）状态。
2. 服务器收到连接释放报文段后随即发出确认，确认报文段中 `ACK = 1`、`ack = u + 1`，自己的序号是 `seq = v`， 等于服务器前面已传送的数据的最后一个字节的序号加 1。服务器进入 **CLOSE-WAIT**（关闭等待）状态。服务器这时应通知高层应用进程，此时，从客户端到服务器这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即客户端已经没有数据要发送了，但服务器若发送数据，客户端仍要接收。也就是说，从服务器到客户端这个方向的连接并未关闭，这个状态可能会持续一段时间。
3. 客户端收到来自服务器的确认后，进入 **FIN-WAIT-2**（终止等待 2）状态，等待服务器发出的连接释放报文段。
4. 若服务器已经没有要向客户端发送的数据，服务器发出连接释放报文段，其中的 `FIN = 1`。现假定服务器的序号为 `w`（在半关闭状态服务器可能又发送了一些数据）。服务器还必须重复上次已发送过的确认号 `ack = u + 1`。服务器进入 **LAST-ACK**（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文段后，在确认报文段中把 `ACK = 1`，确认号 `ack = w + 1`，而自己的序号是 `seq = u + 1`。客户端进入 **TIME-WAIT**（时间等待）状态。
6. 现在 TCP 连接还没有释放掉。必须经过**时间等待计时器**（TIME-WAIT timer）设置的时间 2MSL 后，客户端才进入到 **CLOSED** 状态。时间 MSL 叫作**最长报文段寿命**（Maximum Segment Lifetime），一般建议设为 2 分钟。对于现在的网络，MSL = 2 分钟可能太长。因此 TCP 允许不同的实现，可根据具体情况使用更小的 MSL 值。因此，从客户端进入到 **TIME-WAIT** 状态后，要经过 4 分钟才能进入到 **CLOSED** 状态，之后才能开始建立下一个新的连接。当客户端撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。

上述的 TCP 连接释放过程是**四报文握手**。

注意，`FIN` 报文段即使不携带数据，它也消耗掉一个序号。

### 为什么是四报文握手？

为什么客户端在 **TIME-WAIT** 状态必须等待 2MSL 的时间呢？这有两个理由。

- 为了保证客户端发送的最后一个 `ACK` 报文段能够到达服务器。这个 `ACK` 报文段有可能丢失，因而使处在 **LAST-ACK** 状态的服务器收不到对已发送的 `FIN` + `ACK` 报文段的确认。服务器会超时重传这个 `FIN` + `ACK` 报文段，而客户端就能在 2MSL 时间内收到这个重传的 `FIN` + `ACK` 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 **CLOSED** 状态。如果客户端在 **TIME-WAIT** 状态不等待一段时间，而是在发送完 `ACK` 报文段后立即释放连接，那么就无法收到服务器重传的 `FIN` + `ACK` 报文段，因而也不会再发送一次确认报文段。这样，服务器就无法按照正常步骤进入 **CLOSED** 状态。
- 防止“已失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个 `ACK` 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。服务器只要收到了客户端发出的确认，就进入 **CLOSED** 状态。同样，服务器在撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。注意，服务器结束 TCP 连接的时间要比客户端早一些。

除时间等待计时器外，TCP 还设有一个**保活计时器**（keepalive timer）。设想有这样的情况：客户主动与服务器建立了 TCP 连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。

## 解析

### DOM 构建

### CSSOM 构建

### 其他资源的加载

## 布局

## 合成

## 参考

- [URL 对象](https://wangdoc.com/javascript/bom/location#url-%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81)，阮一峰
- [What is a URL?](https://developer.mozilla.org/en-US/docs/Learn_web_development/Howto/Web_mechanics/What_is_a_URL)，MDN
