# 布局

## 盒模型

### 外边距折叠

块级元素的上边距和下边距有时会合并（折叠）成单个边距，其大小是各个边距中最大的那个（如果它们相等，则只取其中一个），这种行为称为**外边距折叠**（margin collapsing）。

外边距折叠发生在以下三种情况中。

- 相邻兄弟元素（除非后者需要清除浮动）。
- 没有内容分隔的父子元素。块级父元素与其子元素的垂直边距之间没有分隔的内容时就会发生折叠。具体包含以下两种情况：

  - 父元素的上边距与其第一个子元素的上边距折叠，除非父元素设置了 `padding-top`、`border-top`、包含任何内联内容（如文本）或应用了清除。
  - 父元素的下边距与其最后一个子元素的下边距折叠，除非父元素设置了高度、最小高度、`padding-bottom` 或者 `border-bottom`。

- 空的块级元素。如果块级元素的上边距和下边距之间没有高度、最小高度、内边距、边框和内联内容来分隔，那么它的上边距和下边距就会折叠。

另外，注意下面这些特殊情况。

- 边距折叠只发生在**垂直方向**。
- `display` 设置为 `flex` 或 `grid` 的容器，不会发生外边距折叠。
- 当涉及负边距时，外边距折叠的大小是最大正边距和最小（最负）负边距的和。
- 当所有边距都是负数时，外边距折叠的大小是最小（最负）的边距。该规则同样适用于相邻元素和嵌套元素。
- 这些规则同样适用于值为零的边距，因此根据上述规则，后代的边距最终会在其父元素之外，无论父元素的边距是否为零。
- 上述情况组合时，会发生更复杂的外边距折叠（超过两个边距）。

```html
<style>
  body {
    font: 1.2em sans-serif;
  }
  div {
    margin: 2rem 0;
    background: lavender;
  }
  
  p {
    margin: 0.4rem 0 1.2rem 0;
    background: yellow;
  }
</style>

<p>The bottom margin of this paragraph is collapsed …</p>
<p>
  … with the top margin of this paragraph, yielding a margin of
  <code>1.2rem</code> in between.
</p>

<div>
  This parent element contains two paragraphs!
  <p>
    This paragraph has a <code>.4rem</code> margin between it and the text
    above.
  </p>
  <p>
    My bottom margin collapses with my parent, yielding a bottom margin of
    <code>2rem</code>.
  </p>
</div>

<p>I am <code>2rem</code> below the element above.</p>
```

![外边距折叠](/2025/assets/margin-collapsing.png)

## 文档流

### 脱离文档流的方式

脱离文档流的元素会创建一个新的区块格式化上下文（BFC），它们内部的所有内容都可以被视为一个单独的布局，与页面的其余部分分离。因此，根元素（`<html>`）是脱离流的，作为文档中所有内容的容器，并为文档建立区块格式化上下文。

CSS 中，元素脱离文档流主要有两种方式：浮动定位和绝对定位，下面分别对他们进行介绍。

#### 浮动定位

```html
<style>
  body {
    font: 1.2em sans-serif;
  }
  p {
    background-color: #cccccc;
  }
  
  .float {
    float: left;
    font-weight: bold;
    width: 200px;
    border: 2px dotted black;
    padding: 10px;
  }
</style>

<div class="box">
  <div class="float">I am a floated box!</div>
  <p>
    One November night in the year 1782, so the story runs, two brothers sat
    over their winter fire in the little French town of Annonay, watching the
    grey smoke-wreaths from the hearth curl up the wide chimney. Their names
    were Stephen and Joseph Montgolfier, they were papermakers by trade, and
    were noted as possessing thoughtful minds and a deep interest in all
    scientific knowledge and new discovery.
  </p>
</div>
```

上面示例中，`class="float"` 的 `div` 元素开启了浮动布局，此时，这个元素就脱离了正常的文档流，并被其他元素的内容所环绕。

![开启了浮动的元素或脱离文档流](/2025/assets/float-out-of-flow.png "开启了浮动的元素或脱离文档流")

#### 绝对定位

开启了绝对定位的元素，也就是 `position` 属性设置为 `absolute` 或者 `fixed` 的元素，会被移出正常的文档流，并且元素不再占据相应的空间。

```html
<style>
  body {
    font: 1.2em sans-serif;
  }
  .box {
    width: 70%;
  }
  p {
    border: 2px solid green;
  }
  
  .abspos {
    position: absolute;
    background-color: green;
    color: white;
    top: 30px;
    right: 30px;
    width: 400px;
  }
</style>

<div class="box">
  <p>
    One November night in the year 1782, so the story runs, two brothers sat
    over their winter fire in the little French town of Annonay, watching the
    grey smoke-wreaths from the hearth curl up the wide chimney.
  </p>
  <p class="abspos">
    Their names were Stephen and Joseph Montgolfier, they were papermakers by
    trade, and were noted as possessing thoughtful minds and a deep interest in
    all scientific knowledge and new discovery.
  </p>
  <p>
    Before that night—a memorable night, as it was to prove—hundreds of millions
    of people had watched the rising smoke-wreaths of their fires without
    drawing any special inspiration from the fact.
  </p>
</div>
```

注意，设置了 `absolute` 定位的元素，相对于其最近的非 `static` 的祖先元素进行定位，如果没有这样的祖先元素，则相对于初始包含块（这个例子中是 `<html>` 元素）进行定位。

上面的代码显示效果如下。

![`absolute` 绝对定位脱离文档流](/2025/assets/absolute-out-of-flow.png "`absolute` 绝对定位脱离文档流")

另外，设置了 `position: fixed` 的元素一般是相对于视口（viewport）进行定位，并且位置不随页面滚动。

## 格式化上下文

格式化上下文包括多种类型，包括**区块格式化上下文**、**行内格式化上下文**和**弹性格式化上下文**。

页面上的所有内容都是格式化上下文的一部分，或者是一个被定义为以特定方式布局内容的区域。区块格式化上下文（BFC）将根据区块布局规则布局子元素，弹性格式化上下文将其子元素布局为弹性项目，等等。每一种格式化上下文都有其特定的布局规则。

### 区块格式化上下文

区块格式化上下文（Block Formatting Context，BFC）是网页中 CSS 视觉渲染的一部分。它是块级盒子布局发生的区域，也是浮动元素与其他元素交互的区域。BFC 内部是一个独立的布局区域，BFC 内部元素的布局不影响外部，外部元素的布局也不影响 BFC 内部。

下列方式会创建 BFC。

- 文档根元素（`<html>`）。
- 浮动元素（`float` 值不为 `none` 的元素）。
- 绝对定位元素（`position` 为 `absolute` 或 `fixed` 的元素）。
- `overflow` 值不为 `visible` 和 `clip` 的块级元素。
- `display` 值为 `flow-root` 或 `inline-block` 的元素。
- 弹性布局中的项目（`display` 值为 `flex` 或 `inline-flex` 元素的直接子元素），且它们本身不是弹性、网格或表格容器。
- 网格布局中的项目（`display` 值为 `grid` 或 `inline-grid` 元素的直接子元素），且它们本身不是弹性、网格或表格容器。
- 表格标题和表格单元格元素（`display` 分别为 `table-caption` 或 `table-cell` 的元素，这两个属性分别是表格标题和表格单元格的默认值）。
- 由 `display` 值为 `table`（表格）、`table-row`（表格行默认值）、`table-row-group`（表格主体默认值）、`table-header-group`（表格头部默认值）、`table-footer-group`（表格底部默认值）或 `inline-table` 的元素隐式创建的匿名表格单元格。
- 默认值为 `display: flow-root` 的 `<button>` 按钮和 `type="button"` 的 `<input>` 元素。
- `contain` 值为 `layout`、`content` 或 `paint` 的元素。
- 多列容器（`column-count` 或 `column-width` 不是 `auto` 的元素，包括 `column-count: 1` 的元素）。
- `column-span: all` 的元素，即使 `column-span: all` 元素不被多列容器包含。

BFC 对布局的影响主要体现在三个方面：

- **包含内部浮动**。
- **排除外部浮动**。
- **阻止外边距折叠**。

弹性/网格容器（即 `display` 设置为 `flex`、`grid`、`inline-flex` 或 `inline-grid` 的元素），会创建新的弹性/网格格式化上下文。他们与区块格式化上下文类似，除了弹性/网格容器内部没有可用的浮动子元素，它们依然排除外部浮动并阻止外边距折叠。

#### 包含内部浮动

设置 `overflow: auto` 或设置除 `overflow: visible` 初始值之外的其他值，会创建一个包含浮动元素的新的 BFC。

使用 `overflow` 创建新 BFC 的问题在于，`overflow` 属性旨在告诉浏览器如何处理溢出的内容。在某些情况下，当纯粹为了创建 `BFC` 而使用此属性时，会出现不想要的滚动条或被裁剪的阴影。另外，对于其他开发者来说，这可能不太友好，因为他人可能并不清楚为什么此处使用 `overflow`。如果确实要使用 `overflow`，最好注释代码以解释原因。

设置 `display: flow-root` 会创建一个新的 BFC，从 `flow-root` 这个名字就可以看出来，它创建一个新的用于流式布局的上下文，行为如同 root（`<html>`）元素。

`display: flow-root` 同时也是 `<button>` 元素和 `type="button"` 的 `<input>` 元素的默认值，也就是说，按钮默认会创建一个 BFC。

```html
<style>
  section {
    height: 150px;
  }
  .box1 {
    background-color: rgb(224 206 247);
    border: 5px solid rebeccapurple;
  }
  .box2,
  .box3 {
    background-color: aliceblue;
    border: 5px solid steelblue;
  }
  .box2 {
    overflow: auto;
  }
  .box3 {
    display: flow-root;
  }
  .float {
    float: left;
    width: 200px;
    height: 100px;
    background-color: rgb(255 255 255 / 50%);
    border: 1px solid black;
    padding: 10px;
  }
</style>

<section>
  <div class="box1">
    <div class="float">I am a floated box!</div>
    <p>I am content inside the container.</p>
  </div>
</section>
<section>
  <div class="box2">
    <div class="float">I am a floated box!</div>
    <p>I am content inside the <code>overflow:auto</code> container.</p>
  </div>
</section>
<section>
  <div class="box3">
    <div class="float">I am a floated box!</div>
    <p>I am content inside the <code>display:flow-root</code> container.</p>
  </div>
</section>
```

上面的示例中，第一个 box 容器中的浮动元素脱离了正常的文档流，此时 `<div>` 容器只包含浮动元素的内容而不包含浮动元素本身。第二个和第三个 box 容器，分别通过设置 `overflow: auto` 和 `display: flow-root` 创建了一个新的 BFC，这样，浮动元素就不会从容器的底部突出了，而是被包裹在了容器中。

上面的代码最终的显示效果如下。

![开启了 BFC 的元素将浮动元素包含在内](/2025/assets/contains-internal-floats.png "开启了 BFC 的元素将浮动元素包含在内")

注意，通过设置 `display: flow-root` 创建的 BFC **不会产生任何潜在的副作用**，所以应该优先使用这种方式创建 BFC。

#### 排除外部浮动

下面的代码，演示了通过设置 `display: flow-root` 创建 BFC，进而创建两列布局的实现方式。

```html
<style>
  section {
    height: 150px;
  }
  .box1 {
    background-color: rgb(224 206 247);
    border: 5px solid rebeccapurple;
  }
  .box2 {
    background-color: aliceblue;
    border: 5px solid steelblue;
    display: flow-root;
  }
  .float {
    float: left;
    overflow: hidden; /* required by resize:both */
    resize: both;
    margin-right: 25px;
    width: 200px;
    height: 100px;
    background-color: rgb(255 255 255 / 75%);
    border: 1px solid black;
    padding: 10px;
  }
</style>

<section>
  <div class="float">Try to resize this outer float</div>
  <div class="box1"><p>Normal</p></div>
</section>
<section>
  <div class="float">Try to resize this outer float</div>
  <div class="box2">
    <p><code>display:flow-root</code></p>
  </div>
</section>
```

与 `inline-block` 需要设置 `width: <percentage>` 不同的是，在这种方式中，我们不需要设置右侧 `<div>` 元素的宽度，就可以创建两列局部。

上面的代码显示效果如下。

![开启了 BFC 的元素将浮动的兄弟元素排除在外](/2025/assets/exclude-external-floats.png "开启了 BFC 的元素将浮动的兄弟元素排除在外")

这个例子说明，创建了 BFC 的元素，不会与同一个 BFC 中的、开启了浮动的元素的边框重叠。

注意，弹性盒子是现代 CSS 中实现多列布局的更有效的方法。

#### 阻止边距折叠

```html
<body>
  <style>
    .blue,
    .red {
      height: 50px;
      margin: 10px 0;
    }
    .blue {
      background: blue;
    }
    .red {
      background: red;
    }
  </style>

  <div class="blue"></div>
  <div class="red"></div>
</body>
```

上面的代码中的两个相邻的 `<div>` 元素，他们的垂直边距分别为 `10px`。由于外边距折叠的存在，它们之间的垂直间距是 `10px` 而不是 `20px`。

![两个 div 元素的垂直方向发生了外边距折叠](/2025/assets/margin-collapsing-without-bfc.png "两个 div 元素的垂直方向发生了外边距折叠")

```html
<style>
  .blue,
  .red {
    height: 50px;
    margin: 10px 0;
  }
  .blue {
    background: blue;
  }
  .red {
    background: red;
  }
  
  .outer {
    overflow: hidden;
    background: transparent;
  }
</style>

<div class="blue"></div>
<div class="outer">
  <div class="red"></div>
</div>
```

上面的代码，通过在红色 `<div>` 外部包裹一个容器，并使其创建一个新的 BFC，阻止了外边距折叠的发生。

![BFC 阻止了外边距折叠的发生](/2025/assets/prevent-margin-collapsing.png "BFC 阻止了外边距折叠的发生")

### 行内格式化上下文

行内格式化上下文（Inline Formatting Context，IFC）是网页视觉渲染的一部分，是 CSS 中用于处理行内元素（inline elements）布局的一种格式化上下文。它主要控制行内元素在水平方向上的排列和布局。

#### 触发条件

- 块级容器中仅包含行内元素时会创建 IFC。
- 块级容器中混合了行内元素和块级元素时，行内元素部分会创建 IFC。同时每一个连续的块级元素会创建新的 BFC，而行内元素会在 IFC 中排列，这种混合布局会形成多个格式化上下文的嵌套。
- 表格单元格（`display: table-cell`）、表格标题（`display: table-caption`）会创建 IFC，表格行组（`display: table-row-group`）中的行内元素参与 IFC。
- 弹性容器（`display: flex`）中的行内元素参与 IFC。这些行内元素会按照弹性布局的规则排列，但仍然保持 IFC 的特性，
弹性项目本身不会创建 IFC，除非它们包含行内元素。
- 网格容器（`display: grid`）中的行内元素参与 IFC。网格项目本身不创建 IFC，但其中的行内内容会，网格布局会为行内元素创建独立的 IFC 区域。

行内元素的布局方式跟书写模式有关。

- 在水平书写模式（如中文、英文）中，行内元素从左到右水平排列。
- 在垂直书写模式（如传统中文、日文）中，行内元素从上到下垂直排列。
- 元素按照文档流的顺序依次排列，不会跳过或重新排序。

```html
<style>
  body {
    font: 1.2em sans-serif;
  }
  .example {
    border: 5px solid black;
    margin: 20px;
  }
  
  .horizontal {
    writing-mode: horizontal-tb;
  }
  .vertical {
    writing-mode: vertical-rl;
  }
</style>

<div class="example horizontal">One Two Three</div>
<div class="example vertical">Four Five Six</div>
```

上面代码中，带有黑色边框的两个 `<div>` 元素是区块格式化上下文的一部分，在每个框内部，文字参与行内格式化上下文。水平书写模式中的文字水平沿水平方向排列，而垂直书写模式中的文字沿垂直方向排列。

![内联格式化上下文中的文字排列方式](/2025/assets/writing-mode-in-inline-formattting-context.png)

形成一行的框被包含在一个称为行框的矩形区域内。这个框必须足够大以包含该行中的所有行内元素；当内联方向没有更多空间时，就会创建另一行。因此，一个段落就是一组内联行框，按块级方向堆叠。

也就是说，IFC 会创建行框来包含行内元素，当行内方向没有更多空间时，会自动创建新的行框，每个行框的高度由该行中最高元素的行高决定，行框之间按照块级方向堆叠，形成段落或容器。

当一个内联框被分割时，在分割发生的地方，外边距、边框和内边距都没有视觉效果。

```html
<style>
  body {
    font: 1.2em sans-serif;
  }
  .example {
    border: 5px solid black;
    margin: 20px;
  }
  
  span {
    border: 5px solid rebeccapurple;
  }
</style>

<div class="example">
  Before that night—
  <span
    >a memorable night, as it was to prove— hundreds of millions of people</span
  >
  had watched the rising smoke-wreaths of their fires without drawing any
  special inspiration from the fact.
</div>
```

上面示例中，`<span>` 元素包含两行了文字，`<span>` 元素的边框在换行处断开了。

![span 元素的标签在换行处断开了](/2025/assets/border-breaks-at-the-breaking-point.png)

行内元素之间的间距由 `margin`、`padding` 和空白字符决定，空白字符（空格、换行、制表符）会被压缩为单个空格，行内元素不会独占一行，会与其他行内元素共享行空间，行框的宽度由容器宽度和内容决定。

`margin`、`border` 和 `padding` 在行内方向都是生效的，下面示例中的 `<span>` 元素就说明了这一点。

```html
<style>
  body {
    font: 1.2em sans-serif;
  }
  
  .example {
    border: 5px solid black;
    margin: 20px;
  }
  
  span {
    border: 5px solid rebeccapurple;
    padding-inline-start: 20px;
    padding-inline-end: 40px;
    margin-inline-start: 30px;
    margin-inline-end: 10px;
  }
  .horizontal {
    writing-mode: horizontal-tb;
  }
  
  .vertical {
    writing-mode: vertical-rl;
  }
</style>

<div class="example horizontal">One <span>Two</span> Three</div>
<div class="example vertical">Four <span>Five</span> Six</div>
```

![内边距、边框和外边距在行内方式是生效的](/2025/assets/margin-border-and-padding-works-well-in-inline-direction.png)

另外，行内元素默认按照基线（baseline）对齐，基线是文字书写的基础线，确保文字在同一行中视觉上对齐，不同字体大小和类型的元素会保持基线对齐，图片、图标等替换元素也会参与基线对齐。

#### 块级方向的对齐

行内元素可以使用 `vertical-align` 属性在垂直方向上以不同方式进行对齐（在垂直书写模式中就是水平方向）。`vertical-align` 支持多种对齐方式：`baseline`、`top`、`middle`、`bottom`、`text-top`、`text-bottom` 等。

注意，对齐是相对于行框进行的，不是相对于容器，不同对齐值会影响行框的高度计算。

```html
<style>
  body {
    font: 1.2em sans-serif;
  }
  
  span {
    font-size: 200%;
    vertical-align: top;
    background-color: rgb(224 206 247);
  }
  
  .example {
    border: 5px solid black;
    margin: 20px;
    inline-size: 400px;
  }
  
  .horizontal {
    writing-mode: horizontal-tb;
  }
  
  .vertical {
    writing-mode: vertical-rl;
  }
</style>

<div class="example horizontal">
  Before that night—<span>a memorable night</span>, as it was to prove—hundreds
  of millions of people had watched the rising smoke-wreaths of their fires
  without drawing any special inspiration from the fact.
</div>

<div class="example vertical">
  Before that night—<span>a memorable night</span>, as it was to prove—hundreds
  of millions of people had watched the rising smoke-wreaths of their fires
  without drawing any special inspiration from the fact.
</div>
```

上面的示例中，大号文字撑开了行框的高度，因此可以使用 `vertical-align` 属性来对齐其两侧的内联框。

![vertical-align 属性在不同书写模式中的效果](/2025/assets/vertical-align-in-different-writing-mode.png)

#### 内联方向的对齐

如果在内联方向上有额外的空间，可以使用 `text-align` 属性来在行框内对齐内联框。

```html
<style>
  body {
    font: 1.2em sans-serif;
  }
  
  .example {
    border: 5px solid black;
    margin: 20px;
  }
  
  .horizontal {
    writing-mode: horizontal-tb;
  }
  
  .vertical {
    writing-mode: vertical-rl;
  }
  .example {
    text-align: center;
    inline-size: 250px;
  }
</style>

<div class="example horizontal">One Two Three</div>
<div class="example vertical">Four Five Six</div>
```

![text-align 对其行内元素的例子](/2025/assets/text-align-can-be-used-to-align-inline-boxes.png)

#### 浮动的效果

行框通常在内联方向上具有相同的大小，因此在水平书写模式下具有相同的宽度，或在垂直书写模式下具有相同的高度。但是，如果在同一个块级格式化上下文中存在浮动元素，浮动元素会导致环绕它的行框变短。

```html
<style>
  body {
    padding: 100px;
    font: 1.2em sans-serif;
  }
  
  .box {
    background-color: rgb(224 206 247);
    border: 5px solid rebeccapurple;
  }
  
  .float {
    float: left;
    width: 250px;
    height: 150px;
    background-color: white;
    border: 1px solid black;
    padding: 10px;
  }
</style>


<div class="box">
  <div class="float">I am a floated box!</div>
  <p>I am content inside the container.</p>
</div>
```

![浮动的元素使得行框变短](/2025/assets/float-makes-inline-box-shorter.png)

## 参考

- [In flow and out of flow](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/In_flow_and_out_of_flow)，MDN
- [Introduction to formatting contexts](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/Introduction_to_formatting_contexts)，MDN
- [Block formatting context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/Block_formatting_context)，MDN
- [Inline formatting context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_inline_layout/Inline_formatting_context)，MDN
- [Mastering margin collapsing](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_box_model/Mastering_margin_collapsing)，MDN
