# 布局

## 文档流

### 脱离文档流的方式

脱离文档流的元素会创建一个新的区块格式化上下文（BFC），它们内部的所有内容都可以被视为一个单独的布局，与页面的其余部分分离。因此，根元素（`<html>`）是脱离流的，作为文档中所有内容的容器，并为文档建立区块格式化上下文。

CSS 中，元素脱离文档流主要有两种方式：浮动定位和绝对定位，下面分别对他们进行介绍。

#### 浮动定位

```html
<style>
  body {
    font: 1.2em sans-serif;
  }
  p {
    background-color: #cccccc;
  }
  
  .float {
    float: left;
    font-weight: bold;
    width: 200px;
    border: 2px dotted black;
    padding: 10px;
  }
</style>

<div class="box">
  <div class="float">I am a floated box!</div>
  <p>
    One November night in the year 1782, so the story runs, two brothers sat
    over their winter fire in the little French town of Annonay, watching the
    grey smoke-wreaths from the hearth curl up the wide chimney. Their names
    were Stephen and Joseph Montgolfier, they were papermakers by trade, and
    were noted as possessing thoughtful minds and a deep interest in all
    scientific knowledge and new discovery.
  </p>
</div>
```

上面示例中，`class="float"` 的 `div` 元素开启了浮动布局，此时，这个元素就脱离了正常的文档流，并被其他元素的内容所环绕。

![开启了浮动的元素或脱离文档流](/2025/assets/float-out-of-flow.png "开启了浮动的元素或脱离文档流")

#### 绝对定位

开启了绝对定位的元素，也就是 `position` 属性设置为 `absolute` 或者 `fixed` 的元素，会被移出正常的文档流，并且元素不再占据相应的空间。

```html
<style>
  body {
    font: 1.2em sans-serif;
  }
  .box {
    width: 70%;
  }
  p {
    border: 2px solid green;
  }
  
  .abspos {
    position: absolute;
    background-color: green;
    color: white;
    top: 30px;
    right: 30px;
    width: 400px;
  }
</style>

<div class="box">
  <p>
    One November night in the year 1782, so the story runs, two brothers sat
    over their winter fire in the little French town of Annonay, watching the
    grey smoke-wreaths from the hearth curl up the wide chimney.
  </p>
  <p class="abspos">
    Their names were Stephen and Joseph Montgolfier, they were papermakers by
    trade, and were noted as possessing thoughtful minds and a deep interest in
    all scientific knowledge and new discovery.
  </p>
  <p>
    Before that night—a memorable night, as it was to prove—hundreds of millions
    of people had watched the rising smoke-wreaths of their fires without
    drawing any special inspiration from the fact.
  </p>
</div>
```

注意，设置了 `absolute` 定位的元素，相对于其最近的非 `static` 的祖先元素进行定位，如果没有这样的祖先元素，则相对于初始包含块（这个例子中是 `<html>` 元素）进行定位。

上面的代码显示效果如下。

![`absolute` 绝对定位脱离文档流](/2025/assets/absolute-out-of-flow.png "`absolute` 绝对定位脱离文档流")

另外，设置了 `position: fixed` 的元素一般是相对于视口（viewport）进行定位，并且位置不随页面滚动。

## 格式化上下文

格式化上下文包括多种类型，包括**区块格式化上下文**、**行内格式化上下文**和**弹性格式化上下文**。

页面上的所有内容都是格式化上下文的一部分，或者是一个被定义为以特定方式布局内容的区域。区块格式化上下文（BFC）将根据区块布局规则布局子元素，弹性格式化上下文将其子元素布局为弹性项目，等等。每一种格式化上下文都有其特定的布局规则。

### 区块格式化上下文

区块格式化上下文（BFC）是网页中 CSS 视觉渲染的一部分。它是块级盒子布局发生的区域，也是浮动元素与其他元素交互的区域。BFC 内部是一个独立的布局区域，BFC 内部元素的布局不影响外部，外部元素的布局也不影响 BFC 内部。

下列方式会创建 BFC。

- 文档根元素（`<html>`）。
- 浮动元素（`float` 值不为 `none` 的元素）。
- 绝对定位元素（`position` 为 `absolute` 或 `fixed` 的元素）。
- `overflow` 值不为 `visible` 和 `clip` 的块级元素。
- `display` 值为 `flow-root` 或 `inline-block` 的元素。
- 弹性布局中的项目（`display` 值为 `flex` 或 `inline-flex` 元素的直接子元素），如果它们本身不是弹性、网格或表格容器。
- 网格布局中的项目（`display` 值为 `grid` 或 `inline-grid` 元素的直接子元素），如果它们本身不是弹性、网格或表格容器。
- 表格标题和表格单元格元素（`display` 分别为 `table-caption` 或 `table-cell` 的元素，这两个属性分别是表格标题和表格单元格的默认值）。
- 由 `display` 值为 `table`（表格）、`table-row`（表格行默认值）、`table-row-group`（表格主体默认值）、`table-header-group`（表格头部默认值）、`table-footer-group`（表格底部默认值）或 `inline-table` 的元素隐式创建的匿名表格单元格。
- 默认值为 `display: flow-root` 的 `<button>` 按钮和 `type="button"` 的 `<input>` 元素。
- `contain` 值为 `layout`、`content` 或 `paint` 的元素。
- 多列容器（`column-count` 或 `column-width` 不是 `auto` 的元素，包括 `column-count: 1` 的元素）。
- `column-span: all` 的元素，即使 `column-span: all` 元素不被多列容器包含。

BFC 对布局的影响主要体现在三个方面：

- **包含内部浮动**。
- **排除外部浮动**。
- **阻止外边距折叠**。

弹性/网格容器（即 `display` 设置为 `flex`、`grid`、`inline-flex` 或 `inline-grid` 的元素），会创建新的弹性/网格格式化上下文。他们与区块格式化上下文类似，除了弹性/网格容器内部没有可用的浮动子元素，它们依然排除外部浮动并阻止外边距折叠。

#### 包含内部浮动

设置 `overflow: auto` 或设置除 `overflow: visible` 初始值之外的其他值，会创建一个包含浮动元素的新的 BFC。

使用 `overflow` 创建新 BFC 的问题在于，`overflow` 属性旨在告诉浏览器如何处理溢出的内容。在某些情况下，当纯粹为了创建 `BFC` 而使用此属性时，会出现不想要的滚动条或被裁剪的阴影。另外，对于其他开发者来说，这可能不太友好，因为他人可能并不清楚为什么此处使用 `overflow`。如果确实要使用 `overflow`，最好注释代码以解释原因。

设置 `display: flow-root` 会创建一个新的 BFC，从 `flow-root` 这个名字就可以看出来，它创建一个新的用于流式布局的上下文，行为如同 root（`<html>`）元素。

`display: flow-root` 同时也是 `<button>` 元素和 `type="button"` 的 `<input>` 元素的默认值，也就是说，按钮默认会创建一个 BFC。

```html
<style>
  section {
    height: 150px;
  }
  .box1 {
    background-color: rgb(224 206 247);
    border: 5px solid rebeccapurple;
  }
  .box2,
  .box3 {
    background-color: aliceblue;
    border: 5px solid steelblue;
  }
  .box2 {
    overflow: auto;
  }
  .box3 {
    display: flow-root;
  }
  .float {
    float: left;
    width: 200px;
    height: 100px;
    background-color: rgb(255 255 255 / 50%);
    border: 1px solid black;
    padding: 10px;
  }
</style>

<section>
  <div class="box1">
    <div class="float">I am a floated box!</div>
    <p>I am content inside the container.</p>
  </div>
</section>
<section>
  <div class="box2">
    <div class="float">I am a floated box!</div>
    <p>I am content inside the <code>overflow:auto</code> container.</p>
  </div>
</section>
<section>
  <div class="box3">
    <div class="float">I am a floated box!</div>
    <p>I am content inside the <code>display:flow-root</code> container.</p>
  </div>
</section>
```

上面的示例中，第一个 box 容器中的浮动元素脱离了正常的文档流，此时 `<div>` 容器只包含浮动元素的内容而不包含浮动元素本身。第二个和第三个 box 容器，分别通过设置 `overflow: auto` 和 `display: flow-root` 创建了一个新的 BFC，这样，浮动元素就不会从容器的底部突出了，而是被包裹在了容器中。

上面的代码最终的显示效果如下。

![开启了 BFC 的元素将浮动元素包含在内](/2025/assets/contains-internal-floats.png "开启了 BFC 的元素将浮动元素包含在内")

注意，通过设置 `display: flow-root` 创建的 BFC **不会产生任何潜在的副作用**，所以应该优先使用这种方式创建 BFC。

#### 排除外部浮动

下面的代码，演示了通过设置 `display: flow-root` 创建 BFC，进而创建两列布局的实现方式。

```html
<style>
  section {
    height: 150px;
  }
  .box1 {
    background-color: rgb(224 206 247);
    border: 5px solid rebeccapurple;
  }
  .box2 {
    background-color: aliceblue;
    border: 5px solid steelblue;
    display: flow-root;
  }
  .float {
    float: left;
    overflow: hidden; /* required by resize:both */
    resize: both;
    margin-right: 25px;
    width: 200px;
    height: 100px;
    background-color: rgb(255 255 255 / 75%);
    border: 1px solid black;
    padding: 10px;
  }
</style>

<section>
  <div class="float">Try to resize this outer float</div>
  <div class="box1"><p>Normal</p></div>
</section>
<section>
  <div class="float">Try to resize this outer float</div>
  <div class="box2">
    <p><code>display:flow-root</code></p>
  </div>
</section>
```

与 `inline-block` 需要设置 `width: <percentage>` 不同的是，在这种方式中，我们不需要设置右侧 `<div>` 元素的宽度，就可以创建两列局部。

上面的代码显示效果如下。

![开启了 BFC 的元素将浮动的兄弟元素排除在外](/2025/assets/exclude-external-floats.png "开启了 BFC 的元素将浮动的兄弟元素排除在外")

这个例子说明，创建了 BFC 的元素，不会与同一个 BFC 中的、开启了浮动的元素的边框重叠。

注意，弹性盒子是现代 CSS 中实现多列布局的更有效的方法。

#### 阻止边距折叠

```html
<body>
  <style>
    .blue,
    .red {
      height: 50px;
      margin: 10px 0;
    }
    .blue {
      background: blue;
    }
    .red {
      background: red;
    }
  </style>

  <div class="blue"></div>
  <div class="red"></div>
</body>
```

上面的代码中的两个相邻的 `<div>` 元素，他们的垂直边距分别为 `10px`。由于外边距折叠的存在，它们之间的垂直间距是 `10px` 而不是 `20px`。

![两个 div 元素的垂直方向发生了外边距折叠](/2025/assets/margin-collapsing-without-bfc.png "两个 div 元素的垂直方向发生了外边距折叠")

```html
<style>
  .blue,
  .red {
    height: 50px;
    margin: 10px 0;
  }
  .blue {
    background: blue;
  }
  .red {
    background: red;
  }
  
  .outer {
    overflow: hidden;
    background: transparent;
  }
</style>

<div class="blue"></div>
<div class="outer">
  <div class="red"></div>
</div>
```

上面的代码，通过在红色 `<div>` 外部包裹一个容器，并使其创建一个新的 BFC，阻止了外边距折叠的发生。

![BFC 阻止了外边距折叠的发生](/2025/assets/prevent-margin-collapsing.png "BFC 阻止了外边距折叠的发生")

### 行内格式化上下文

## 参考

- [In flow and out of flow](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/In_flow_and_out_of_flow)，MDN
- [Introduction to formatting contexts](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/Introduction_to_formatting_contexts)，MDN
- [Block formatting context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_display/Block_formatting_context)，MDN
- [Inline formatting context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_inline_layout/Inline_formatting_context)，MDN
