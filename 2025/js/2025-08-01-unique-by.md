# 数组去重

## 使用 Set 对象

ES6 中新增了 Set 对象，Set 中的元素具有唯一性，可以根据这个特性进行数组去重。

```javascript
[...new Set(array)];

// 或者使用 Array.from
Array.from(new Set(array));
```

## 使用数组的 `filter()` 方法

```javascript
function unique(array) {
  return array.filter((item, index) => array.indexOf(item) === index);
}
```

## 使用数组的 `reduce()` 方法

```javascript
function unique(array) {
  return array.reduce((acc, cur) => {
    if (acc.includes(cur)) return acc;
    return acc.concat(cur);
  }, []);
}
```

## 使用 for 循环

通过 `for` 循环手动遍历，其他方法比如 `forEach` 也是类似的实现思路。

```javascript
function unique(array) {
  const result = [];

  for (let index = 0; index < array.length; index++) {
    const item = array[index];
    if (result.includes(item)) {
      result.push(item);
    }
  }

  return result;
}
```

下面是 `forEach` 结合 Map 实现对象去重的方法。

```javascript
function uniqueBy(array, property) {
  const map = new Map();
  
  array.forEach(item => {
    if (!map.has(item[property])) {
      map.set(item[property], item);
    }
  });

  return Array.from(map.values());
}
```

## 关于 `Array.prototype.uniqueBy()` 方法的提案

Github 上有一个关于数组的 `uniqueBy()` 方法的 [uniqueBy - proposal]，下面是它的一种实现。

```javascript
if (!('uniqueBy' in Array.prototype)) {
  Object.defineProperty(Array.prototype, 'uniqueBy', {
    value(resolver) {
      const that = Object(this);
      const length = lengthOfArrayLike(that);
      const resolverFunction = typeof resolver === 'function' ? resolver : function (value) {
        if (value == null) return value;
        if (value && value[resolver]) return value[resolver];
        return value;
      }

      const result = [];
      const map = new Map();
      for (let index = 0; index < length; index++) {
        if (!(index in that)) continue;
        const item = that[index];
        const key = resolverFunction(item);
        if (!map.has(key)) {
          map.set(key, item);
        }
      }

      map.forEach(function (value) {
        result.push(value);
      });

      return result;
    },
    writable: true,
    configurable: true,
  });
}
```

这个方法支持下面这些特性。

- 没有参数时，它的行为就像 `[...new Set(array)]`。
- 当参数为数值、字符串或者 Symbol 类型时，`uniqueBy()` 会去数组的每个元素中，按照给定的键，对数组元素进行去重。
- 当参数为函数，每次遍历时，都会执行这个函数，并且根据函数的返回值，对数组中的每个元素去重。

```javascript
[1, 2, 3, 3, 2, 1].uniqueBy();  // [1, 2, 3]

const data = [
  { id: 1, uid: 10000 },
  { id: 2, uid: 10000 },
  { id: 3, uid: 10001 }
];
data.uniqueBy('uid');
// [
//   { id: 1, uid: 10000 },
//   { id: 3, uid: 10001 }
// ]

data.uniqueBy(({ id, uid }) => `${id}-${uid}`);
// [
//   { id: 1, uid: 10000 },
//   { id: 2, uid: 10000 },
//   { id: 3, uid: 10001 }
// ]
```

[uniqueBy - proposal]: https://github.com/tc39/proposal-array-unique

## 参考

- [core-js](packages/core-js/internals/array-unique-by.js)
- [proposal-array-unique](https://github.com/tc39/proposal-array-unique)
