# 浅拷贝和深拷贝

## 一、浅拷贝

### 1.1 介绍

浅拷贝是指创建一个新对象，这个新对象与原始对象共享相同的内存地址，但只复制**第一层**属性的值。对于基本数据类型（如数字、字符串、布尔值），浅拷贝会复制实际的值；但对于引用数据类型（如对象、数组、函数），浅拷贝只复制引用（指针），而不是复制实际的数据内容。

由于不需要递归遍历所有层级，浅拷贝的性能通常比深拷贝要好，内存占用也较少。

如果只想拷贝第一层数据，或者嵌套的对象不需要独立修改，就可以考虑使用浅拷贝。

### 1.2 扩展运算符（`...`）

扩展运算符（`...`），也包括下面的解构复制，都是 ES6 中新增的特性。可用于对象和数组的复制和合并操作。

```javascript
const foo = { a: { b: 1 } };
const bar = { ...foo };

foo.a.b = 2;

bar // { a: { b: 2 } }
```

### 1.3 解构赋值

```javascript
const foo = { a: { b: 1 } };

const { a: bar } = foo;
const { a: baz } = foo;

foo.a.b = 2;

bar // { b: 2 }
baz // { b: 2 }
```

### 1.4 Object.assign()

`Object.assign(target, ...sources)` 方法是 ES6 中新增的方法，用于执行对象属性的合并。它能将源对象**自身的**、所有**可枚举的**属性（包括 Symbol）属性，复制到目标对象，并返回目标对象。

```javascript
const foo = { a: { b: 1 } };
const bar = Object.assign({}, foo);
foo.a.b = 2;

bar // { a: { b: 2 } }
```

### 1.5 Array.from()

`Array.from(arrayLike, mapFn, thisArg)` 也是 ES6 中新增的方法，用于将类似数组的对象和部署了 Iterator 接口的对象，转为真正的数据。

```javascript
const foo = [{ a: 1 }];
const bar = Array.from(foo);
foo[0].a = 2;

bar // [ { a: 2 } ]
```

### 1.6 Array.prototype.slice()

```javascript
const foo = [{ a: 1 }];
const bar = foo.slice();
foo[0].a = 2;

bar // [ { a: 2 } ]
```

### 1.7 Array.prototype.concat()

```javascript
const foo = [{ a: 1 }];
const bar = [].concat(foo);
foo[0].a = 2;

bar // [ { a: 2 } ]
```

### 1.8 for

也可以通过 `for`、`for...of` 和 `for...in` 等循环手动实现浅拷贝，这类方法的原理都一样，这里只演示 `for...in` 的例子。

```javascript
const foo = { a: { b: 1 } }
const bar = {};

for (const key in foo) {
  if (foo.hasOwnProperty(key)) {
    bar[key] =  foo[key];
  }
}
foo.a.b = 2;

bar // { a: { b: 2 } }
```

## 二、深拷贝

### 2.1 介绍

深拷贝是指创建一个新对象，这个新对象与原始对象完全独立，包括所有嵌套的对象和数组。深拷贝会递归地复制所有层级的数据，确保原始对象和拷贝对象之间没有任何引用关系。这意味着修改拷贝对象中的任何属性都不会影响原始对象，反之亦然。

深拷贝可以处理各种数据类型，但需要注意某些特殊类型（如函数、DOM 节点）的处理。

### 2.2 `JSON.stringify()`

- 对象中如果包含循环引用的属性，使用该方法序列化时会报错。
- 对于 Set、WeakSet、Map、WeakMap 对象，只会序列化可枚举的属性。
- 无法转换 Symbol 的键值、函数键、`undefined` 值，函数、`undefined` 被单独转换时，会返回 `undefined`。
- 对象中如果有 `toJSON()` 方法，`JSON.stringify()` 序列化的不是该对象，而是 `toJSON()` 方法返回的值。
- Date 对象在序列化时会调用自身的 `toJSON()` 方法，因此实际被序列化的是该方法返回的结果。
- 布尔值、数字、字符串的包装对象，在序列化过程中会自动转为对应的原始值，导致类型丢失。
- 非数组对象的属性，在序列化后无法保证其顺序。
- `null`、NaN 和 Infinity 都会被转为 `null`。

正是由于 `JSON.stringify()` 方法的这些问题，在执行深拷贝时，一般不考虑使用这个方法。除非是对于那些结构简单、属性已知的对象。

### 2.3 `structuredClone()`

JavaScript 原生提供了 `structuredClone()` 方法执行深拷贝操作，该方法使用 [结构化克隆算法](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/structuredClone)来序列化对象。

```javascript
structuredClone(value, options)
```

该方法接受两个参数。

- `value`：表示要操作的属性。
- `options`：可选的配置对象，该对象只有一个 `transfer` 属性，用来指定一个可转移对象数组。如果提供了该属性，则数组中的对象将被转移到新对象，之后原始对象将不可用。

```javascript
const foo = { a: 1 };
foo.itself = foo;

const clone = structuredClone(foo);

clone !== foo // true
clone.a === 1 // true
clone.itself === clone // true
```

这个方法使用简单，能够处理大多数数据类型，也能处理对象中循环引用的属性，而且性能好。但是该方法也有两个问题，如果对象中包含函数和 DOM 节点，这个方法会报错。

```javascript
structuredClone({
  bar() {},
});

// Uncaught DataCloneError: Failed to execute 'structuredClone' on 'Window': bar() {} could not be cloned.
```

下面是对象中包含 DOM 元素时的执行结果。

```javascript
structuredClone({
  div: document.createElement('div')
});

// Uncaught DataCloneError: Failed to execute 'structuredClone' on 'Window': HTMLDivElement object could not be cloned.
```

结构化克隆算法之所以不支持函数属性和 DOM 节点，跟它的使用场景有关，该方法经常在 JavaScript 的通信 API 中，比如下面的 MessageChannel API，这就使得它必须考虑函数和 DOM 节点这两种特殊的类型。

对于函数来说，函数体中包含对创建时环境的引用，比如闭包，这些引用不应该跨消息通道传递，因为函数可能引用外部变量，这些变量在目标上下文中很可能不存在。另外，函数中包含可执行代码，在一个上下文能安全执行的代码，在另一个上下文就可能出问题，即使不会抛出错误，安全性也是一个值得考虑的问题。

而 DOM 节点包含样式、事件监听器、子节点等复杂信息，这些信息是与特定的文档上下文绑定的。此外，允许传递 DOM 节点还可能带来安全风险，恶意代码可能通过 DOM 操作影响页面。

### 2.4 MessageChannel

MessageChannel API 是 JavaScript 原生提供的，用于不同上下文之间传递消息的接口，相当于提供了一种一对一的通信机制。它可以实现浏览器的同一上下文、不同上下文、主窗口和 iframe 窗口以及不同 worker 线程之间的通信。

```javascript
const channel = new MessageChannel();
channel.port1.onmessage = function (event) {
  console.log(event.data);
  // Hello from port2
};

channel.port2.postMessage('Hello from port2');
```

上面的代码，通过 `MessageChannel` 构造函数创建了一个 `channel` 实例，`channel` 上有两个端口：`port1` 和 `port2`，相当于通信的两个端口。这时，一个端口发送消息，另一个端口就可以接收消息。

利用这个机制，就可以实现对象的深拷贝。

```javascript
function deepClone(obj) {
  return new Promise((resolve, reject) => {
    try {
      const channel = new MessageChannel();
      channel.port1.onmessage = function (event) {
        channel.port1.close();
        resolve(event.data);
      };
      channel.port2.postMessage(obj);
    } catch (error) {
      reject(error);
    }
  });
}
```

下面是一个测试的例子。

```javascript
(async function() {
  const foo = { a: { b: 1 } };
  const copy = await deepClone(foo);

  foo === copy // false

  foo.a.b = 2;

  copy // { a: { b: 1 } }
})()
```

使用 MessageChannel API 执行深拷贝有很多优点。比如，能够处理循环引用的属性，以及大多数数据类型，异步执行，不会阻塞主线程。但由于 `postMessage` 方法内部使用结构化克隆算法来序列化数据，所以依然无法处理对象中包含函数和 DOM 节点的情况。

关于 MessageChannel API 详细信息，可以参考 [这里](/2025/js/2025-08-11-message-channel.md)。

### 2.5 手动实现

除了使用第三方库外，比较可靠的方式还是通过手动实现，不过手动实现深拷贝稍有些复杂，要考虑到各种数据类型，而且要处理好递归的问题。

```javascript
const { typeOf } = require('./_internals/utils/type-of');

function deepClone(obj, visited = new WeakMap()) {
  if (obj == null 
    || Number.isNaN(obj) 
    || typeof obj !== 'object') {
      return obj;
    };

  if (visited.has(obj)) {
    return visited.get(obj);
  }

  let clone;

  switch (typeOf(obj)) {
    case 'array': {
      clone = [];
      visited.set(obj, clone);
      for (let index = 0; index < obj.length; index++) {
        clone[index] = deepClone(obj[index], visited);
      }
    } break;
    case 'date':
      return new Date(obj.getTime());
    case 'regexp':
      return new RegExp(obj.source, obj.flags);
    case 'set': {
      clone = new Set();
      visited.set(obj, clone);
      for (const item of obj) {
        clone.add(deepClone(item));
      }
    } break;
    case 'map': {
      clone = new Map();
      visited.set(obj, clone);
      for (const [key, item] of obj.entries()) {
        clone.set(key, deepClone(item, visited));
      }
    } break;
    default:
      clone = Object.create(Object.getPrototypeOf(obj));  
      visited.set(obj, clone);

      const descriptors = {};
      const keys = Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
      
      for (const key of keys) {
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc.value) {
          desc.value = deepClone(desc.value, visited)
        }
        descriptors[key] = desc;
      }
  
      Object.defineProperties(clone, descriptors);
  }

  return clone;
}
```

下面是一个测试的例子。

```javascript
const foo = {
  a: null,
  b: undefined,
  c: Number.NaN,
  d: true,
  e: 123,
  f: 0xBC,
  g: 'foo',
  h: 123n,
  i: Symbol('foo'),
  j: [
    true,
    123,
    'foo',
    ['a', { 'b': 'foo' }],
  ],
  j: {
    a: true,
    b: 123,
    c: 'foo',
    d: [123],
    e: {
      f: 'foo',
    },
  },
  k: new Set([true, 123, 'foo']),
  l: new Map([
    ['a', true],
    ['b', 123],
    ['c', 'foo'],
  ]),
  m (name) {
    this.name = name;
  },
  n: new RegExp(/.*?/g),
  [Symbol('foo')]: 'foo symbol',
};

foo.x = foo;
foo.y = foo.j;
foo.z = {
  bar: 'bar',
};

console.log(deepClone(foo));

// 结果输出如下
{/* 
<ref *1> {
  a: null,
  b: undefined,
  c: NaN,
  d: true,
  e: 123,
  f: 188,
  g: 'foo',
  h: 123n,
  i: Symbol(foo),
  j: { a: true, b: 123, c: 'foo', d: [ 123 ], e: { f: 'foo' } },
  k: Set(3) { true, 123, 'foo' },
  l: Map(3) { 'a' => true, 'b' => 123, 'c' => 'foo' },
  m: [Function: m],
  n: /.*?/g,
  x: [Circular *1],
  y: { a: true, b: 123, c: 'foo', d: [ 123 ], e: { f: 'foo' } },
  z: { bar: 'bar' },
  [Symbol(foo)]: 'foo symbol'
} 
*/}
```

## 三、参考

- [JSON.stringify()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)，MDN
- [structuredClone()](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/structuredClone)，MDN
- [Channel Messaging API](https://developer.mozilla.org/zh-CN/docs/Web/API/Channel_Messaging_API)，MDN
- [对象的扩展](https://es6.ruanyifeng.com/#docs/object)，阮一峰
- [数组的扩展](https://es6.ruanyifeng.com/#docs/array)，阮一峰
