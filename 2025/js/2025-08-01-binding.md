# call、apply 和 bind

## `Function.prototype.apply`

```javascript
if (!('apply' in Function.prototype)) {
  Object.defineProperty(Function.prototype, 'apply', {
    value: function apply(thisArg, argsArray) {
      // 类型检查：确保 this 是函数
      if (typeof this !== 'function') {
        throw new TypeError('Function.prototype.apply called on incompatible ' + typeof this);
      }

      const context = getContext(thisArg);

      let args;
      if (argsArray == null) {
        args = [];
      } else if (typeof argsArray === 'object') {
        if (typeof argsArray.length === 'number' && argsArray.length >= 0) {
          args = [];
          for (let i = 0; i < argsArray.length; i++) {
            args[i] = argsArray[i];
          }
        } else {
          throw new TypeError('CreateListFromArrayLike called on non-object');
        }
      } else {
        throw new TypeError('CreateListFromArrayLike called on non-object');
      }

      const tempKey = Symbol('__apply_polyfill_temp_key__');
      
      try {
        context[tempKey] = this;
        
        return context[tempKey](...args);
      } finally {
        try {
          delete context[tempKey];
        } catch (error) {
          // 忽略删除错误
        }
      }
    },
    writable: true,
    configurable: true,
    enumerable: false
  });
}
```

```javascript
if (!('apply' in Function.prototype)) {
  Object.defineProperty(Function.prototype, 'apply', {
    value: function apply(thisArg, argsArray) {
      if (typeof this !== 'function') {
        throw new TypeError('Function.prototype.apply called on incompatible ' + typeof this);
      }

      const context = getContext(thisArg);
      
      // 处理 argsArray 参数
      let args = [];
      if (argsArray != null) {
        if (typeof argsArray === 'object' && typeof argsArray.length === 'number' && argsArray.length >= 0) {
          for (let i = 0; i < argsArray.length; i++) {
            if (i in argsArray) {
              args[i] = argsArray[i];
            }
          }
        } else {
          throw new TypeError('CreateListFromArrayLike called on non-object');
        }
      }

      const tempKey = Symbol('__apply_polyfill_temp_key__');
      
      try {
        context[tempKey] = this;
        
        let argsString = '';
        if (args.length > 0) {
          argsString = args.map((_, index) => `args[${index}]`).join(',');
        }
        
        const evalString = `context[tempKey](${argsString})`;
        return eval(evalString);
      } finally {
        try {
          delete context[tempKey];
        } catch (error) {
          // 忽略删除错误
        }
      }
    },
    writable: true,
    configurable: true,
    enumerable: false
  });
}
```

## `Function.prototype.call`

当通过 `obj.fn()` 或者 `obj['fn']()` 调用对象中的方法时，方法中的 `this` 指向对象本身。

```javascript
function getContext(thisArg) {
  let context;

  if (thisArg == null) {
    // 优先使用 globalThis，然后是其他全局对象
    if (typeof globalThis !== 'undefined') {
      context = globalThis;
    } else if (typeof global !== 'undefined') {
      context = global;
    } else if (typeof window !== 'undefined') {
      context = window;
    } else if (typeof self !== 'undefined') {
      context = self;
    } else {
      // 最后的备选方案
      context = Function('return this')();
    }
  } else {
    context = Object(thisArg);
  }

  return context;
}

if (!('call' in Function.prototype)) {
  Object.defineProperty(Function.prototype, 'call', {
    value: function call(thisArg, ...args) {
      if (typeof this !== 'function') {
        throw new TypeError('Function.prototype.call called on incompatible ' + typeof this);
      }

      const context = getContext(thisArg);
      
      const tempKey = Symbol('__call_polyfill_temp_key__');
      
      try {
        context[tempKey] = this;

        return context[tempKey](...args);;
      } finally {
        try {
          delete context[tempKey];
        } catch (error) {
          // 如果 context 是不可扩展的或属性不可删除，忽略错误
        }
      }
    },
    writable: true,
    configurable: true,
    enumerable: false
  });
}
```

借助 `eval()` 函数实现。

```javascript
if (!('call' in Function.prototype)) {
  Object.defineProperty(Function.prototype, 'call', {
    value: function call(thisArg, ...args) {
      if (typeof this !== 'function') {
        throw new TypeError('Function.prototype.call called on incompatible ' + typeof this);
      }

      const context = getContext(thisArg);
      
      const tempKey = Symbol('__call_polyfill_temp_key__');
      
      try {
        context[tempKey] = this;
        
        let argsString = '';
        if (args.length > 0) {
          argsString = args.map((_, index) => `args[${index}]`).join(',');
        }
        
        const evalString = `context[tempKey](${argsString})`;
        return eval(evalString);
      } finally {
        try {
          delete context[tempKey];
        } catch (error) {
          // 如果 context 是不可扩展的或属性不可删除，忽略错误
        }
      }
    },
    writable: true,
    configurable: true,
    enumerable: false
  });
}
```

## `Function.prototype.bind`

JavaScript 的动态特性允许任何对象通过原型链访问 `Function.prototype` 的方法。由于 `bind` 方法只能被函数调用，方法中最开始的判断，是为了防止以下几种情况的调用。
  
（1）非函数对象调用。
  
  ```javascript
  const obj = {};
  obj.bind = Function.prototype.bind;
  obj.bind();
  ```

（2）通过 `call` 或 `apply` 改变 `this`，比如：`Function.prototype.bind.call({});`。

（3）意外的上下文丢失。

  ```javascript
  const bind = Function.prototype.bind;
  bind();
  ```

借助 `Object.create` 方法实现绑定。

```javascript
if (!('bind' in Function.prototype)) {
  Object.defineProperty(Function.prototype, 'bind', {
    value: function bind(thisArg, ...boundArgs) {
      if (typeof this !== 'function') {
        throw new TypeError('Function.prototype.bind called on incompatible ' + typeof this);
      }

      const targetFunction = this;
      
      const context = getContext(thisArg);

      const boundFunction = function(...callArgs) {
        // 处理 this 绑定：如果使用 new 调用，使用新创建的对象；否则使用绑定的 context
        const thisContext = this instanceof boundFunction ? this : context;
        
        // 合并参数：boundArgs 在前，callArgs 在后
        const finalArgs = boundArgs.concat(callArgs);
        
        return targetFunction.apply(thisContext, finalArgs);
      };

      if (targetFunction.prototype) {
        boundFunction.prototype = Object.create(targetFunction.prototype);
      }

      Object.defineProperty(boundFunction, 'name', {
        value: 'bound ' + (targetFunction.name || 'anonymous'),
        configurable: true
      });

      Object.defineProperty(boundFunction, 'length', {
        value: Math.max(0, targetFunction.length - boundArgs.length),
        configurable: true
      });

      Object.defineProperty(boundFunction, 'toString', {
        value: function() {
          return targetFunction.toString();
        },
        configurable: true,
        writable: true
      });

      // 设置 caller 和 arguments 属性（如果环境支持）
      try {
        Object.defineProperty(boundFunction, 'caller', {
          get: function() {
            throw new TypeError('Function.prototype.caller is not accessible');
          },
          set: function() {
            throw new TypeError('Function.prototype.caller is not writable');
          },
          configurable: true
        });

        Object.defineProperty(boundFunction, 'arguments', {
          get: function() {
            throw new TypeError('Function.prototype.arguments is not accessible');
          },
          set: function() {
            throw new TypeError('Function.prototype.arguments is not writable');
          },
          configurable: true
        });
      } catch (error) {
        // 如果环境不支持这些属性，忽略错误
      }

      return boundFunction;
    },
    writable: true,
    configurable: true,
    enumerable: false
  });
}
```

## 参考

- [Function，MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function)
