# 定时器

## setTimeout

### 替代方案

#### MessageChannel

MessageChannel API 是原生提供的一种用于一对一的通信机制，通过执行 `MessageChannel` 构造函数生成的两个 port，可以实现不同上下文之间的通信。这个 API 也可以用来模式实现 `setTimeout`，而且相比于后者，MessageChannel API 有很多优点。

- MessageChannel 同样能够实现异步宏任务操作。
- MessageChannel 没有 `setTimeout` 的最低延迟。
- 某些情况下，`setTimeout` 的执行时机可能变得难以预测。比如，当设备处于后台或者低电量模式时，`setTimeout` 可能会被浏览器节流，而 MessageChannel 不会有这个问题。

```javascript
let enqueueTask;

if (typeof MessageChannel !== 'undefined') {
  enqueueTask = function (callback) {
    const channel = new MessageChannel();
    channel.port1.onmessage = function () {
      channel.port1.close();
      callback();
    }
    channel.port2.postMessage(undefined);
  }
}

if (enqueueTask) {
  enqueueTask(() => {
    console.log('in enqueueTask');
  });
}

console.log('start');

// start
// in enqueueTask
```

使用 `MessageChannel` 执行异步操作，实际上也是执行的宏任务，它的优先级要低于微任务。

React 中对 `setTimeout` 的模拟，就是通过上面的代码实现的。

## setInterval

### 消除定时器偏差

定时器偏差（Timer Drift）是指定时器实际执行时间与预期时间之间的差异。简单来说，就是当你设置一个定时器每1000毫秒（1秒）执行一次时，实际执行的时间间隔可能不是精确的 1000 毫秒，而是可能变成 1050 毫秒、980 毫秒等。

定时器的偏差是不确定的，除了定时器本身累积的误差，还可能受系统负载、垃圾回收机制、系统事件循环机制等的影响。

比如下面的代码，在系统压力较大时运行，就可能出现比较明显的误差。

```javascript
let count = 0;
const startTime = Date.now();

const timer = setInterval(() => {
  count++;
  const actualTime = Date.now();
  const expectedTime = startTime + (count * 1000);
  const drift = actualTime - expectedTime;
  
  console.log(`第 ${count} 次执行，偏差: ${drift}ms`);
  
  if (count >= 10) {
    clearInterval(timer);
    console.log(`总偏差: ${drift}ms`);
  }
}, 1000);

// 第1次执行，偏差: 15ms
// 第2次执行，偏差: 32ms
// 第3次执行，偏差: 48ms
// ...
// 第10次执行，偏差: 156ms
// 总偏差: 156ms
```

注意，上面代码的实际误差可能并不准确，这里只是为了说明定时器偏差的存在。

#### 简单时间补偿

```javascript
function createPreciseTimer(callback, interval) {
  let startTime = Date.now();
  let expectedTime = startTime;
  let running = false;
  let timerId = null;
  
  function tick() {
    if (!running) return;
    
    const now = Date.now();
    const drift = now - expectedTime;
    
    callback();
    
    expectedTime += interval;
    const nextTick = Math.max(0, interval - drift);
    
    timerId = setTimeout(tick, nextTick);
  }
  
  function start() {
    if (running) return;

    running = true;
    startTime = Date.now();
    expectedTime = startTime;

    tick();
  }
  
  function stop() {
    running = false;
    if (timerId) {
      clearTimeout(timerId);
      timerId = null;
    }
  }
  
  return {
    start,
    stop,
    isRunning: () => running,
    getElapsedTime: () => Date.now() - startTime
  };
}
```

```javascript
const timer = createPreciseTimer(() => {
  console.log('定时器执行:', new Date().toISOString());
}, 1000);

timer.start(); // 启动

// 5秒后停止
setTimeout(() => {
  timer.stop();
  console.log('定时器已停止');
}, 5000);
```

#### 累积偏差补偿

```javascript
class PreciseTimer {
  constructor(callback, interval) {
    this.callback = callback;
    this.interval = interval;
    this.startTime = null;
    this.expectedTime = null;
    this.running = false;
    this.timerId = null;
    this.tickCount = 0;
  }
  
  start() {
    if (this.running) return;
    
    this.running = true;
    this.startTime = Date.now();
    this.expectedTime = this.startTime;
    this.tickCount = 0;
    this.tick();
  }
  
  stop() {
    this.running = false;
    if (this.timerId) {
      clearTimeout(this.timerId);
      this.timerId = null;
    }
  }
  
  isRunning() {
    return this.running;
  }
  
  getTickCount() {
    return this.tickCount;
  }
  
  getElapsedTime() {
    if (!this.startTime) return 0;
    return Date.now() - this.startTime;
  }
  
  tick() {
    if (!this.running) return;
    
    const now = Date.now();
    const drift = now - this.expectedTime;
    
    this.tickCount++;
    this.callback({
      tickCount: this.tickCount,
      currentTime: now,
      expectedTime: this.expectedTime,
      drift: drift,
      elapsed: now - this.startTime
    });
    
    this.expectedTime += this.interval;
    const nextTick = Math.max(0, this.interval - drift);
    
    this.timerId = setTimeout(() => this.tick(), nextTick);
  }
}
```

```javascript
const timer = new PreciseTimer((data) => {
  console.log(`第 ${data.tickCount} 次执行，偏差: ${data.drift}ms`);
}, 1000);

timer.start();

// 5秒后停止
setTimeout(() => {
  timer.stop();
  console.log('定时器已停止');
}, 5000);
```

#### 基于帧率的定时器

```javascript
class FrameBasedTimer {
  constructor(callback, targetFPS = 60) {
    this.callback = callback;
    this.targetFPS = targetFPS;
    this.frameInterval = 1000 / targetFPS;
    this.lastFrameTime = 0;
    this.running = false;
    this.animationId = null;
    this.frameCount = 0;
  }
  
  start() {
    if (this.running) return;
    
    this.running = true;
    this.lastFrameTime = performance.now();
    this.frameCount = 0;
    this.animate();
  }
  
  stop() {
    this.running = false;
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }

  isRunning() {
    return this.running;
  }
  
  getFrameCount() {
    return this.frameCount;
  }
  
  getFPS() {
    if (!this.running || this.frameCount === 0) return 0;
    const elapsed = performance.now() - this.lastFrameTime;
    return (this.frameCount / elapsed) * 1000;
  }
  
  animate(currentTime) {
    if (!this.running) return;
    
    if (currentTime - this.lastFrameTime >= this.frameInterval) {
      this.frameCount++;
      this.callback({
        frameCount: this.frameCount,
        currentTime: currentTime,
        fps: this.getFPS()
      });
      this.lastFrameTime = currentTime;
    }
    
    this.animationId = requestAnimationFrame((time) => this.animate(time));
  }
}
```

```javascript
const frameTimer = new FrameBasedTimer((data) => {
  console.log(`第 ${data.frameCount} 帧，FPS: ${data.fps.toFixed(2)}`);
}, 60);

frameTimer.start();

// 5秒后停止
setTimeout(() => {
  frameTimer.stop();
  console.log('帧定时器已停止');
}, 5000);
```

####

```javascript
class HighPrecisionTimer {
  constructor(callback, interval) {
    this.callback = callback;
    this.interval = interval;
    this.startTime = null;
    this.expectedTime = null;
    this.running = false;
    this.timerId = null;
    this.tickCount = 0;
    this.totalDrift = 0;
  }
  
  start() {
    if (this.running) return;
    
    this.running = true;
    this.startTime = performance.now();
    this.expectedTime = this.startTime;
    this.tickCount = 0;
    this.totalDrift = 0;
    this.tick();
  }
  
  stop() {
    this.running = false;
    if (this.timerId) {
      clearTimeout(this.timerId);
      this.timerId = null;
    }
  }

  isRunning() {
    return this.running;
  }
  
  getTickCount() {
    return this.tickCount;
  }
  
  getElapsedTime() {
    if (!this.startTime) return 0;
    return performance.now() - this.startTime;
  }
  
  getAverageDrift() {
    if (this.tickCount === 0) return 0;
    return this.totalDrift / this.tickCount;
  }
  
  getAccuracy() {
    if (this.tickCount === 0) return 100;
    const avgDrift = Math.abs(this.getAverageDrift());
    return Math.max(0, (1 - avgDrift / this.interval) * 100);
  }
  
  tick() {
    if (!this.running) return;
    
    const now = performance.now();
    const drift = now - this.expectedTime;
    
    this.tickCount++;
    this.totalDrift += drift;
    
    this.callback({
      tickCount: this.tickCount,
      currentTime: now,
      expectedTime: this.expectedTime,
      drift: drift,
      totalDrift: this.totalDrift,
      averageDrift: this.getAverageDrift(),
      accuracy: this.getAccuracy(),
      elapsed: now - this.startTime
    });
    
    this.expectedTime += this.interval;
    const nextTick = Math.max(0, this.interval - drift);
    
    this.timerId = setTimeout(() => this.tick(), nextTick);
  }
}
```

```javascript
const highPrecisionTimer = new HighPrecisionTimer((data) => {
  console.log(`第 ${data.tickCount} 次执行，偏差: ${data.drift.toFixed(2)}ms，精度: ${data.accuracy.toFixed(2)}%`);
}, 1000);

highPrecisionTimer.start();

// 10秒后停止
setTimeout(() => {
  highPrecisionTimer.stop();
  console.log('高精度定时器已停止');
  console.log(`最终统计：执行 ${highPrecisionTimer.getTickCount()} 次，平均偏差 ${highPrecisionTimer.getAverageDrift().toFixed(2)}ms，精度 ${highPrecisionTimer.getAccuracy().toFixed(2)}%`);
}, 10000);
```

#### 页面可见性感知

```javascript
class VisibilityAwareTimer {
  constructor(callback, interval) {
    this.callback = callback;
    this.interval = interval;
    this.startTime = null;
    this.expectedTime = null;
    this.running = false;
    this.isPageVisible = true;
    this.timerId = null;
    this.tickCount = 0;
    this.pausedTime = 0;
    
    this.setupVisibilityListener();
  }
  
  setupVisibilityListener() {
    document.addEventListener('visibilitychange', () => {
      const wasVisible = this.isPageVisible;
      this.isPageVisible = !document.hidden;
      
      if (wasVisible && !this.isPageVisible && this.running) {
        // 页面变为不可见，记录暂停时间
        this.pausedTime = performance.now();
      } else if (!wasVisible && this.isPageVisible && this.running) {
        // 页面重新可见，重新同步时间
        this.resync();
      }
    });
  }
  
  start() {
    if (this.running) return;
    
    this.running = true;
    this.startTime = performance.now();
    this.expectedTime = this.startTime;
    this.tickCount = 0;
    this.pausedTime = 0;
    this.tick();
  }
  
  stop() {
    this.running = false;
    if (this.timerId) {
      clearTimeout(this.timerId);
      this.timerId = null;
    }
  }
  
  isRunning() {
    return this.running;
  }
  
  getTickCount() {
    return this.tickCount;
  }
  
  getElapsedTime() {
    if (!this.startTime) return 0;
    const now = performance.now();
    return now - this.startTime - (this.pausedTime > 0 ? now - this.pausedTime : 0);
  }
  
  isPageVisible() {
    return this.isPageVisible;
  }
  
  resync() {
    const now = performance.now();
    const elapsed = now - this.startTime;
    const missedTicks = Math.floor(elapsed / this.interval);
    
    this.expectedTime = this.startTime + (missedTicks + 1) * this.interval;
    this.pausedTime = 0;
  }
  
  tick() {
    if (!this.running) return;
    
    const now = performance.now();
    const drift = now - this.expectedTime;
    
    this.tickCount++;
    this.callback({
      tickCount: this.tickCount,
      currentTime: now,
      expectedTime: this.expectedTime,
      drift: drift,
      elapsed: this.getElapsedTime(),
      isPageVisible: this.isPageVisible
    });
    
    this.expectedTime += this.interval;
    const nextTick = Math.max(0, this.interval - drift);
    
    this.timerId = setTimeout(() => this.tick(), nextTick);
  }
}
```

```javascript
const visibilityTimer = new VisibilityAwareTimer((data) => {
  console.log(`第 ${data.tickCount} 次执行，偏差: ${data.drift.toFixed(2)}ms，页面可见: ${data.isPageVisible}`);
}, 1000);

visibilityTimer.start();

// 10秒后停止
setTimeout(() => {
  visibilityTimer.stop();
  console.log('可见性感知定时器已停止');
}, 10000);
```

## 参考

- [react 源码](https://github.com/facebook/react/blob/cc015840ef72d48de86778785894c7ca44f4f856/packages/scheduler/src/forks/Scheduler.js#L532)
