# webpack 中的插件

## 一、介绍

## 二、`html-webpack-plugin`

### 2.1 介绍

[html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin) 是 webpack 生态系统中一个非常重要的插件。下面是该插件的主要作用。

- 如果项目中不存在入口 HTML（`index.html`）文件，则自动创建该文件；如果存在入口文件，可以以该文件为模板，创建一个新的入口文件。
- 将项目打包后的各种资源，注入到入口文件中。
- 压缩 HTML 代码。

下面列出了该插件常见的配置项。

- `template`：指定 HTML 模板文件路径。这是最核心的配置项。
- `filename`：指定生成的 HTML 文件名，支持占位符。默认值为 `'index.html'`。
- `inject`：控制资源注入的位置和方式。可选值为布尔值、`'head'` 和 `'body'`。如果指定为 `'head'`，则注入到 `<head>` 标签中，默认值为 `true`。
- `title`：设置 HTML 页面的标题。这个值会替换模板中的 `<%= htmlWebpackPlugin.options.title %>`。
- `templateParameters`：对象类型。向模板传递自定义参数。可以在模板中使用这些参数。比如，`<title><%= appName %> v<%= version %></title>`。
- `hash`：控制是否使用文件名哈希。当设置为 `true` 时，插件会在资源文件名后添加哈希值，用于缓存破坏。
- `minify`：压缩选项。生产环境中的重要配置，可通过该配置项指定具体的压缩行为。
- `chunks`：控制哪些 chunk 会被注入到 HTML 中，默认注入所有的 chunk。
- `favicon`：设置网站的 favicon 图标。
- `meta`：用于添加 `<meta>` 标签。

  比如，如果指定为下面的配置。

  ```javascript
  meta: {
    viewport: 'width=device-width, initial-scale=1, shrink-to-fit=no'
  }
  ```

  会创建一个这样的 meta 标签。

  ```html
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  ```

### 2.2 自定义压缩行为

`minify` 配置项控制压缩 HTML 代码的具体行为。生产模式下，默认值为 `true`，此时，webpack 使用内置的 [html-minifier-terser](https://github.com/DanielRuf/html-minifier-terser)插件，压缩 HTML 代码。也就是说，`minify` 配置项其实是对 `html-minifier-terser` 插件进行配置。其他模式下值为 `false`，表示不开启压缩。

下面是 `minify` 配置项的默认值。

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      minify: {
        // 默认值
        collapseWhitespace: true, // 移除空白符
        removeComments: true, // 移除 HTML 注释
        keepClosingSlash: false, // 移除自闭合标签的斜杠
        removeRedundantAttributes: true, // 移除冗余属性
        removeScriptTypeAttributes: true, // 移除 script 的 type 属性
        removeStyleLinkTypeAttributes: true, // 移除 style 和 link 的 type 属性
        useShortDoctype: true, // 使用短文档类型
      },
    }),
  ],
};
```

除了上面的默认属性，还可以考虑配置下面的几个属性。

- `minifyJS: true`：压缩内联 JavaScript。
- `minifyCSS: true`：压缩内联 CSS。
- `minifyURLs: true`：压缩 URL。
- `removeEmptyElements: true`：移除空元素。
- `removeEmptyAttributes: true`：移除空属性。
- `collapseBooleanAttributes: true`：压缩布尔属性。

### 2.3 变量注入

`html-webpack-plugin` 提供了强大的变量注入功能，允许在 HTML 模板中使用各种 webpack 和插件提供的变量。这些变量可以帮助我们动态生成HTML内容，实现更灵活的模板配置。

`htmlWebpackPlugin.options` 对象包含了传递给 `HtmlWebpackPlugin` 的所有配置选项。

`htmlWebpackPlugin.files` 对象包含了 webpack 打包后的文件信息。通过这个对象，可以获取所有需要被注入的样式、脚本和 chunks 数组。

```html
<!-- 注入所有 CSS 文件 -->
<% htmlWebpackPlugin.files.css.forEach(function(cssFile) { %>
  <link href="<%= cssFile %>" rel="stylesheet">
<% }); %>

<!-- 注入所有 JS 文件 -->
<% htmlWebpackPlugin.files.js.forEach(function(jsFile) { %>
  <script src="<%= jsFile %>"></script>
<% }); %>

<!-- 遍历所有 chunks -->
<% Object.keys(htmlWebpackPlugin.files.chunks).forEach(function(chunkName) { %>
  <% var chunk = htmlWebpackPlugin.files.chunks[chunkName]; %>
  <% if (chunk.css) { %>
    <% chunk.css.forEach(function(cssFile) { %>
      <link href="<%= cssFile %>" rel="stylesheet">
    <% }); %>
  <% } %>
  <% if (chunk.js) { %>
    <% chunk.js.forEach(function(jsFile) { %>
      <script src="<%= jsFile %>"></script>
    <% }); %>
  <% } %>
<% }); %>
```

通过 `templateParameters` 属性，可以注入自定义变量到模板中。

```javascript
// webpack.config.js
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      templateParameters: {
        // 应用信息
        appName: 'React应用',
        version: '1.0.0',
        environment: process.env.NODE_ENV || 'development',
        
        // 配置信息
        cdnUrl: process.env.CDN_URL || 'https://cdn.example.com',
        
        // 功能开关
        enableAnalytics: process.env.NODE_ENV === 'production',
        enableDebug: process.env.NODE_ENV === 'development',
        
        // 自定义函数
        formatDate: function(date) {
          return new Date(date).toLocaleDateString();
        },
        
        // 复杂对象
        config: {
          theme: 'light',
          language: 'zh-CN',
          features: ['feature1', 'feature2'],
        },
      },
    }),
  ],
};
```

```html
<!-- public/index.html -->
<!DOCTYPE html>
<html lang="<%= config.language %>">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= appName %> v<%= version %></title>
  
  <!-- 应用信息 -->
  <meta name="app-name" content="<%= appName %>">
  <meta name="version" content="<%= version %>">
  <meta name="environment" content="<%= environment %>">
  
  <!-- 配置信息 -->
  <meta name="cdn-url" content="<%= cdnUrl %>">

  <!-- 使用条件渲染避免不必要的代码 -->
  <% if (environment === 'production') { %>
    <!-- 生产环境特定代码 -->
    <meta name="robots" content="index, follow">
    <script src="https://analytics.example.com/tracker.js"></script>
  <% } else { %>
    <!-- 开发环境特定代码 -->
    <meta name="robots" content="noindex, nofollow">
    <script>
      console.log('开发模式已启用');
    </script>
  <% } %>
    
  <!-- 条件渲染 -->
  <% if (enableAnalytics) { %>
    <script>
      // 生产环境分析代码
      window.analytics = {
        enabled: true,
        track: function(event) {
          console.log('Analytics:', event);
        }
      };
    </script>
  <% } %>
  
  <% if (enableDebug) { %>
    <script>
      // 开发环境调试代码
      window.debug = {
        enabled: true,
        log: function(message) {
          console.log('Debug:', message);
        }
      };
    </script>
  <% } %>
  
  <!-- 主题配置 -->
  <script>
    window.appConfig = {
      theme: '<%= config.theme %>',
      language: '<%= config.language %>',
      features: <%- JSON.stringify(config.features) %>,
    };
  </script>
</head>
<body>
  <div style="display: none;">
    <p>应用名称: <%= appName %></p>
    <p>版本: <%= version %></p>
    <p>环境: <%= environment %></p>
  </div>
</body>
</html>
```

### 2.4 模板优化

这部分内容，在 [模板优化](/2025/react/2025-08-04-optimization.md) 有详细介绍。

[示例代码](/examples/webpack/demos/html-optimization/)

## DllPlugin 和 DllReferencePlugin

## 基本概念

### 什么是 DLL？

DLL (Dynamic Link Library) 是动态链接库的缩写，在 Webpack 中，DllPlugin 用于将第三方库预先打包成独立的文件，这些文件可以在后续的构建过程中被重复使用，避免重复打包相同的库。

### 解决的问题

- **重复打包**: 每次构建都会重新打包第三方库
- **构建速度慢**: 第三方库通常很大，重复打包耗时
- **缓存失效**: 第三方库变化导致整个 bundle 缓存失效

## DllPlugin 详解

DllPlugin 将指定的第三方库打包成独立的文件，并生成一个 manifest 文件，记录库的模块信息。

### 配置示例

```javascript
// webpack.dll.config.js
const webpack = require('webpack');
const path = require('path');

module.exports = {
  mode: 'production',
  entry: {
    // 将常用的第三方库打包到vendor中
    vendor: [
      'react',
      'react-dom',
      'react-router-dom',
      'lodash',
      'axios',
      'moment',
      'antd',
    ],
    // 将UI组件库单独打包
    ui: [
      'antd',
      '@ant-design/icons',
      '@ant-design/pro-components',
    ],
    // 将工具库单独打包
    utils: [
      'lodash',
      'moment',
      'dayjs',
      'uuid',
    ],
  },
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name].dll.js',
    library: '[name]_library',
    // 确保DLL文件可以被其他构建过程访问
    publicPath: '/',
  },
  plugins: [
    new webpack.DllPlugin({
      // manifest文件的输出路径
      path: path.join(__dirname, 'dist', '[name]-manifest.json'),
      // 暴露出的DLL的函数名
      name: '[name]_library',
      // 上下文，默认为webpack的上下文
      context: __dirname,
    }),
    // 添加版权信息
    new webpack.BannerPlugin({
      banner: 'DLL文件 - 构建时间: ' + new Date().toISOString(),
    }),
  ],
  // 优化配置
  optimization: {
    minimize: true,
    splitChunks: false, // DLL中不需要代码分割
  },
};
```

### 高级配置

```javascript
// webpack.dll.config.js - 高级版本
const webpack = require('webpack');
const path = require('path');
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  mode: 'production',
  entry: {
    vendor: [
      'react',
      'react-dom',
      'react-router-dom',
    ],
    ui: [
      'antd',
      '@ant-design/icons',
    ],
    utils: [
      'lodash',
      'moment',
      'axios',
    ],
  },
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name].[contenthash:8].dll.js',
    library: '[name]_library',
    publicPath: '/',
    // 清理旧的DLL文件
    clean: true,
  },
  plugins: [
    new webpack.DllPlugin({
      path: path.join(__dirname, 'dist', '[name]-manifest.json'),
      name: '[name]_library',
      context: __dirname,
    }),
    // 定义环境变量
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify('production'),
    }),
    // 添加构建信息
    new webpack.BannerPlugin({
      banner: (chunk) => {
        return `/* ${chunk.name} DLL - Built at ${new Date().toISOString()} */`;
      },
    }),
  ],
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        parallel: true,
        terserOptions: {
          compress: {
            drop_console: true,
            drop_debugger: true,
          },
        },
      }),
    ],
  },
  // 性能提示
  performance: {
    hints: false, // 关闭性能提示
  },
};
```

## DllReferencePlugin 详解

### 工作原理

DllReferencePlugin 在主构建过程中引用 DllPlugin 生成的 manifest 文件，避免重复打包已经在 DLL 中的模块。

### 3.2 基础配置

```javascript
// webpack.config.js
const webpack = require('webpack');
const path = require('path');

module.exports = {
  mode: 'production',
  entry: './src/index.js',
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name].[contenthash:8].js',
  },
  plugins: [
    // 引用vendor的manifest
    new webpack.DllReferencePlugin({
      manifest: require('./dist/vendor-manifest.json'),
      // 可选：指定DLL文件的路径
      sourceType: 'var',
    }),
    // 引用ui的manifest
    new webpack.DllReferencePlugin({
      manifest: require('./dist/ui-manifest.json'),
      sourceType: 'var',
    }),
    // 引用utils的manifest
    new webpack.DllReferencePlugin({
      manifest: require('./dist/utils-manifest.json'),
      sourceType: 'var',
    }),
  ],
};
```

### 3.3 高级配置

```javascript
// webpack.config.js - 高级版本
const webpack = require('webpack');
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  mode: 'production',
  entry: './src/index.js',
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name].[contenthash:8].js',
    clean: true,
  },
  plugins: [
    // 引用vendor DLL
    new webpack.DllReferencePlugin({
      manifest: require('./dist/vendor-manifest.json'),
      sourceType: 'var',
      // 可选：指定DLL文件的路径
      context: __dirname,
    }),
    // 引用ui DLL
    new webpack.DllReferencePlugin({
      manifest: require('./dist/ui-manifest.json'),
      sourceType: 'var',
      context: __dirname,
    }),
    // 引用utils DLL
    new webpack.DllReferencePlugin({
      manifest: require('./dist/utils-manifest.json'),
      sourceType: 'var',
      context: __dirname,
    }),
    // HTML模板，自动引入DLL文件
    new HtmlWebpackPlugin({
      template: './public/index.html',
      filename: 'index.html',
      // 自动注入DLL文件
      inject: true,
      // 自定义模板变量
      templateParameters: {
        dllFiles: [
          '/vendor.dll.js',
          '/ui.dll.js',
          '/utils.dll.js',
        ],
      },
    }),
  ],
  // 优化配置
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // 避免与DLL冲突
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
          priority: 10,
        },
      },
    },
  },
};
```

## 4. HTML 模板配置

### 4.1 手动引入 DLL 文件

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My App</title>
</head>
<body>
  <div id="root"></div>
  
  <!-- 预加载DLL文件 -->
  <script src="%PUBLIC_URL%/vendor.dll.js"></script>
  <script src="%PUBLIC_URL%/ui.dll.js"></script>
  <script src="%PUBLIC_URL%/utils.dll.js"></script>
  
  <!-- 主应用文件 -->
  <script src="%PUBLIC_URL%/main.js"></script>
</body>
</html>
```

### 4.2 自动注入 DLL 文件

```javascript
// webpack.config.js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const fs = require('fs');
const path = require('path');

// 自动读取DLL文件
function getDllFiles() {
  const dllDir = path.join(__dirname, 'dist');
  const files = fs.readdirSync(dllDir);
  return files
    .filter(file => file.endsWith('.dll.js'))
    .map(file => `/${file}`);
}

module.exports = {
  // ... 其他配置
  plugins: [
    // ... 其他插件
    new HtmlWebpackPlugin({
      template: './public/index.html',
      filename: 'index.html',
      inject: true,
      templateParameters: {
        dllFiles: getDllFiles(),
      },
    }),
  ],
};
```

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My App</title>
</head>
<body>
  <div id="root"></div>
  
  <!-- 自动注入DLL文件 -->
  <% dllFiles.forEach(function(file) { %>
    <script src="<%= file %>"></script>
  <% }); %>
</body>
</html>
```

## 5. 构建脚本配置

### 5.1 package.json 脚本

```json
{
  "scripts": {
    "build:dll": "webpack --config webpack.dll.config.js",
    "build:dll:watch": "webpack --config webpack.dll.config.js --watch",
    "build": "npm run build:dll && webpack --config webpack.config.js",
    "build:prod": "NODE_ENV=production npm run build",
    "dev": "npm run build:dll && webpack serve --config webpack.config.js",
    "clean": "rimraf dist .cache",
    "rebuild": "npm run clean && npm run build"
  }
}
```

### 5.2 自动化构建脚本

```javascript
// scripts/build.js
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

function buildDll() {
  console.log('开始构建DLL文件...');
  
  // 检查是否需要重新构建DLL
  const dllFiles = [
    'dist/vendor.dll.js',
    'dist/ui.dll.js',
    'dist/utils.dll.js',
  ];
  
  const needRebuild = dllFiles.some(file => !fs.existsSync(file));
  
  if (needRebuild) {
    execSync('npm run build:dll', { stdio: 'inherit' });
    console.log('DLL文件构建完成');
  } else {
    console.log('DLL文件已存在，跳过构建');
  }
}

function buildApp() {
  console.log('开始构建应用...');
  execSync('webpack --config webpack.config.js', { stdio: 'inherit' });
  console.log('应用构建完成');
}

// 主构建流程
function main() {
  try {
    buildDll();
    buildApp();
    console.log('所有构建任务完成');
  } catch (error) {
    console.error('构建失败:', error);
    process.exit(1);
  }
}

main();
```

## 6. 性能优化策略

### 6.1 DLL 文件分割策略

```javascript
// 按功能分割DLL
const dllConfig = {
  // 核心框架
  core: [
    'react',
    'react-dom',
    'react-router-dom',
  ],
  // UI组件库
  ui: [
    'antd',
    '@ant-design/icons',
    '@ant-design/pro-components',
  ],
  // 工具库
  utils: [
    'lodash',
    'moment',
    'dayjs',
    'uuid',
  ],
  // 网络请求
  network: [
    'axios',
    'fetch',
  ],
  // 状态管理
  state: [
    'redux',
    'react-redux',
    '@reduxjs/toolkit',
  ],
};
```

### 6.2 缓存策略

```javascript
// webpack.dll.config.js
module.exports = {
  output: {
    filename: '[name].[contenthash:8].dll.js',
    // 使用contenthash确保内容变化时文件名变化
  },
  plugins: [
    new webpack.DllPlugin({
      path: path.join(__dirname, 'dist', '[name]-manifest.json'),
      name: '[name]_library',
    }),
  ],
};
```

### 6.3 按需加载策略

```javascript
// 根据环境动态选择DLL
const isDev = process.env.NODE_ENV === 'development';

const dllEntries = {
  vendor: [
    'react',
    'react-dom',
  ],
};

// 开发环境添加更多库
if (isDev) {
  dllEntries.vendor.push(
    'react-hot-loader',
    'webpack-dev-server',
  );
}

module.exports = {
  entry: dllEntries,
  // ... 其他配置
};
```

## 7. 常见问题和解决方案

### 7.1 DLL 文件路径问题

```javascript
// 解决方案：使用绝对路径
const path = require('path');

module.exports = {
  output: {
    path: path.resolve(__dirname, 'dist'),
    publicPath: '/',
  },
  plugins: [
    new webpack.DllReferencePlugin({
      manifest: path.resolve(__dirname, 'dist/vendor-manifest.json'),
    }),
  ],
};
```

### 7.2 版本冲突问题

```javascript
// 解决方案：使用peerDependencies
// package.json
{
  "peerDependencies": {
    "react": "^17.0.0 || ^18.0.0",
    "react-dom": "^17.0.0 || ^18.0.0"
  }
}
```

### 7.3 热更新问题

```javascript
// 解决方案：开发环境不使用DLL
const isDev = process.env.NODE_ENV === 'development';

if (isDev) {
  // 开发环境直接打包，不使用DLL
  module.exports = {
    // 普通配置
  };
} else {
  // 生产环境使用DLL
  module.exports = {
    plugins: [
      new webpack.DllReferencePlugin({
        manifest: require('./dist/vendor-manifest.json'),
      }),
    ],
  };
}
```

## 8. 最佳实践

### 8.1 选择合适的库

```javascript
// 适合放入DLL的库
const dllLibraries = [
  // 大型框架
  'react',
  'react-dom',
  'vue',
  'angular',
  
  // UI组件库
  'antd',
  'element-ui',
  'material-ui',
  
  // 工具库
  'lodash',
  'moment',
  'dayjs',
  
  // 网络库
  'axios',
  'fetch',
  
  // 状态管理
  'redux',
  'mobx',
  'vuex',
];
```

### 8.2 监控和优化

```javascript
// 监控DLL文件大小
const fs = require('fs');
const path = require('path');

function analyzeDllSize() {
  const dllDir = path.join(__dirname, 'dist');
  const files = fs.readdirSync(dllDir);
  
  files
    .filter(file => file.endsWith('.dll.js'))
    .forEach(file => {
      const filePath = path.join(dllDir, file);
      const stats = fs.statSync(filePath);
      const sizeInMB = (stats.size / 1024 / 1024).toFixed(2);
      console.log(`${file}: ${sizeInMB} MB`);
    });
}

// 在构建完成后调用
analyzeDllSize();
```

### 8.3 自动化管理

```javascript
// 自动更新DLL配置
const packageJson = require('./package.json');

function generateDllConfig() {
  const dependencies = Object.keys(packageJson.dependencies || {});
  
  // 根据依赖自动生成DLL配置
  const dllConfig = {
    vendor: dependencies.filter(dep => 
      ['react', 'vue', 'angular'].some(framework => 
        dep.includes(framework)
      )
    ),
    ui: dependencies.filter(dep => 
      ['antd', 'element', 'material'].some(ui => 
        dep.includes(ui)
      )
    ),
    utils: dependencies.filter(dep => 
      ['lodash', 'moment', 'dayjs', 'axios'].some(util => 
        dep.includes(util)
      )
    ),
  };
  
  return dllConfig;
}
```
