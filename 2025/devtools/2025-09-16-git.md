# Git

## 介绍

### 内部状态管理

Git 的内部状态管理机制，分为三个部分，每个部分保存着不同的状态变更。

![Git 的状态管理流程](/2025/assets/git/git-basic-command-workflow.png)

上面的图片演示了内部状态管理的工作流程，其中：

- Workspace 表示工作区，是本地项目所在的目录，开发中我们直接操作的，就是这个目录下的所有内容。
- Index 表示暂存区，这是一个临时区域，存放着下一次要提交的内容的修改，当执行 `git add` 命令时，工作区内容的修改就会被暂存到这个区，暂存区中文件的状态为已暂存（Staged）。暂存区中的所有内容，会被当作下一次提交。
- Repository 表示本地仓库区，存放着完整的提交历史记录。当执行 `git commit` 命令时，暂存区中所有暂存的内容，会被记录到一个新的快照中，并被提交到这个区。

### HEAD 指针

HEAD 是一个特殊的指针，它总是指向当前分支的最新提交。在正常状态（Attached HEAD）下，HEAD 指向分支指针，分支指针再指向提交；在分离状态（Detached HEAD）下，HEAD 直接指向某个提交。

下面的代码演示了正常状态下 HEAD 的指向。

```bash
git status
# On branch main
# Your branch is up to date with 'origin/main'.
```

上面代码中，HEAD 指向 `main` 分支，`main` 分支指向 `abc1234` 这个提交。

分离状态下，HEAD 直接指向某个提交。

```bash
git checkout abc1234
git status
# HEAD detached at abc1234
```

上面代码中，HEAD 直接指向 `abc1234` 这个提交。

注意，在分离状态下提交会创建"悬空"提交，需要创建分支保存。

可以通过 `git checkout` 移动 HEAD 指针，或者使用 `git reset` 同时移动 HEAD 和分支指针。

#### 引用方式

HEAD 有两种引用方式：`HEAD~n` 表示线性历史中的第 n 个父提交，它沿着第一个父提交的路径回溯；`HEAD^n` 表示合并提交中的第 n 个父提交，它可以选择不同的父提交路径。

```bash
# 创建线性提交
git init
echo "A"  > file.txt && git add . && git commit -m "A"
echo "B" >> file.txt && git add . && git commit -m "B"  
echo "C" >> file.txt && git add . && git commit -m "C"

# 创建分支并合并
git checkout -b feature
echo "D" >> file.txt && git add . && git commit -m "D"
echo "E" >> file.txt && git add . && git commit -m "E"

git checkout main
git merge feature

git log --oneline --graph
# *   abc1234 (HEAD) Merge branch 'feature'
# |\  
# | * def5678 E
# | * ghi9012 D  
# * | jkl3456 C
# * | mno7890 B
# * | pqr1234 A

# 使用 ~ 符号（线性历史）
HEAD~1 # 指向 C（第一个父提交）
HEAD~2 # 指向 B
HEAD~3 # 指向 A

# 使用 ^ 符号（合并历史）
HEAD^1 # 指向 C（第一个父提交）
HEAD^2 # 指向 E（第二个父提交，来自 feature 分支）
```

此外，两种符号还可以组合使用。

```bash
HEAD~2^2 # 上两个提交的第二个父提交
HEAD^2~1 # 第二个父提交的上一个提交
HEAD~3^2 # 上三个提交的第二个父提交
```

#### 恢复

HEAD 指向变更后，可以使用 `reflog` 进行恢复。

```bash
# 查看 HEAD 的移动历史
git reflog
# abc1234 HEAD@{0}: checkout: moving from main to abc1234
# def5678 HEAD@{1}: commit: 最新提交
# ghi9012 HEAD@{2}: commit: 第二个提交

# 恢复到之前的状态
git checkout HEAD@{1}
```

## 常用操作

### 撤销

#### `git revert`

`git revert` 用于对提交进行撤销操作，该命令会创建一个新的提交来撤销指定的提交。它有三种使用方式，分别用来撤销单个提交、多个提交和某个范围的提交。

```bash
# 撤销单个提交
git revert [commit]

# 撤销多个提交
git revert [commit1] [commit2] [commit3]

# 撤销某个范围的提交，包括 newest-commit，但不包括 oldest-commit
git revert [oldest-commit]..[newest-commit]
```

下面的例子，创建了一个空的 `README.md` 文件，之后向这个文件中写入了两次内容，分别是 `First content` 和 `Bad content`。

```bash
git init .
touch README.md
echo "First content" >> README.md
git add README.md
git commit -am "first commit"

echo "Bad content" >> README.md
git commit -am "second commit"

git log --oneline
# 3602d88 bad commit
# 299b15f first commit
```

第二次写入的内容 `Bad content` 是我们不小心写入的内容，这时，可以通过 `git revert` 命令来撤销第二次的操作结果。

```bash
git revert HEAD
# [main b9cd081] Revert "Bad content" 1 file changed, 1 deletion(-)

$ git log --oneline
# b9cd081 Revert "bad commit"
# 3602d88 bad commit
# 299b15f first commit
```

上面的代码，`git revert HEAD` 对最近的一次提交 `3602d88` 进行了撤销操作，这个命令没有删除最近的提交，而是在撤销完成后，创建了一个新的提交。此时，`README.md` 中只有 `First content`，最后一次提交的 `Bad content` 被撤销了。

注意，在撤销过程中可能会发生代码冲突，此时要使用下面两个命令来控制冲突解决流程。

```bash
# 解决冲突后继续
git revert --continue

# 取消 revert 操作
git revert --abort
```

对于已推送提交的撤销，应该优先考虑使用 `git revert` 操作。因为它是一个安全的操作，不会破坏提交历史，而且保留了完整的操作记录。

`git revert` 在使用时还可以携带参数。

- `-e` / `--edit` 默认值，表示打开编辑器让用户编辑提交信息，该参数会自动生成一个默认的提交信息。

  ```bash
  git revert HEAD

  # 或者显式指定
  git revert -e HEAD
  git revert --edit HEAD
  ```

- `--no-edit` 表示不打开编辑器，直接使用自动生成的提交信息，该参数会会自动生成一个默认的提交信息。该参数，包括上面的 `-e` 和 `--edit` 参数，生成的默认提交信息格式都为 `Revert "默认生成的提交信息格式"`。
- `-n` / `--no-commit` 表示执行撤销操作但不自动提交，并将更改放入暂存区，之后用户可以手动添加提交信息。

另外，`get revert` 和 `git reset` 都能够执行撤销操作，但是它们的原理并不相同。`get revert` 在撤销某个（些）提交时，并不会删除这些提交，而是撤销这些提交所修改的内容，并在时间线结尾创建一个新的提交。而 `git reset` 执行撤销操作时，是通过删除某（个）些提交来实现。下面的图片展示了他们之间的这种差异。

![git revert 和 git reset 执行撤销的机制不同](/2025/assets/git/difference-between-reverting-and-resetting.svg)

#### `git reset`

`git reset` 用于对提交进行重置操作，该命令通过修改工作区、暂存区和本地仓库中的历史提交记录，来撤销对本地内容的修改。

该命令常用的格式有两种。

```bash
git reset [command] HEAD~n

# 或者
git reset [command] [commit]
```

上面的两个命令都表示，将 HEAD 指针移动到指定的提交。其中，第一个命令中的 `n`，表示将 HEAD 移动到它前面的第 n 个提交；第二个命令中的 `[commit]`，是某次提交的哈希值。n

`git reset` 有三个可选的 `[command]` 参数，下面分别对他们进行介绍。

##### `--soft`

`git reset --soft [commit]` 表示软重置，该参数的行为如下。

- 移动 HEAD 指向特定的 `[commit]`。
- 工作区不会发生任何变化，`[commit]` 之后的提交（即原始的 HEAD 和新的 HEAD 之间的内容）重新回到暂存区（状态为已暂存，staged）。
- 此时，`[commit]` 之后提交的内容变为“未提交的更新”，就像你刚提交了某个特定的 commit，然后对这些“未提交的更新”做出了修改，并执行了 `git add` 一样。

假设在某一时刻，`main` 分支中存在三个提交，其中在最后一次提交（`abc1234`）对 `file.text` 文件进行了更新操作。

```bash
# 假设当前状态
git log --oneline
# abc1234 (HEAD) 最新提交
# def5678 第二个提交
# ghi9012 第一个提交
```

然后执行 `git reset --soft HEAD~1` 命令，尝试将提交重置到第二个提交。

```bash
# 执行软重置
git reset --soft HEAD~1

# 执行后的状态
git log --oneline
# def5678 (HEAD) 第二个提交
# ghi9012 第一个提交
```

查看当前分支的最新状态。

```bash
git status
# On branch main
# Changes to be committed:
#   modified:   file.txt
```

上面的代码，由于执行了 `git reset --soft HEAD~1`，导致 HEAD 指向了第二次提交，这就使得最后一次提交（`abc1234`）的内容回到了暂存区。此时，再次此执行 `git commit` 命令，一个新的提交记录就会被创建。

从上面的过程可以看出，`git reset --soft` 是一个安全的操作，不会丢失任何内容。因此，因此可以用来撤销最近的一个或者多个提交，并重新编辑提交信息。

```bash
git reset --soft HEAD~3
git commit -m "合并后的提交信息"
```

上面的代码，撤销了最近的三次提交，并将其合并为一个后再次提交。

重新编辑提交信息时，除了使用 `git reset --soft`，还可以使用 `git commit --amend -m "新的提交信息"` 命令，不过前者更灵活。

另外，单独使用 `git reset --soft HEAD` 命令，还可以用来清空暂存区，然后重新选择要提交的文件。

下面的例子中，工作区有三个文件被修改，执行 `git add .` 将这些更改存放到暂存区。

```bash
git add .
git status
# Changes to be committed:
#   modified: file1.txt
#   modified: file2.txt
#   modified: file3.txt
```

执行完上面的操作后，突然发现 `file3.txt` 这个文件不应该被暂存，于是就可以使用 `git reset --soft HEAD` 命令，暂时清空暂存区，之后再执行 `git add`。

```bash
git reset --soft HEAD
git add file1.txt file2.txt # 只暂存需要的文件
git commit -m "只提交file1和file2"
```

这样，只有 `file1.text` 和 `file2.text` 被暂存了。

##### `--mixed`

`git reset --mixed [commit]` 表示混合重置，该参数的行为如下。

- 移动 HEAD 指向特定的 `[commit]`。
- `[commit]` 之后的提交重新回到工作区（状态为未暂存，unstaged），对应暂存区中的内容被移除。

假设在某一时刻，`main` 分支中存在三个提交，第二个提交对 `file1.text` 进行了修改，最新的提交创建了一个新的文件 `file2.text`。

```bash
# 假设当前状态
git log --oneline
# abc1234 (HEAD) 最新提交
# def5678 第二个提交
# ghi9012 目标提交
```

然后执行 `git reset --mixed` 命令。

```bash
# 执行混合重置
git reset --mixed ghi9012

# 执行后的状态
git log --oneline
# ghi9012 (HEAD) 目标提交 ← HEAD 移动到这里
```

查看当前分支的最新状态。

```bash
git status
# On branch main
# Changes not staged for commit:
#   modified: file1.txt  ← 从暂存区移到工作区
# Untracked files:
#   file2.txt  ← 从暂存区移到工作区
```

上面的代码，由于执行了 `git reset --mixed`，导致 HEAD 指向了目标提交，这使得最近的两次提交（`def5678` 和 `abc1234`）的内容重新回到了工作区。此时，执行 `git add .` 和 `git commit` 命令，一个新的提交记录就会被创建。

从上面的过程可以看出，`git reset --mixed` 是一个安全的操作，不会丢失任何内容。因此，该命令可以用来重新选择要提交的文件。

注意，上面的命令可以简写为 `git reset [commit]`，也就是说，`git reset` 默认就是 mixed 模式。

##### `--hard`

`git reset --hard [commit]` 表示混合重置，该参数的行为如下。

- 移动 HEAD 指向特定的 `[commit]`。
- 工作区中所有未暂存的内容和暂存区中所有未提交的内容都会被删除。

假设在某一时刻，`main` 分支中存在三个提交。

```bash
# 假设当前状态
git log --oneline
# abc1234 (HEAD) 最新提交
# def5678 第二个提交
# ghi9012 目标提交
```

然后执行 `git reset --hard` 命令。

```bash
# 执行硬重置
git reset --hard ghi9012

# 执行后的状态
git log --oneline
# ghi9012 (HEAD) 目标提交 ← HEAD 移动到这里
```

查看当前分支的最新状态。

```bash
git status
# On branch main
# nothing to commit, working tree clean
# 所有更改都丢失了！
```

执行完 `git reset --hard` 命令后，工作区、暂存区和本地仓库中 `ghi9012` 之后的提交都被删除了。

从上面的过程可以看出，`git reset --hard` 是一个危险的操作，除非你知道自己在做什么，否则应该避免使用这个命令。如果不小心使用了该命令，可以通过 `git reflog` 恢复，下面是恢复流程。

第一步，执行 `git reflog` 查看历史记录。

```bash
git reflog
# ghi9012 HEAD@{0}: reset: moving to ghi9012
# abc1234 HEAD@{1}: commit: 最新提交
# def5678 HEAD@{2}: commit: 第二个提交
# ghi9012 HEAD@{3}: commit: 目标提交
```

第二步，找到要恢复的提交。从上面的 reflog 历史记录可以看出，`HEAD@{1}` 指向 `abc1234`，这就是我们想要恢复的状态，`HEAD@{0}` 是当前的硬重置操作。

第三步，再次执行 `git reset --hard` 恢复到之前的状态。

```bash
# 恢复到硬重置之前的状态
git reset --hard HEAD@{1}

# 或者直接使用提交的哈希值
git reset --hard abc1234
```

最后，查看提交历史记录，可以看到已经恢复到了之前的状态。

```bash
# 检查是否恢复成功
git log --oneline
# abc1234 (HEAD) 最新提交
# def5678 第二个提交
# ghi9012 目标提交
```

下面是这三个命令的作用范围。

![--soft、--mixed 和 --hard 参数的作用范围](/2025/assets/git/the-scope-of-git-resets-modes.svg)

##### 与 `git checkout` 的区别

表面上看，`git reset` 和 `git checkout` 命令相似。但他们之间有很大区别，`git checkout` 仅操作 HEAD 指针，而 `git reset` 同时操作 HEAD 和当前分支指针。

比如，在 `main` 分支上有一系列提交，当前，HEAD 和 `main` 指针同时指向提交 `d`。

![HEAD 和 main 指针同时指向提交 d](/2025/assets/git/git-sequence-transparent.png)

执行 `git checkout b`，此时，`main` 依然指向 `d` 提交，而 HEAD 则指向了 `b` 提交，该仓库现在处于 “HEAD 分离”状态。指针指向如下图所示。

![main 依然指向 d 提交，而 HEAD 则指向了 b 提交](/2025/assets/git/git-checkout-transparent.png)

执行 `git reset b`，此时，`main` 和 HEAD 指针同时指向了 `b` 提交。此时的指针指向如下图所示。

![main 和 HEAD 指针同时指向了 b 这个提交](/2025/assets/git/git-reset-transparent.png)

## 特定场景操作

### 撤销提交

git revert

git rebase

git rebase（变基）

交互式 rebase

```bash
git rebase -i HEAD~3
```

这种方式可以删除、编辑、重排 commits，适用于本地未推送的 commits。但是这种方式有风险，需要谨慎操作。

删除特定 commit

```bash
# 在 rebase 交互界面中删除对应行
pick abc1234 commit message 1
drop def5678 commit message 2  # 删除这行
pick ghi9012 commit message 3
```

git cherry-pick（挑选）

反向 cherry-pick

```bash
git revert [commit]
# 然后
git cherry-pick <revert-commit>
```

选择性应用撤销更改，适用于复杂的撤销场景。

git filter-branch（过滤分支）

从历史中完全移除

```bash
git filter-branch --index-filter 'git rm --cached --ignore-unmatch <file>' HEAD
```

这种方式从整个历史中移除文件或 commit，适用于需要彻底清理历史记录。注意，这种操作风险很高，会重写历史，应该谨慎使用。

git rebase --onto（选择性变基）

移除中间 commit

```bash
git rebase --onto <parent-commit> <commit-to-remove> <branch>
```

- 作用：移除指定 commit，保留其他 commits
- 适用：移除中间的 commit

git reset + force push（强制推送）

本地重置后强制推送

```bash
git reset --hard HEAD~1
git push --force-with-lease origin <branch>
```

- 作用：强制更新远程分支
- 风险：高，会覆盖远程历史
- 注意：使用`--force-with-lease`更安全

git commit --amend（修改最近 commit）

修改最近 commit

```bash
git commit --amend -m "new message"
```

- 作用：修改最近 commit 的内容或信息
- 适用：只修改最后一个 commit

git rebase --interactive（交互式变基）

详细操作步骤

```bash
git rebase -i HEAD~5
```

在编辑器中：

- `pick`：保留 commit
- `drop`：删除 commit
- `squash`：合并到前一个 commit
- `edit`：暂停编辑 commit
- `reword`：修改 commit 信息

## 参考

- [Git Tutorials](https://www.atlassian.com/git), atlassian
- [常用 Git 命令清单](https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html), 阮一峰
- [How to use Git Revert](https://stackoverflow.com/questions/19032296/how-to-use-git-revert), stackoverflow
