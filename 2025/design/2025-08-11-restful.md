# RESTful

## 一、介绍

RESTful 是一种软件架构风格，全称为 **Representational State Transfer**（表现层状态转移）。它是由 Roy Fielding 在 2000 年提出的，用于设计网络应用程序的 API。

### 1.1 资源（Resources）

表现层状态转移这个术语中，省略了主语“资源”，即应该将其理解为资源的表现层状态转移。

所谓"资源"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。网络中的每一个资源，都可以通过 URI 来标识，URI 是每一个资源的地址或独一无二的识别符。

所谓"上网"，就是与互联网上一系列的"资源"互动，调用它的URI。

### 1.2 表现层（Representational）

表现层"（Representation）指的是"资源"所表现出来的、外在的表现形式。

比如，文本可以用 txt、HTML、XML 和 JSON 格式表现，甚至还可以采用二进制格式；图片可以用 JPG、PNG 等格式表现。

URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的 `.html` 后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，而 URI 应该只代表"资源"的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 `Accept` 和 `Content-Type` 字段指定，这两个字段才是对"表现层"的描述。

### 1.3 状态转移（State Transfer）

访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。

HTTP 是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转移"（State Transfer）。而这种转移是建立在表现层之上的，所以就是"表现层状态转移"。

要实现表现层状态转移，就要用到 HTTP 方法，具体来说就是 GET、POST、PUT、DELETE 等操作方法，后面会对他们进行介绍。

## 二、REST 架构的限制条件

### 2.1 客户端-服务器分离（Client-Server Separation）

这是最基本的约束，客户端和服务器必须完全分离，各自独立演化。

即客户端不关心数据如何存储，只关心如何获取和操作数据；服务器不关心用户界面，只关心业务逻辑和数据存储。通过 HTTP 协议进行通信，实现松耦合。

这种设计原则的优势是，能够提高系统的可扩展性，允许客户端和服务器独立开发和部署，支持多种客户端（Web、移动端、桌面端）。

### 2.2 无状态性（Stateless）

无状态性（Stateless）指服务器不保存任何客户端的状态信息，每个请求必须包含所有必要的信息。此外，请求具有独立性，不同请求之间没有互相依赖关系，每个请求都可以被服务器单独处理。

好的设计是，在需要身份验证的场景，每次请求都在 `Authorization` 头中携带 token。比如，下面的设计就符合无状态原则，每次请求都包含认证信息。

```bash
GET /profile
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

下面是一个违反这个原则的例子。

```text
第一次请求：POST /login {username: "user", password: "pass"}
服务器：设置会话，返回 sessionId

第二次请求：GET /profile
服务器：根据 sessionId 查找用户信息
```

### 2.3 可缓存性（Cacheable）

可缓存性（Cacheable）指响应必须明确标识是否可以被缓存，以及缓存的有效期。

比如，HTTP 协议中，使用 `Expire`、`Cache-Control`、`Last-Modified` 和 `ETag` 等头字段控制缓存策略。

### 2.4 统一接口（Uniform Interface）

统一接口（Uniform Interface）是 REST 架构的核心约束，定义了客户端和服务器之间的标准通信方式。

#### （1）资源识别（Resource Identification）

每个资源都有唯一的 URI 标识符。

```bash
# 资源层次结构
/api/v1/users # 用户集合
/api/v1/users/123 # 特定用户
/api/v1/users/123/posts # 用户的文章集合
/api/v1/users/123/posts/456 # 用户的特定文章
/api/v1/users/123/posts/456/comments # 文章的评论集合

# 查询参数设计
/api/v1/users?page=1&limit=10&sort=name&order=asc
/api/v1/users?status=active&role=admin&created_after=2024-01-01

# 过滤和搜索
/api/v1/users?search=john&filter[age][gte]=18&filter[age][lte]=65
/api/v1/users?include=posts,comments&fields=id,name,email
```

#### （2）通过表述操作资源（Manipulation of Resources Through Representations）

客户端通过资源的表述来操作资源，而不是直接操作资源本身。

客户端发送资源的表述（如 JSON 数据），服务器根据表述来更新资源，支持多种数据格式（JSON、XML、HTML、纯文本）。

比如，HTTP 请求中，客户端通过 `Accept` 请求头指定接受数据的格式，服务器通过 `` 响应头描述返回内容的格式。

```http
# 客户端请求特定格式
Accept: application/json
Accept: application/xml
Accept: text/html
Accept: */*

# 服务器响应相应格式
Content-Type: application/json
Content-Type: application/xml
Content-Type: text/html
```

#### （3）自描述消息（Self-Descriptive Messages）

每个消息都包含足够的信息来处理请求，无需额外的外部信息。

比如，HTTP 请求中，请求由三部分构成：请求行、请求头和请求体。请求行中又包括请求方法、请求路径以及 HTTP 版本信息。在服务器返回的响应中，响应数据也包含三部分：相应行、响应头和响应体，响应行中又包含状态码、状态信息和 HTTP 版本信息。

```http
# 请求消息自描述
POST /api/v1/users HTTP/1.1
Host: api.example.com
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Length: 89

{
  "name": "张三",
  "email": "zhangsan@example.com",
  "age": 25
}

# 响应消息自描述
HTTP/1.1 201 Created
Content-Type: application/json
Location: /api/v1/users/123
ETag: "abc123"
Cache-Control: no-cache

{
  "id": 123,
  "name": "张三",
  "email": "zhangsan@example.com",
  "age": 25,
  "created_at": "2024-01-15T10:30:00Z"
}
```

#### （4）超媒体驱动（Hypermedia Driven）

通过链接来导航和发现资源，实现 API 的自发现。通过在响应中包含所需的链接，是用户不用查询相关文档，即可使用相应的 API。

### 2.5 分层系统（Layered System）

客户端不能直接连接到最终服务器，必须通过中间层。

客服端到服务器之间，还可以包含多个其他角色。比如，负载均衡服务器可以分发请求到多个服务器，反向代理能够处理 SSL、缓存、压缩，还可以设置监控层，实现系统监控和日志记录。

### 2.6 按需代码（Code on Demand，可选）

服务器可以向客户端传输可执行代码，客户端执行这些代码。

## 三、HTTP 方法

上面说过，实现资源的状态转移，要通过 HTTP 方法来实现，下秒介绍这些方法的使用方式。

### 3.1 GET

`GET` 方法用来获取资源，不改变资源状态。`GET` 方法是**幂等**的，这意味着多次相同的请求，会得到相同的结果。GET 方法是安全的，一般不会改变资源的状态。

下面是一个获取用户列表的请求。

```http
GET /api/v1/users HTTP/1.1
Host: api.example.com
Accept: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

服务器返回的数据，可能是这样的。

```http
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: public, max-age=300
X-Total-Count: 1000
X-Page-Count: 100

{
  "data": [
    {
      "id": 1,
      "name": "张三",
      "email": "zhangsan@example.com"
    }
  ],
  "pagination": {
    "page": 1,
    "limit": 10,
    "total": 1000,
    "total_pages": 100
  },
  "_links": {
    "next": "/api/v1/users?page=2&limit=10",
    "last": "/api/v1/users?page=100&limit=10"
  }
}
```

下面是 GET 请求携带参数的例子。

```http
# 分页
GET /api/v1/users?page=1&limit=20

# 搜索
GET /api/v1/users?search=john

# 排序
GET /api/v1/users?sort=name&order=asc

# 过滤
GET /api/v1/users?status=active&role=admin

# 字段选择
GET /api/v1/users?fields=id,name,email

# 关联数据
GET /api/v1/users?include=posts,comments
```

### 3.2 POST

`POST` 方法用于创建新资源。`POST` 方法是**非幂等**的，这意味着多次相同的 POST 请求，可能会创建多个资源。POST 方法是不安全的，会改变资源的状态。

下面是一个使用 `POST` 方法创建用户的例子。

```http
POST /api/v1/users HTTP/1.1
Host: api.example.com
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Length: 89

{
  "name": "李四",
  "email": "lisi@example.com",
  "age": 30,
  "role": "user"
}
```

服务器返回的响应可能是这样的。

```http
HTTP/1.1 201 Created
Content-Type: application/json
Location: /api/v1/users/124
ETag: "def456"

{
  "id": 124,
  "name": "李四",
  "email": "lisi@example.com",
  "age": 30,
  "role": "user",
  "created_at": "2024-01-15T11:00:00Z",
  "_links": {
    "self": {
      "href": "/api/v1/users/124",
      "method": "GET"
    }
  }
}
```

下面的例子展示了如何使用 POST 请求批量创建用户。

```http
POST /api/v1/users/batch HTTP/1.1
Content-Type: application/json

{
  "users": [
    {
      "name": "王五",
      "email": "wangwu@example.com"
    },
    {
      "name": "赵六",
      "email": "zhaoliu@example.com"
    }
  ]
}
```

### 3.3 PUT

`PUT` 方法一般用于完整更新资源（替换整个资源），`PUT` 方法是幂等的，多次相同的请求会得到相同的结果。PUT 方法是安全的，一般不会改变资源的状态。

下面是一个使用 PUT 请求更新用户的例子。

```http
PUT /api/v1/users/124 HTTP/1.1
Host: api.example.com
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
If-Match: "def456"

{
  "name": "李四",
  "email": "lisi@example.com",
  "age": 31,
  "role": "admin",
  "phone": "13800138000",
  "address": "北京市朝阳区"
}
```

服务器返回的响应可能是这样的。

```http
HTTP/1.1 200 OK
Content-Type: application/json
ETag: "ghi789"

{
  "id": 124,
  "name": "李四",
  "email": "lisi@example.com",
  "age": 31,
  "role": "admin",
  "phone": "13800138000",
  "address": "北京市朝阳区",
  "updated_at": "2024-01-15T11:30:00Z"
}
```

### 3.4 DELETE

`DELETE` 方法用于删除资源，DELETE 操作是幂等的，多次执行相同的请求会得到相同的结果。DELETE 操作是不安全的，资源的状态会被改变。

下面是一个 DELETE 请求删除用户的例子。

```http
# 删除用户
DELETE /api/v1/users/124 HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
If-Match: "jkl012"
```

服务器返回的响应可能是这样的。

```http
HTTP/1.1 204 No Content
```

注意，对资源的删除，分为软删除和硬删除，对于重要的数据，应该尽量使用软删除，避免造成数据的丢失。

下面是使用 DELETE 方法，进行软删除的例子。

```http
# 软删除（推荐）
DELETE /api/v1/users/124 HTTP/1.1

# 响应
HTTP/1.1 200 OK
Content-Type: application/json

{
  "message": "用户已删除",
  "deleted_at": "2024-01-15T12:30:00Z"
}
```

下面是一个硬删除的例子。

```http
# 硬删除（物理删除）
DELETE /api/v1/users/124?hard=true HTTP/1.1

# 响应
HTTP/1.1 204 No Content
```

### 3.5 PATCH

`PATCH` 方法用于部分更新资源。PATCH 方法是非幂等的，多次相同的请求，可能会产生不同的结果。这意味着 PATCH 方法也是不安全的，资源的状态会被改变。

下面是一个 PATCH 请求更新部分用户的例子。

```http
PATCH /api/v1/users/124 HTTP/1.1
Host: api.example.com
Content-Type: application/json-patch+json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
If-Match: "ghi789"

[
  {
    "op": "replace",
    "path": "/age",
    "value": 32
  },
  {
    "op": "add",
    "path": "/skills",
    "value": ["JavaScript", "Python"]
  },
  {
    "op": "remove",
    "path": "/phone"
  }
]
```

服务器返回的响应可能是这样的。

```http
HTTP/1.1 200 OK
Content-Type: application/json
ETag: "jkl012"

{
  "id": 124,
  "name": "李四",
  "email": "lisi@example.com",
  "age": 32,
  "role": "admin",
  "address": "北京市朝阳区",
  "skills": ["JavaScript", "Python"],
  "updated_at": "2024-01-15T12:00:00Z"
}
```

## 四、RESTful API 设计规范

### 4.1 版本控制策略

对于版本的控制，按照版本信息所处的位置，可以分为三种策略。

- URL 路径中指定版本：这种方式最直观，缺点是 URL 会变得较长。
- URL 查询参数中指定版本：简洁，但版本信息会出现在查询参数中，可能影响缓存效果。
- 通过 `Accept` 头字段指定版本：优点是简洁，不会污染 URL 结构，缺点是需要在每个请求中指定版本。

```http
# 路径中指定
/api/v1/users
/api/v2/users

# 查询参数指定
/api/users?version=1

# 头字段指定
Accept: application/vnd.company.app-v1+json
```

### 4.2 URI 设计原则

#### （1）路径使用名词、复数

URI 中的路径（Endpoint）应该使用名词的复数形式，而非动词和单数形式。

应该使用下面这种方式。

```bash
GET /users
POST /users
PUT /users/{id}
DELETE /users/{id}
```

而不是下面的方式。

```bash
GET /getUsers
POST /createUser
PUT /updateUser
DELETE /deleteUser
```

#### （2）嵌套结构

URI 应该使用嵌套结构表示资源关系，但也应该避免过度嵌套。

```bash
/users/{id}/posts # 获取特定用户的文章
/users/{id}/posts/{postId} # 获取特定用户的特定文章
/users/{id}/posts/{postId}/comments # 获取特定文章的评论
```

#### （3）查询参数

使用**过滤参数**从资源集合中选择特定的子集。

```http
GET /users?role=admin # 获取管理员用户
GET /users?status=active # 获取活跃用户
```

使用**排序参数**控制资源返回的顺序，通常使用 `sort` 参数，多个排序条件用逗号分隔。

```http
GET /users?sort=name # 按姓名升序排列
GET /users?sort=name,-age # 先按姓名升序，再按年龄降序
GET /users?sort=-createdAt # 按创建时间降序排列（负号表示降序）
```

使用**分页参数**控制返回结果的数量和偏移量，常用的参数包括 `page`、`limit`、`offset` 等。

```http
GET /users?page=1&limit=10 # 第1页，每页10条记录
GET /users?offset=20&limit=10  # 从第20条开始，返回10条记录
GET /users?cursor=abc123&limit=10  # 基于游标的分页
```

除了上面这些，还应考虑到 URL 不宜过长，敏感数据也不应该放在 URL 中。

### 4.3 状态码使用规范

状态码（Status Codes）用于对请求的操作结果进行描述。

HTTP 协议中，状态码分为五大类，分别以 `1xx`、`2xx`、`3xx`、`4xx` 和 `5xx` 表示，下面分别对 HTTP 请求中常见的状态码进行介绍。

#### （1）1xx

以 `1xx` 表示的状态码，一般跟请求和响应数据有关。

- `100 Continue`：有时，为了让服务器检查请求首部中的某些字符是否符合要求，客户端会发送一个请求，在请求头中有个 `Expect: 100-continue` 字段，表示期望收到服务器返回的 `100 Continue` 状态码。如果服务器通过检索发现，请求头中的相关字符，满足服务器的要求，就会返回一个 `100 Continue` 状态码，表示客户端可以继续后续的请求；如果请求头中相关字段不满足服务器的要求，就会返回 `417 Expectation Failed` 状态码，表示相关字段不符合要求。

#### （2）2xx

以 `2xx` 表示的状态码，一般表示请求成功。

- `200 OK`：表示请求成功。因请求方法的不同，这个状态码所表示的具体含义也有差别。
  - 对于 `HEAD` 请求，表示客户端请求的信息处理成功，此时一般没有响应体。
  - 对于 `GET` 请求，表示客户端请求的资源已经找到，并即将通过响应体返回给客户端。
  - 对于 `POST` 请求，表示客户端请求的资源已创建成功，跟这个（些）资源有关的信息，已通过响应体返回。
  - 对于 `PUT` 或者 `DELETE` 请求，一般不响应此状体码，而是分别通过 `201 Created`（资源创建成功） 和 `204 No Content`（没有相关内容）指定。
- `201 Created`：表示资源创建成功，且新增的资源已通过响应体返回。资源的地址，在响应体中返回，或者通过响应头中的 `Location` 字段指定。此状态码一般用于 POST 请求成功时。
- `202 Accepted`：表示客户端发送的请求，服务器已成功接受，但可能还没来得及处理或者还没开始处理。至于操作的结果，服务器并不保证一定成功，并且待到服务器处理完成后，也不会通过异步的响应告诉服务器。该状态码一般用于批处理操作。
- `204 No Content`：表示请求成功，但响应中没有返回任何内容。该状态码一般出现在 `PUT` 或者 `DELETE` 请求中。`204` 对于 `PUT` 请求通常是可缓存的，此时响应头中会设置 `ETag` 字段。比如，客户端通过 `DELETE` 请求删除某个资源，服务器操作完成后，不需要返回任何数据。
- `206 Partial Content`：表示请求成功，所请求的资源的部分内容已在响应中返回。通常该响应返回的数据区间，是通过请求头中的 `Range` 字段指定的，

  该状态码一般出现在文件的断点续传场景。与该状态码有关的字段还包括 `Range`（客户端请求的数据范围，以字节表示）、`Content-Range`（服务器返回的数据返回） 和 `Content-Type`（返回的数据的类型）。

  ```http
  HTTP/1.1 206 Partial Content
  Date: Wed, 15 Nov 2015 06:25:24 GMT
  Last-Modified: Wed, 15 Nov 2015 04:58:08 GMT
  Content-Range: bytes 21010-47021/47022
  Content-Length: 26012
  Content-Type: image/gif

  ... 26012 bytes of partial image data ...
  ```
  
  如果返回的响应中，只包含一个数据区间，那么响应头中的 `Content-Type` 字段的值为文件的类型；如果响应中包含多个数据区间，则整个响应头中 `Content-Type` 的值为 `multipart/byteranges`，每个数据片段会另外携带 `Content-Type` 和 `Content-Range` 字段，知名当前片段的数据类型和范围。

  ```http
  HTTP/1.1 206 Partial Content
  Date: Wed, 15 Nov 2015 06:25:24 GMT
  Last-Modified: Wed, 15 Nov 2015 04:58:08 GMT
  Content-Length: 1741
  Content-Type: multipart/byteranges; boundary=String_separator

  --String_separator
  Content-Type: application/pdf
  Content-Range: bytes 234-639/8000

  ...the first range...
  --String_separator
  Content-Type: application/pdf
  Content-Range: bytes 4590-7999/8000

  ...the second range
  --String_separator--
  ```

#### （3）3xx

以 `3xx` 表示的状态码，表示与资源的重定向有关。

- `301 Moved Permanently`：表示所请求的资源已被永久移动 `Location` 响应头字段所指向的新地址。浏览器在收到响应后，对 `Location` 指向的地址发送重定向请求，请求方法被修改为 `GET`，这意味着，如果之前的请求方法为非 `GET` 请求，那么请求方法会发生改变。也正是由于这个原因，`301` 状态码最好只用于 `GET` 和 `HEAD` 请求。
- `302 Found`：表示请求的资源被暂时移动到 `Location` 响应头字段所指向的新地址。浏览器在收到响应后，对 `Location` 指向的地址发送重定向请求，请求方法被修改为 `GET`。由于只是临时重定向，浏览器会缓存重定向结果，搜索引擎也不会更改索引。
- `303 See Other`：临时重定向，表示资源地址被移动到了 `Location` 指向的地址。通常作为 `PUT` 或 `POST` 请求的结果状态码，`303` 明确要求在发送重定向请求时，要使用 `GET` 方法。
- `304 Not Modified`：表示服务器内容没有发生更改，可以使用客户端缓存的资源。一般出现在协商请求的响应中。注意，该响应不包含响应体。
- `307 Temporary Redirect`：含义跟 `302` 一致，区别是在进行重定向请求时，请求方法和请求体保持不变。不管是 `302` 还是 `307`，客户端之后的请求，应然应该使用原始 URL。
- `308 Permanent Redirect`：含义跟 `301` 一致，区别是在进行重定向请求时，请求方法和请求体保持不变。

#### （4）4xx

以 `4xx` 表示的状态码，表示客户端错误。

- `400 Bad Request`：坏的请求，一般是因为客户端语法、格式等不正确。
- `401 Unauthorized`：未授权，表示客户端在请求时应该携带用户身份信息，但却没有这么做。此时，响应头中一般会包含 `WWW-Authenticate` 字段，表示服务器使用什么方法进行身份验证，客户端应该按照要求，使用合适的方式发送用户身份信息。

  ```http
  HTTP/1.1 401 Unauthorized
  Date: Wed, 21 Oct 2015 07:28:00 GMT
  WWW-Authenticate: Basic realm="Access to staging site"
  ```

- `403 Forbidden`：表示该用户没有权限访问该资源。
- `404 Not Found`：所请求的资源无法找到。该状态码只是单纯地说明资源没有找到，并没有说明资源时临时丢失还是永久丢失，如果资源是永久丢失，应该使用 `410 Gone`。
- `405 Method Not Allowed`：请求方法不被允许，一般是因为使用了不正确的请求方法。
- `408 Request Timeout`：请求超时。服务器等待客户端发送请求的时间过长，导致服务器决定关闭连接。注意，有些服务器会在连接空闲时发送此信息，即便客户端没有发送任何请求。
- `410 Gone`：请求的资源在服务器上永久丢失。
- `429 Too Many Requests`：表示在一段时间内，客户端发出了太多请求。

#### （5）5xx

以 `5xx` 表示的状态码，表示服务器端的错误。

- `500 Internal Server Error`：服务器内部发生错误。可以认为是服务端抛出的一个万能的状态码，如果不确定服务器应该使用哪个状态码，就可以返回 `500`。
- `501 Not Implemented`：服务器不支持当前的请求方法或者当前 API 还未实现。此时，客户端可以尝试使用 `GET` 或者 `HEAD` 方法重试。
- `503 Service Unavailable`：服务器暂时不可用。一般是因为服务器处于维护状态。更好的做法是，在返回 `503` 状态码的同时，响应体中给出具体的出错原因，并在头字段中通过 `Retry-After` 字段，告诉客户端多久之后可以尝试重新请求。

  ```http
  503 Service Unavailable HTTP/1.1
  Retry-After: Wed, 21 Oct 2015 07:28:00 GMT
  Retry-After: 120
  ```

  上面代码表示，服务器当前不可用，客户端可以在 10/21/2015 日 7 点 28 分后或者 120s 后重新发送请求。

## 参考

- [HTTP 响应状态码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Status)，MDN
- [理解 RESTful 架构](https://www.ruanyifeng.com/blog/2011/09/restful.html)，阮一峰
- [RESTful API 设计指南](https://www.ruanyifeng.com/blog/2014/05/restful_api.html)，阮一峰
