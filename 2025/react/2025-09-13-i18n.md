# 前端国际化

## 介绍

国际化（Internationalization，简称 i18n）指设计和开发软件应用程序时，对不同语言、地区和文化的进行适配的过程。国际化的目的，是为应用程序提供多语言支持。

## 原生实现

## i18next

在 React 中，使用 [i18next] 提供的一系列工具，可以快速实现前端国际化。

### 依赖包

首先，需要安装下面列出的依赖包。

- [i18next] 必需，国际化的核心库，提供翻译引擎。该依赖提供了比如插值处理、命名空间管理、`t()` 和 `changeLanguage()` 等核心方法。
- [react-i18next] 必需，React 的 i18next 集成库，提供 React 组件中使用的 Hook 和 HOC，比如 `useTranslation` 和 `withTranslation` 等。
- [i18next-http-backend] 推荐，HTTP 后端加载器，可以从服务器动态加载翻译文件。
- [i18next-browser-languagedetector] 推荐，浏览器语言检测器，能够自动检测用户浏览器语言。
- [i18next-localstorage-backend] 可选，本地存储后端，将翻译文件缓存到 `localStorage`。能够实现离线翻译支持、减少网络请求等功能。
- [i18next-scanner] 可选，代码扫描工具，自动提取代码中的硬编码文本并生成翻译文件。
- [i18next-parser] 可选，翻译文件处理工具，用于解析、转换和验证翻译文件。

除了上面列出的这些，i18next 还提供了很多[其他依赖包][other-repositories]，可以根据自己的需求进行安装。

执行下面的安装命令，添加依赖。

```bash
# 使用 npm
npm install react-i18next i18next i18next-browser-languagedetector i18next-http-backend

# 或者使用 yarn
yarn add react-i18next i18next i18next-browser-languagedetector i18next-http-backend
```

### 创建语料文件

语料文件（Translation Files）是存储多语言翻译内容的文件，通常以 JSON、YAML 等格式存储。语料文件通常以键值对的形式进行存储，键是要翻译的内容的标识，值是对应的翻译后的内容。

下面是一个英语版本（`en-US.json`）的语料文件示例。

```json
{
  "common": {
    "loading": "Loading...",
    "error": "Error",
    "success": "Success"
  },
  "user": {
    "welcome": "Welcome, {{name}}!",
    "profile": "Profile"
  }
}
```

创建语料文件时，应该尽量遵循下面的原则。

- 尽量使用扁平化结构，避免过深的嵌套。
- 语义化命名，避免无意义命名。
- 保持所有语言文件结构一致。
- 对于关键的键值对，提供上下文信息。
- 文化适配。

```json
// 上下文信息提供
{
  "button_save": {
    "value": "Save",
    "context": "Save button in user profile form",
    "usage": "Used when user clicks to save profile changes"
  }
}

// 美国格式
{
  "date_format": "MM/DD/YYYY",
  "currency": "$1,234.56"
}

// 中国格式
{
  "date_format": "YYYY年MM月DD日",
  "currency": "¥1,234.56"
}
```

如果站点面向的是指定国家（地区）的用户，只需创建对应国家（地区）的语料文件即可；如果面向全球用户，可以考虑创建以下国家（地区）的语料文件。

- 英语（`en-US`），国际通用语言。
- 中文简体（`zh-CN`），中国大陆市场。
- 中文繁体（`zh-TW`），台湾、香港、澳门。
- 西班牙语（`es-ES`），全球第二大语言。
- 法语（`fr-FR`），欧洲重要语言。
- 德语（`de-DE`），欧洲经济强国。
- 日语（`ja-JP`），亚洲重要市场。
- 韩语（`ko-KR`），亚洲重要市场。
- 葡萄牙语（`pt-BR`），巴西市场。
- 俄语（`ru-RU`），东欧市场。
- 阿拉伯语（`ar-SA`），中东市场。
- 印地语（`hi-IN`），印度市场。
- 意大利语（`it-IT`），欧洲市场。
- 荷兰语（`nl-NL`），欧洲市场。
- 瑞典语（`sv-SE`），北欧市场。

i18next 提供了 [i18next-scanner] 和 [i18next-parser] 等工具，用于自动提取翻译键以及生成翻译文件模板，也可以使用 [Crowdin]、[Lokalise] 和 [Transifex] 之类的平台提供的付费服务。

### 基本配置

首先在入口文件中，执行 i18next 初始化操作。

```javascript
// src/index.js
import '@i18n';
```

设置 i18next 的配置文件。

```javascript
// @i18n/config/index.j
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import LanguageDetector from 'i18next-browser-languagedetector';
import Backend from 'i18next-http-backend';

const initI18n = () => {
  i18n
    .use(Backend)
    .use(LanguageDetector)
    .use(initReactI18next)
    .init({
      // 基础配置
      lng: 'zh-CN', // 默认语言
      fallbackLng: 'en-US', // 回退语言
      supportedLngs: ['zh-CN', 'en-US', 'ja-JP'], // 支持的语言
      
      // 命名空间配置
      ns: ['common', 'user', 'product'],
      defaultNS: 'common',
      
      // 后端配置
      backend: {
        loadPath: '/locales/{{lng}}/{{ns}}.json',
        addPath: '/locales/add/{{lng}}/{{ns}}',
      },
      
      // 语言检测配置
      detection: {
        order: ['localStorage', 'navigator', 'htmlTag'],
        caches: ['localStorage'],
        lookupLocalStorage: 'i18nextLng',
      },
      
      // 插值配置
      interpolation: {
        escapeValue: false, // React 已经处理了 XSS
      },
      
      // React 配置
      react: {
        useSuspense: false, // 禁用 Suspense
      },
      
      // 开发环境配置
      debug: process.env.NODE_ENV === 'development',
      saveMissing: process.env.NODE_ENV === 'development',
      missingKeyHandler: (lng, ns, key) => {
        if (process.env.NODE_ENV === 'development') {
          console.warn(`Missing translation: ${lng}.${ns}.${key}`);
        }
      },
    });

  return i18n;
};

export default initI18n();
```

- `lng` 类型为 `<string>`，指定要使用的语言代码，如果使用了语言检测器插件，可忽略此选项。
- `fallbackLng` 类型为 `<string | string[] | object | function>`，指定当用户语言不可用时使用的回退语言。
- `supportedLngs` 类型为 `<string[] | false>`，支持的语言列表。
- `nonExplicitSupportedLngs` 类型为 `<boolean>`，如果为 `true`，当在 `supportedLngs` 中找到 `'en'` 时，会传递 `'en-US'`，默认为 `false`。
- `load` 类型为 `<'all' | 'currentOnly' | 'languageOnly'>`，语言代码查找方式。默认值为 `'all'`。
- `preload` 类型为 `<string[] | false>`，预加载的语言数组，在服务端渲染时很重要。
- `lowerCaseLng` 类型为 `<boolean>`，将语言代码转换为小写
- `cleanCode` 类型为 `<boolean>`，将语言代码转换为小写但保留完整区域设置，比如，`'EN'` 会被转为 `'en'`，但 `'en-US'` 保持不变。
- `ns` 类型为 `<string | string[]>`，要加载的命名空间，默认值为 `['translation']`。
- `defaultNS` 类型为 `<string | false | string[]>`，翻译函数的默认命名空间，默认值为 `['translation']`。
- `fallbackNS` 类型为 `<string | string[] | false>`，当在给定命名空间中找不到键时，要查找的命名空间，默认值为 `false`。
- `resources` 类型为 `<object>`，初始化时使用的语料资源
- `keySeparator` 类型为 `<string | false>`，键分隔符，默认值为 `'.'`
- `nsSeparator` 类型为 `<string | false>`，命名空间分隔符，默认值为 `':'`。
- `contextSeparator` 类型为 `<string>`，上下文分隔符，默认值为 `'_'`。
- `debug` 类型为 `<boolean>`，在控制台输出信息级别日志，帮助查找加载问题。默认值为 `false`。
- `saveMissing` 类型为 `<boolean>`，启用保存缺失键到后端。默认值为 `false`。
- `missingKeyHandler` 类型为 `<function | false>`，自定义缺失键处理函数。
- `interpolation` 类型为 `<object>`，插值选项。
- `react` 类型为 `<object>`，React 插件选项。
- `detection` 类型为 `<object>`，语言检测插件选项。
- `backend` 类型为 `object`，后端插件选项。
- `cache` 类型为 `object`，缓存层插件选项。

以上只是列出了部分配置项，更多信息请参考[配置信息][configuration-options]。

### 创建工具函数、Hooks

项目中，大部分内容都可以使用 i18next 直接转换。但是，有些动态内容，特别是从服务器获取的动态内容，以及跟地区有关的内容，需要使用工具函数进行动态处理。比如，日期类型在显示时，中国地区格式一般为"年/月/日"，而美欧地区一般为"月/日/年"。

```javascript
// src/i18n/utils/index.js
import i18n from '../config';

// 数字格式化
export const formatNumber = (number, options = {}) => {
  const locale = i18n.language;
  return new Intl.NumberFormat(locale, options).format(number);
};

// 货币格式化
export const formatCurrency = (amount, currency = 'CNY') => {
  const locale = i18n.language;
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
  }).format(amount);
};

// 日期格式化
export const formatDate = (date, options = {}) => {
  const locale = i18n.language;
  const defaultOptions = {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  };
  return new Intl.DateTimeFormat(locale, { ...defaultOptions, ...options }).format(date);
};

// 相对时间格式化
export const formatRelativeTime = (value, unit, options = {}) => {
  const locale = i18n.language;
  return new Intl.RelativeTimeFormat(locale, options).format(value, unit);
};

// 文件大小格式化
export const formatFileSize = (bytes) => {
  const locale = i18n.language;
  const units = ['B', 'KB', 'MB', 'GB', 'TB'];
  let size = bytes;
  let unitIndex = 0;
  
  while (size >= 1024 && unitIndex < units.length - 1) {
    size /= 1024;
    unitIndex++;
  }
  
  return `${formatNumber(size, { maximumFractionDigits: 2 })} ${units[unitIndex]}`;
};

// 百分比格式化
export const formatPercentage = (value, options = {}) => {
  const locale = i18n.language;
  return new Intl.NumberFormat(locale, {
    style: 'percent',
    ...options,
  }).format(value);
};

// 检查翻译是否存在
export const hasTranslation = (key, options = {}) => {
  const { ns = 'common' } = options;
  const translation = i18n.getResource(i18n.language, ns, key);
  return translation !== undefined && translation !== key;
};

// 获取翻译键
export const getTranslationKey = (value, namespace = 'common') => {
  const resources = i18n.getResourceBundle(i18n.language, namespace);
  for (const [key, translation] of Object.entries(resources)) {
    if (translation === value) {
      return key;
    }
  }
  return null;
};

// 检查是否为从右到左语言
export const isRTL = (language = i18n.language) => {
  const rtlLanguages = ['ar', 'he', 'fa', 'ur'];
  return rtlLanguages.some(lang => language.startsWith(lang));
};

// 获取文本方向
export const getTextDirection = (language = i18n.language) => {
  return isRTL(language) ? 'rtl' : 'ltr';
};

// 获取复数形式
export const getPluralForm = (count, language = i18n.language) => {
  const rules = new Intl.PluralRules(language);
  return rules.select(count);
};
```

```javascript
// src/i18n/hooks/useI18n.js
import { useTranslation } from 'react-i18next';
import { useState, useEffect, useCallback } from 'react';

// 支持的语言配置
const SUPPORTED_LANGUAGES = {
  'zh-CN': '简体中文',
  'en-US': 'English',
  'ja-JP': '日本語',
};

// 检查语言是否支持
const isLanguageSupported = (language) => {
  return Object.keys(SUPPORTED_LANGUAGES).includes(language);
};

// 获取当前语言
const getCurrentLanguage = () => {
  return localStorage.getItem('i18nextLng') || 'zh-CN';
};

// 切换语言
const changeLanguage = async (language) => {
  try {
    const i18n = (await import('../config')).default;
    await i18n.changeLanguage(language);
    return true;
  } catch (error) {
    console.error('Failed to change language:', error);
    return false;
  }
};

// 增强的国际化 Hook，提供语言切换、格式化等功能
export const useI18n = (namespace = 'common') => {
  const { t, i18n, ready } = useTranslation(namespace);
  const [currentLang, setCurrentLang] = useState(getCurrentLanguage());

  // 监听语言变化
  useEffect(() => {
    const handleLanguageChange = (lng) => {
      setCurrentLang(lng);
    };

    i18n.on('languageChanged', handleLanguageChange);

    return () => {
      i18n.off('languageChanged', handleLanguageChange);
    };
  }, [i18n]);

  // 切换语言
  const switchLanguage = useCallback(async (language) => {
    if (!isLanguageSupported(language)) {
      console.warn(`Unsupported language: ${language}`);
      return false;
    }

    if (language === currentLang) {
      return true;
    }

    const success = await changeLanguage(language);

    return success;
  }, [currentLang]);

  // 获取支持的语言列表
  const getSupportedLanguages = useCallback(() => Object.keys(SUPPORTED_LANGUAGES).map((code) => ({
    code,
    name: SUPPORTED_LANGUAGES[code],
    isActive: code === currentLang,
  })), [currentLang]);

  // 检查是否为当前语言
  const isCurrentLanguage = useCallback((language) => language === currentLang, [currentLang]);

  // 获取语言显示名称
  const getLanguageName = useCallback((language) => SUPPORTED_LANGUAGES[language] || language, []);

  return {
    // 基础翻译功能
    t,
    ready,

    // 语言相关
    currentLanguage: currentLang,
    switchLanguage,
    getSupportedLanguages,
    isCurrentLanguage,
    getLanguageName

    // i18n实例
    i18n,
  };
};
```

### 封装语言切换组件

在语言切换组件中，当用户点击不同的语言选项时，执行语言切换逻辑。

```jsx
// src/components/common/LanguageSwitcher.jsx
import React from 'react';
import { useI18n } from '@i18n';

const LanguageSwitcher = () => {
  const {
    switchLanguage,
    getSupportedLanguages
  } = useI18n();

  const supportedLanguages = getSupportedLanguages();

  const handleLanguageChange = async (languageCode) => {
    await switchLanguage(languageCode);
  };

  return (
    <div>
      {supportedLanguages.map(({ code }) => (
        <button onClick={() => handleLanguageChange(code)}></button>
      ))}
    </div>
  );
};

export default LanguageSwitcher;
```

### 在业务组件中使用

```jsx
import React from 'react';
import { useTranslation } from 'react-i18next';

const MyComponent = () => {
  const { t } = useTranslation('common');
  
  return (
    <div>
      <h1>{t('app.title')}</h1>
      <p>{t('app.description')}</p>
      
      {/* 带插值的翻译 */}
      <p>{t('user.welcome', { name: '张三' })}</p>
      
      {/* 复数形式 */}
      <p>{t('items', { count: 5 })}</p>
    </div>
  );
};

export default MyComponent;
```

### 高级功能实现

#### 命名空间管理

命名空间（Namespace）是 i18next 中用于组织翻译内容的重要概念。通过命名空间，可以将不同模块的翻译内容进行分离管理。

```javascript
// 按功能模块划分命名空间
// common.json - 通用翻译
{
  "loading": "加载中...",
  "error": "错误",
  "success": "成功"
}

// user.json - 用户相关翻译
{
  "profile": "个人资料",
  "settings": "设置",
  "logout": "退出登录"
}

// product.json - 产品相关翻译
{
  "title": "产品标题",
  "description": "产品描述",
  "price": "价格"
}

// 在组件中使用特定命名空间
const UserProfile = () => {
  const { t } = useTranslation('user');
  return (
    <div>
      <h1>{t('profile')}</h1>
      <button>{t('settings')}</button>
    </div>
  );
};

// 使用多个命名空间
const ProductCard = () => {
  const { t: tCommon } = useTranslation('common');
  const { t: tProduct } = useTranslation('product');
  
  return (
    <div>
      <h2>{tProduct('title')}</h2>
      <p>{tProduct('description')}</p>
      <span>{tCommon('loading')}</span>
    </div>
  );
};
```

#### 动态加载翻译文件

```javascript
// 在 i18n 配置中启用动态加载
const i18nConfig = {
  backend: {
    loadPath: '/locales/{{lng}}/{{ns}}.json',
    addPath: '/locales/add/{{lng}}/{{ns}}',
    // 自定义请求头
    customHeaders: {
      'Cache-Control': 'no-cache',
    },
    // 请求超时
    requestOptions: {
      cache: 'no-cache',
    },
  },
  saveMissing: process.env.NODE_ENV === 'development',
  missingKeyHandler: (lng, ns, key) => {
    if (process.env.NODE_ENV === 'development') {
      console.warn(`Missing translation: ${lng}.${ns}.${key}`);
      // 可以发送到服务器进行收集
      // sendMissingKeyToServer(lng, ns, key);
    }
  },
  // 启用命名空间懒加载
  load: 'languageOnly',
  // 预加载关键命名空间
  preload: ['common'],
};
```

#### 复数处理

```javascript
// 在翻译文件中使用复数
// en-US.json
{
  "items": {
    "zero": "No items",
    "one": "{{count}} item",
    "other": "{{count}} items"
  }
}

// zh-CN.json
{
  "items": "{{count}}个项目"
}

// 在组件中使用
const ItemCount = ({ count }) => {
  const { t } = useTranslation('common');
  return <span>{t('items', { count })}</span>;
};

// 复杂复数规则示例
// en-US.json
{
  "messages": {
    "zero": "No messages",
    "one": "{{count}} message",
    "other": "{{count}} messages"
  }
}
```

#### 插值处理

插值（Interpolation）是 i18next 中用于在翻译文本中插入动态值的功能。

```javascript
// 基础插值
// zh-CN.json
{
  "welcome": "欢迎 {{name}}，您有 {{count}} 条新消息",
  "greeting": "你好，{{name}}！今天是 {{date}}"
}

// en-US.json
{
  "welcome": "Welcome {{name}}, you have {{count}} new messages",
  "greeting": "Hello {{name}}! Today is {{date}}"
}

// 组件中使用
const WelcomeMessage = ({ name, messageCount }) => {
  const { t } = useTranslation('common');
  return <p>{t('welcome', { name, count: messageCount })}</p>;
};

// 带格式化插值的示例
const GreetingMessage = ({ name }) => {
  const { t } = useTranslation('common');
  const today = new Date().toLocaleDateString();
  return <p>{t('greeting', { name, date: today })}</p>;
};

// 嵌套对象插值
// zh-CN.json
{
  "user_info": "用户 {{user.name}} 来自 {{user.location.city}}"
}

// 组件中使用
const UserInfo = ({ user }) => {
  const { t } = useTranslation('common');
  return <p>{t('user_info', { user })}</p>;
};

// 数组插值
// zh-CN.json
{
  "fruits": "我喜欢 {{fruits.0}} 和 {{fruits.1}}"
}

// 组件中使用
const FruitList = () => {
  const { t } = useTranslation('common');
  const fruits = ['苹果', '香蕉'];
  return <p>{t('fruits', { fruits })}</p>;
};
```

#### 上下文和变体

i18next 支持上下文（Context）和变体（Variants）功能，可以根据不同的上下文显示不同的翻译。

```javascript
// 上下文翻译
// zh-CN.json
{
  "friend": {
    "male": "男朋友",
    "female": "女朋友",
    "other": "朋友"
  }
}

// en-US.json
{
  "friend": {
    "male": "boyfriend",
    "female": "girlfriend",
    "other": "friend"
  }
}

// 组件中使用
const FriendInfo = ({ gender }) => {
  const { t } = useTranslation('common');
  return <span>{t('friend', { context: gender })}</span>;
};

// 变体翻译
// zh-CN.json
{
  "item": {
    "one": "{{count}} 个项目",
    "other": "{{count}} 个项目"
  }
}

// 组件中使用
const ItemCount = ({ count }) => {
  const { t } = useTranslation('common');
  return <span>{t('item', { count })}</span>;
};
```

#### 富文本翻译

i18next 支持在翻译文本中使用 HTML 标签和 React 组件。

```javascript
// 翻译文件
// zh-CN.json
{
  "welcome_message": "欢迎 <strong>{{name}}</strong>！请查看您的 <a href='{{link}}'>个人资料</a>"
}

// en-US.json
{
  "welcome_message": "Welcome <strong>{{name}}</strong>! Please check your <a href='{{link}}'>profile</a>"
}

// 组件中使用
const WelcomeMessage = ({ name, profileLink }) => {
  const { t } = useTranslation('common');
  return (
    <div 
      dangerouslySetInnerHTML={{
        __html: t('welcome_message', { name, link: profileLink })
      }}
    />
  );
};

// 使用 Trans 组件（推荐）
import { Trans } from 'react-i18next';

const WelcomeMessageWithTrans = ({ name, profileLink }) => {
  return (
    <Trans
      i18nKey="welcome_message"
      values={{ name }}
      components={{
        strong: <strong />,
        link: <a href={profileLink} />
      }}
    />
  );
};
```

```javascript
// 翻译文件
// zh-CN.json
{
  "welcome": "欢迎 {{name}}，您有 {{count}} 条新消息",
  "greeting": "你好，{{name}}！今天是 {{date}}"
}

// en-US.json
{
  "welcome": "Welcome {{name}}, you have {{count}} new messages",
  "greeting": "Hello {{name}}! Today is {{date}}"
}

// 组件中使用
const WelcomeMessage = ({ name, messageCount }) => {
  const { t } = useTranslation('common');
  return <p>{t('welcome', { name, count: messageCount })}</p>;
};

// 带格式化插值的示例
const GreetingMessage = ({ name }) => {
  const { t } = useTranslation('common');
  const today = new Date().toLocaleDateString();
  return <p>{t('greeting', { name, date: today })}</p>;
};
```

[react-i18next]: https://github.com/i18next/react-i18next
[i18next]: https://github.com/i18next
[i18next-http-backend]: https://github.com/i18next/i18next-http-backend
[i18next-browser-languagedetector]: https://github.com/i18next/i18next-browser-languageDetector
[i18next-localstorage-backend]: https://github.com/i18next/i18next-localstorage-backend
[other-repositories]: https://github.com/orgs/i18next/repositories
[i18next-scanner]: https://github.com/i18next/i18next-scanner
[i18next-parser]: https://github.com/i18next/i18next-parser
[crowdin]: https://crowdin.com/
[lokalise]: https://lokalise.com/
[transifex]: https://www.transifex.com/
[configuration-options]: https://www.i18next.com/overview/configuration-options

## 参考

- [i18n](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/i18n), MDN
- [Intl API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl), MDN
- [Internationalization and localization](https://en.wikipedia.org/wiki/Internationalization_and_localization), wikipedia
- [International and Multilingual](https://developers.google.com/search/docs/specialty/international), Google

<!-- ## 核心关键问题

2. 动态语言切换功能实现
5. 翻译文件的加载和缓存策略

## 重要技术问题

6. 插值变量的处理（如用户名、数字等动态内容）
7. 复数形式的处理（单数/复数/零值等）

## 用户体验问题

12. 从右到左（RTL）语言的文本方向处理
13. 语言切换时的加载状态和过渡效果
14. 用户语言偏好的持久化存储
15. 浏览器语言自动检测的准确性

## 性能和优化问题

21. 翻译文件的懒加载和按需加载
22. 大量翻译内容的内存管理
23. 翻译文件的压缩和优化

## 高级功能问题

31. 命名空间的管理和隔离
32. 条件翻译和逻辑分支处理
33. 富文本内容的翻译处理
34. 图片和媒体资源的多语言适配
35. SEO友好的多语言URL结构
-->
