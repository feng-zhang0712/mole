# 前端国际化

## 介绍

国际化（Internationalization，简称 i18n）是指设计和开发软件应用程序时，使其能够轻松适应不同语言、地区和文化的过程。国际化的目的，是为应用程序提供多语言支持。

## i18next

在 React 中，使用 [i18next] 提供的一系列工具，可以快速实现前端国际化。

### 依赖包

首先，需要安装下面列出的依赖包。

- [react-i18next] 必需，React 的 i18next 集成库，提供 React 组件中使用的 Hook 和 HOC，比如 `useTranslation` 和 `withTranslation` 等。
- [i18next] 必需，国际化的核心库，提供翻译引擎。该依赖提供了比如插值处理、命名空间管理、`t()` 和 `changeLanguage()` 等核心方法。
- [i18next-http-backend] 推荐，HTTP 后端加载器，可以从服务器动态加载翻译文件。
- [i18next-browser-languagedetector] 推荐，浏览器语言检测器，能够自动检测用户浏览器语言。
- [i18next-localstorage-backend] 可选，本地存储后端，将翻译文件缓存到 `localStorage`。能够实现离线翻译支持、减少网络请求等功能。
- [i18next-scanner] 可选，代码扫描工具，自动提取代码中的硬编码文本并生成翻译文件。
- [i18next-parser] 可选，翻译文件处理工具，用于解析、转换和验证翻译文件。

除了上面列出的这些，i18next 还提供了很多[其他依赖包][other-repositories]，可以根据自己的需求进行安装。

执行下面的安装命令，添加依赖。

```bash
# 使用 npm
npm install react-i18next i18next i18next-browser-languagedetector i18next-http-backend

# 或者使用 yarn
yarn add react-i18next i18next i18next-browser-languagedetector i18next-http-backend
```

### 创建语料文件

语料文件（Translation Files）是存储多语言翻译内容的文件，通常以 JSON、YAML 等格式存储。语料文件通常以键值对的形式进行存储，键是要翻译的内容的标识，值是对应的翻译后的内容。

下面是一个英语版本（`en-US.json`）的语料文件示例。

```json
{
  "common": {
    "loading": "Loading...",
    "error": "Error",
    "success": "Success"
  },
  "user": {
    "welcome": "Welcome, {{name}}!",
    "profile": "Profile"
  }
}
```

创建语料文件时，应该尽量遵循下面的原则。

- 尽量使用扁平化结构，避免过深的嵌套。
- 语义化命名，避免无意义命名。
- 保持所有语言文件结构一致。
- 对于关键的键值对，提供上下文信息。
- 文化适配。

```json
// 上下文信息提供
{
  "button_save": {
    "value": "Save",
    "context": "Save button in user profile form",
    "usage": "Used when user clicks to save profile changes"
  }
}

// 美国格式
{
  "date_format": "MM/DD/YYYY",
  "currency": "$1,234.56"
}

// 中国格式
{
  "date_format": "YYYY年MM月DD日",
  "currency": "¥1,234.56"
}
```

如果站点面向的是指定国家（地区）的用户，只需创建对应国家（地区）的语料文件即可；如果面向全球用户，可以考虑创建以下国家（地区）的语料文件。

- 英语（`en-US`），国际通用语言。
- 中文简体（`zh-CN`），中国大陆市场。
- 中文繁体（`zh-TW`），台湾、香港、澳门。
- 西班牙语（`es-ES`），全球第二大语言。
- 法语（`fr-FR`），欧洲重要语言。
- 德语（`de-DE`），欧洲经济强国。
- 日语（`ja-JP`），亚洲重要市场。
- 韩语（`ko-KR`），亚洲重要市场。
- 葡萄牙语（`pt-BR`），巴西市场。
- 俄语（`ru-RU`），东欧市场。
- 阿拉伯语（`ar-SA`），中东市场。
- 印地语（`hi-IN`），印度市场。
- 意大利语（`it-IT`），欧洲市场。
- 荷兰语（`nl-NL`），欧洲市场。
- 瑞典语（`sv-SE`），北欧市场。

i18next 提供了 [i18next-scanner] 和 [i18next-parser] 等工具，用于自动提取翻译键以及生成翻译文件模板，也可以使用 [Crowdin]、[Lokalise] 和 [Transifex] 之类的平台提供的付费服务。

### 基本配置

在入口文件中 `src/index.js` 中导入 i18n，执行 i18next 初始化操作。

```javascript
import '@i18n';
```

i18next 的配置文件位于 `@i18n/config/index.js`。

```jsx
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import LanguageDetector from 'i18next-browser-languagedetector';
import Backend from 'i18next-http-backend';

const initI18n = () => {
  i18n
    .use(Backend)
    .use(LanguageDetector)
    .use(initReactI18next)
    .init({
      // ...
    });

  return i18n;
};

export default initI18n();
```

- `lng` 类型为 `<string>`，指定要使用的语言代码，如果使用了语言检测器插件，可忽略此选项。
- `fallbackLng` 类型为 `<string | string[] | object | function>`，指定当用户语言不可用时使用的回退语言。
- `supportedLngs` 类型为 `<string[] | false>`，支持的语言列表。
- `nonExplicitSupportedLngs` 类型为 `<boolean>`，如果为 `true`，当在 `supportedLngs` 中找到 `'en'` 时，会传递 `'en-US'`，默认为 `false`。
- `load` 类型为 `<'all' | 'currentOnly' | 'languageOnly'>`，语言代码查找方式。默认值为 `'all'`。
- `preload` 类型为 `<string[] | false>`，预加载的语言数组，在服务端渲染时很重要。
- `lowerCaseLng` 类型为 `<boolean>`，将语言代码转换为小写
- `cleanCode` 类型为 `<boolean>`，将语言代码转换为小写但保留完整区域设置，比如，`'EN'` 会被转为 `'en'`，但 `'en-US'` 保持不变。
- `ns` 类型为 `<string | string[]>`，要加载的命名空间，默认值为 `['translation']`。
- `defaultNS` 类型为 `<string | false | string[]>`，翻译函数的默认命名空间，默认值为 `['translation']`。
- `fallbackNS` 类型为 `<string | string[] | false>`，当在给定命名空间中找不到键时，要查找的命名空间，默认值为 `false`。
- `resources` 类型为 `<object>`，初始化时使用的语料资源
- `keySeparator` 类型为 `<string | false>`，键分隔符，默认值为 `'.'`
- `nsSeparator` 类型为 `<string | false>`，命名空间分隔符，默认值为 `':'`。
- `contextSeparator` 类型为 `<string>`，上下文分隔符，默认值为 `'_'`。
- `debug` 类型为 `<boolean>`，在控制台输出信息级别日志，帮助查找加载问题。默认值为 `false`。
- `saveMissing` 类型为 `<boolean>`，启用保存缺失键到后端。默认值为 `false`。
- `missingKeyHandler` 类型为 `<function | false>`，自定义缺失键处理函数。
- `interpolation` 类型为 `<object>`，插值选项。
- `react` 类型为 `<object>`，React 插件选项。
- `detection` 类型为 `<object>`，语言检测插件选项。
- `backend` 类型为 `object`，后端插件选项。
- `cache` 类型为 `object`，缓存层插件选项。

以上只是列出了部分配置项，更多信息请参考[配置信息][configuration-options]。

### 创建工具函数、Hooks

项目中，大部分内容都可以使用 i18next 直接转换。但是，有些动态内容，特别是从服务器获取的动态内容，以及跟地区有关的内容，需要使用工具函数进行动态处理。比如，日期类型在显示是，中国地区格式一般为“年/月/日”，而美欧地区一般为“月/日/年”。

`i18n/index.js`

```javascript
export {
  formatNumber,
  formatCurrency,
  formatDate,
  formatRelativeTime,
  formatFileSize,
  formatPercentage,
  getPluralForm,
  hasTranslation,
  getTranslationKey,
  getTranslations,
  isRTL,
  getTextDirection,
} from './utils';
```

```jsx
// src/i18n/hooks/useI18n.js

// 增强的国际化 Hook，提供语言切换、格式化等功能
export const useI18n = (namespace = 'common') => {
  const { t, i18n, ready } = useTranslation(namespace);
  const [currentLang, setCurrentLang] = useState(getCurrentLanguage());
  const [isChanging, setIsChanging] = useState(false);

  // 监听语言变化
  useEffect(() => {
    const handleLanguageChange = (lng) => {
      setCurrentLang(lng);
      setIsChanging(false);
    };

    i18n.on('languageChanged', handleLanguageChange);

    return () => {
      i18n.off('languageChanged', handleLanguageChange);
    };
  }, [i18n]);

  // 切换语言
  const switchLanguage = useCallback(async (language) => {
    if (!isLanguageSupported(language)) {
      console.warn(`Unsupported language: ${language}`);
      return false;
    }

    if (language === currentLang) {
      return true;
    }

    setIsChanging(true);
    const success = await changeLanguage(language);

    if (!success) {
      setIsChanging(false);
    }

    return success;
  }, [currentLang]);

  // 获取支持的语言列表
  const getSupportedLanguages = useCallback(() => Object.keys(SUPPORTED_LANGUAGES).map((code) => ({
    code,
    name: SUPPORTED_LANGUAGES[code],
    isActive: code === currentLang,
  })), [currentLang]);

  // 检查是否为当前语言
  const isCurrentLanguage = useCallback((language) => language === currentLang, [currentLang]);

  // 获取语言显示名称
  const getLanguageName = useCallback((language) => SUPPORTED_LANGUAGES[language] || language, []);

  return {
    // 基础翻译功能
    t,
    ready,

    // 语言相关
    currentLanguage: currentLang,
    switchLanguage,
    getSupportedLanguages,
    isCurrentLanguage,
    getLanguageName,
    isChanging,

    // i18n实例
    i18n,
  };
};
```

### 封装语言切换组件

在语言切换组件中，当用户点击不同的语言选项时，执行语言切换逻辑。

```jsx
// src/components/common/LanguageSwitcher.jsx

import { useI18n } from '@i18n';

const LanguageSwitcher = () => {
  const {
    switchLanguage,
    getSupportedLanguages,
  } = useI18n();

  const supportedLanguages = getSupportedLanguages();

  const handleLanguageChange = async (languageCode) => {
    await switchLanguage(languageCode);
  };

  return (
    <div>
      {supportedLanguages.map(({ code }) => (
        <button onClick={() => handleLanguageChange(code)}></button>
      ))}
    </div>
  );
};

export default LanguageSwitcher;
```

### 在业务组件中使用

```jsx
import React from 'react';
import { useTranslation } from '@i18n';

const MyComponent = () => {
  const { t } = useTranslation('common');
  
  return (
    <div>
      <h1>{t('app.title')}</h1>
      <p>{t('app.description')}</p>
    </div>
  );
};

export default MyComponent;
```

### 高级功能实现

#### 动态加载翻译文件

```javascript
// 在 i18n 配置中启用动态加载
const i18nConfig = {
  backend: {
    loadPath: '/locales/{{lng}}/{{ns}}.json',
    addPath: '/locales/add/{{lng}}/{{ns}}',
  },
  saveMissing: process.env.NODE_ENV === 'development',
  missingKeyHandler: (lng, ns, key) => {
    if (process.env.NODE_ENV === 'development') {
      console.warn(`Missing translation: ${lng}.${ns}.${key}`);
    }
  },
};
```

#### 复数处理

```javascript
// 在翻译文件中使用复数
{
  "items": {
    "zero": "没有项目",
    "one": "{{count}}个项目",
    "other": "{{count}}个项目"
  }
}

// 在组件中使用
const ItemCount = ({ count }) => {
  const { t } = useTranslation('common');
  return <span>{t('items', { count })}</span>;
};
```

#### 插值处理

```javascript
// 翻译文件
{
  "welcome": "欢迎 {{name}}，您有 {{count}} 条新消息"
}

// 组件中使用
const WelcomeMessage = ({ name, messageCount }) => {
  const { t } = useTranslation('common');
  return <p>{t('welcome', { name, count: messageCount })}</p>;
};
```

[react-i18next]: https://github.com/i18next/react-i18next
[i18next]: https://github.com/i18next
[i18next-http-backend]: https://github.com/i18next/i18next-http-backend
[i18next-browser-languagedetector]: https://github.com/i18next/i18next-browser-languageDetector
[i18next-localstorage-backend]: https://github.com/i18next/i18next-localstorage-backend
[other-repositories]: https://github.com/orgs/i18next/repositories
[i18next-scanner]: https://github.com/i18next/i18next-scanner
[i18next-parser]: https://github.com/i18next/i18next-parser
[crowdin]: https://crowdin.com/
[lokalise]: https://lokalise.com/
[transifex]: https://www.transifex.com/
[configuration-options]: https://www.i18next.com/overview/configuration-options

## 参考

- [i18n](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/i18n), MDN
- [Internationalization and localization](https://en.wikipedia.org/wiki/Internationalization_and_localization), wikipedia
- [International and Multilingual](https://developers.google.com/search/docs/specialty/international), Google

<!-- ## 核心关键问题

2. 动态语言切换功能实现
5. 翻译文件的加载和缓存策略

## 重要技术问题

6. 插值变量的处理（如用户名、数字等动态内容）
7. 复数形式的处理（单数/复数/零值等）

## 用户体验问题

12. 从右到左（RTL）语言的文本方向处理
13. 语言切换时的加载状态和过渡效果
14. 用户语言偏好的持久化存储
15. 浏览器语言自动检测的准确性

## 性能和优化问题

21. 翻译文件的懒加载和按需加载
22. 大量翻译内容的内存管理
23. 翻译文件的压缩和优化

## 高级功能问题

31. 命名空间的管理和隔离
32. 条件翻译和逻辑分支处理
33. 富文本内容的翻译处理
34. 图片和媒体资源的多语言适配
35. SEO友好的多语言URL结构
-->
