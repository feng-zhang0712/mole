# Hook

## Hook 结构

```typescript
export type Hook = {
  memoizedState: any,
  baseState: any,
  baseQueue: Update<any, any> | null,
  queue: any,
  next: Hook | null,
};
```

### `memoizedState`

`memoizedState: any` 字段存储 Hook 的当前状态值，不同类型的 Hook 存储不同的数据。

#### （1）`useState`

对于 `useState`，`memoizedState` 直接存储状态值。

```javascript
hook.memoizedState = hook.baseState = initialState;
```

下面代码中，`memoizedState` 存贮当前的状态值 `count`（初始话是值为 `0`）。

```javascript
const [count, setCount] = useState(0);
```

#### （2）`useEffect` 和 `useLayoutEffect`

`memoizedState` 存储 Effect 对象。下面是 Effect 对象的结构。

```javascript
{
  tag: HookFlags, // 副作用标记 (HookHasEffect | HookPassive)
  create: () => void, // 创建函数
  destroy: () => void, // 清理函数
  deps: Array<mixed>, // 依赖数组
  next: Effect | null, // 下一个 Effect
}
```

#### （3）`useContext`

`memoizedState` 存储上下文值。

```javascript
const value = isPrimaryRenderer
  ? context._currentValue
  : context._currentValue2;
```

注意，`useContext` 实际上不创建 Hook 对象，而是直接读取上下文值。

#### （5）`useRef`

`memoizedState` 此时为对象类型，存储 `ref` 对象.

```javascript
const ref = {current: initialValue};
hook.memoizedState = ref;
```

下面代码中，`memoizedState` 为 `{ current: null }`。

```javascript
const ref = useRef(null);
```

#### （5）`useMemo`

`memoizedState` 此时为数组类型，结构为 `[计算值, 依赖数组]`。用于存储计算值和依赖数组。

```javascript
hook.memoizedState = [nextValue, nextDeps];
```

下面代码中，`memoizedState` 为 `[计算结果, [a, b]]`。

```javascript
const memoizedValue = useMemo(() => expensiveCalculation(a, b), [a, b]);
```

#### （6）`useCallback`

`memoizedState` 此时为数组类型，结构为 `[回调函数, 依赖数组]`。存储回调函数和依赖数组的元组。

```javascript
hook.memoizedState = [callback, nextDeps];
```

下面代码中，`memoizedState` 为 `[回调函数, [a, b]]`。

```javascript
const memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);
```

### `baseState`

`baseState: any` 字段存储基础状态，用于计算新状态。

### `baseQueue`

`baseQueue: Update<any, any> | null` 字段基础更新队列，存储由于优先级不足（低优先级）而被跳过的更新。在下次渲染时会重新应用这些更新，以确保更新的完整性，此属性在高优先级更新打断低优先级更新时使用。

### `queue`

`queue: any` 字段表示当前更新队列，类型是 `any`（实际是 `UpdateQueue` 类型）。存储当前 Hook 的所有 pending 更新，包含 dispatch 函数和 reducer，以及管理更新的优先级和调度。

### `next`

`next: Hook | null` 字段是指向下一个 Hook 的指针。用于形成 Hook 链表结构，确保 Hook **调用顺序的一致性**，还支持 Hook 的遍历和查找。

## useState 的实现

## 与 Fiber 的关系

## 链表管理机制

## 状态更新流程
