# 前端模块化详细指南

## 前端模块化发展历史

### 理论基础

前端模块化源于软件工程中的模块化设计原则。模块化的本质是将复杂的系统分解为相对独立、功能明确的模块，每个模块封装特定的功能，对外提供清晰的接口，同时隐藏内部实现细节。这种设计模式遵循了几个重要的软件设计原则：

- 分离关注点（Separation of Concerns）- 不同的功能模块处理不同的业务逻辑
- 高内聚低耦合（High Cohesion, Low Coupling）- 模块内部功能紧密相关，模块间依赖最小化
- 信息隐藏（Information Hiding）- 模块只暴露必要的接口，隐藏实现细节
- 可重用性（Reusability）- 模块可以在不同的上下文中重复使用

### 早期的前端开发困境

在模块化标准出现之前，前端开发主要依赖以下几种原始的代码组织方式，但都存在明显的问题：

```html
<!-- 传统的全局变量方式 -->
<script src="jquery.js"></script>
<script src="utils.js"></script>
<script src="app.js"></script>
<script>
  // 全局变量污染
  var name = "global";
  var utils = {
    formatDate: function() { /* ... */ }
  };
</script>
```

主要问题分析：

1. 全局命名空间污染（Global Namespace Pollution）
   - 所有变量和函数都存在于全局作用域中
   - 不同脚本间容易产生命名冲突
   - 全局对象window成为了所有代码的共享状态容器
   - 难以追踪变量的来源和使用情况

2. 依赖关系管理混乱（Dependency Management Issues）
   - 模块间依赖关系隐式存在，缺乏明确声明
   - 无法自动检测循环依赖
   - 依赖关系的变更需要手动维护多个文件

3. 文件加载顺序敏感（Load Order Sensitivity）
   - script标签的顺序直接影响代码执行
   - 依赖的库必须在使用它的代码之前加载
   - 重构时容易破坏加载顺序导致运行时错误

4. 代码重用和维护困难（Poor Reusability and Maintainability）
   - 功能耦合严重，难以独立测试和重用
   - 缺乏封装机制，内部实现暴露给外部
   - 大型项目中代码结构混乱，维护成本高昂

### 早期解决方案的演进

#### IIFE (Immediately Invoked Function Expression) 模式

立即调用函数表达式是早期JavaScript模块化的重要尝试。IIFE 利用函数作用域的特性来创建私有空间，避免全局污染。这种模式体现了闭包（Closure）的核心概念，即内部函数可以访问外部函数的变量，而外部无法直接访问内部变量。

理论原理：

- 利用 JavaScript 的词法作用域（Lexical Scoping）
- 创建独立的执行上下文（Execution Context）
- 通过闭包机制实现数据封装

```javascript
// 使用 IIFE 避免全局污染
(function() {
  var privateVar = "private";
  
  window.MyModule = {
    publicMethod: function() {
      return privateVar;
    }
  };
})();
```

#### 命名空间模式（Namespace Pattern）

命名空间模式是另一种早期的模块化尝试，它通过创建全局对象来组织相关的功能。这种模式借鉴了其他编程语言（如C#、Java）的命名空间概念，试图在JavaScript中实现类似的代码组织方式。

设计思想：

- 减少全局变量数量
- 通过对象层级结构组织代码
- 提供清晰的代码分组和访问路径

```javascript
// 命名空间模式
var MyApp = MyApp || {};
MyApp.Utils = {
  formatDate: function(date) {
    // 实现
  }
};

MyApp.Components = {
  Modal: function() {
    // 实现
  }
};
```

### 模块化标准化进程

#### 历史发展时间线

随着Web应用复杂度的指数级增长，JavaScript社区开始系统性地解决模块化问题。这个过程经历了从实践探索到标准制定的完整历程：

1. 2009年 - CommonJS规范诞生
- 背景：Node.js的兴起需要服务端JavaScript模块系统
- 特点：同步加载，适合服务器环境
- 影响：奠定了JavaScript模块化的理论基础

2. 2011年 - AMD规范发布
- 背景：浏览器环境需要异步加载机制
- 创新：依赖前置，异步加载
- 代表实现：RequireJS

3. 2012年 - CMD规范提出
- 背景：对AMD复杂语法的简化需求
- 特点：依赖就近，延迟执行
- 代表实现：Sea.js

4. 2015年 - ES6 Modules成为官方标准
- 意义：JavaScript语言原生支持模块化
- 特点：静态结构，编译时优化
- 影响：统一了前端模块化标准

#### 标准化的必要性

模块化标准的制定解决了以下关键问题：

1. API统一性 - 不同环境下使用相同的模块语法
2. 工具链集成 - 构建工具和开发工具的标准化支持
3. 生态系统建设 - 促进了npm等包管理器的发展
4. 性能优化 - 为打包工具的tree-shaking等优化提供基础

## AMD (Asynchronous Module Definition)

### 理论背景与设计哲学

AMD（异步模块定义）规范是为了解决浏览器环境中JavaScript模块加载问题而设计的。与服务器端的同步加载不同，浏览器环境中的模块加载面临着网络延迟、并发加载等挑战。AMD规范的设计哲学基于以下几个核心理念：

#### 1. 异步加载的必要性

在浏览器环境中，同步加载会阻塞UI渲染和用户交互。AMD规范通过异步加载机制确保：
- 非阻塞性 - 模块加载不会阻塞页面渲染
- 并行性 - 多个模块可以并行加载，提高整体加载效率
- 响应性 - 保证用户界面的响应性和流畅性

#### 2. 依赖前置的设计思想

AMD规范采用"依赖前置"的设计模式，即在模块定义时就明确声明所有依赖。这种设计有以下优势：
- 静态分析 - 构建工具可以在编译时分析依赖关系
- 预加载优化 - 可以提前并行加载所有依赖模块
- 循环依赖检测 - 便于检测和处理循环依赖问题

#### 3. 浏览器优先的架构考量

AMD专门针对浏览器环境的特点进行了优化：
- 网络优化 - 减少HTTP请求数量和往返次数
- 缓存策略 - 支持浏览器的缓存机制
- 加载策略 - 支持按需加载和延迟加载

### 概念介绍

AMD 是异步模块定义规范，主要解决浏览器端模块加载的问题。AMD 规范采用异步方式加载模块，模块的加载不影响后面语句的运行。

### 核心特点

1. 异步加载 - 避免阻塞页面渲染
2. 依赖前置 - 在模块定义时就声明依赖
3. 浏览器优先 - 专门为浏览器环境设计

### 语法规范

#### define 函数

```javascript
// AMD 模块定义语法
define(id?, dependencies?, factory);
```

参数说明：

- `id`: 模块标识符（可选）
- `dependencies`: 依赖模块数组（可选）
- `factory`: 工厂函数或对象

### 详细示例

#### 基础模块定义

```javascript
// math.js - 定义一个数学工具模块
define(function() {
  return {
    add: function(a, b) {
      return a + b;
    },
    subtract: function(a, b) {
      return a - b;
    },
    PI: 3.14159
  };
});
```

#### 带依赖的模块定义

```javascript
// calculator.js - 依赖math模块
define(['./math'], function(math) {
  return {
    calculate: function(operation, a, b) {
      switch(operation) {
        case 'add':
          return math.add(a, b);
        case 'subtract':
          return math.subtract(a, b);
        default:
          throw new Error('Unknown operation');
      }
    },
    getPI: function() {
      return math.PI;
    }
  };
});
```

#### 复杂依赖示例

```javascript
// app.js - 多依赖模块
define([
  'jquery',
  './calculator',
  './utils',
  'text!./templates/main.html'
], function($, calculator, utils, mainTemplate) {
  
  return {
    init: function() {
      var result = calculator.calculate('add', 10, 5);
      var formattedResult = utils.formatNumber(result);
      
      $('body').html(mainTemplate.replace('{{result}}', formattedResult));
    }
  };
});
```

### RequireJS 实现

RequireJS 是 AMD 规范最著名的实现：

```html
<!DOCTYPE html>
<html>
<head>
  <script data-main="scripts/main" src="scripts/require.js"></script>
</head>
<body>
</body>
</html>
```

```javascript
// main.js - 入口文件
require.config({
  baseUrl: 'scripts',
  paths: {
    'jquery': 'lib/jquery',
    'underscore': 'lib/underscore',
    'backbone': 'lib/backbone'
  },
  shim: {
    'backbone': {
      deps: ['underscore', 'jquery'],
      exports: 'Backbone'
    }
  }
});

require(['app'], function(app) {
  app.init();
});
```

### 循环依赖处理

```javascript
// moduleA.js
define(['./moduleB'], function(moduleB) {
  return {
    name: 'moduleA',
    getB: function() {
      return moduleB.name;
    }
  };
});

// moduleB.js
define(['./moduleA'], function(moduleA) {
  // 此时 moduleA 可能还未完全初始化
  return {
    name: 'moduleB',
    getA: function() {
      return moduleA ? moduleA.name : 'loading...';
    }
  };
});
```

### AMD 的优缺点

优点：

- 适合浏览器环境
- 异步加载，不阻塞页面
- 支持动态加载
- 成熟的生态系统（RequireJS）

缺点：

- 语法相对复杂
- 依赖前置可能导致性能问题
- 不是官方标准

## CMD (Common Module Definition)

### 概念介绍

CMD 是通用模块定义规范，由玉伯（阿里巴巴）提出。CMD 规范整合了 CommonJS 和 AMD 规范的特点，支持同步和异步加载。

### 核心特点

1. 依赖就近 - 在需要时才声明依赖
2. 延迟执行 - 模块在使用时才执行
3. API简洁 - 语法简单易懂

### 语法规范

```javascript
// CMD 模块定义
define(function(require, exports, module) {
  // 模块代码
});
```

### 详细示例

#### 基础模块定义

```javascript
// math.js
define(function(require, exports, module) {
  exports.add = function(a, b) {
    return a + b;
  };
  
  exports.subtract = function(a, b) {
    return a - b;
  };
  
  exports.PI = 3.14159;
});
```

#### 依赖就近使用

```javascript
// calculator.js
define(function(require, exports, module) {
  
  exports.calculate = function(operation, a, b) {
    // 在需要时才引入依赖
    var math = require('./math');
    
    switch(operation) {
      case 'add':
        return math.add(a, b);
      case 'subtract':
        return math.subtract(a, b);
      default:
        throw new Error('Unknown operation');
    }
  };
  
  exports.advancedCalculate = function(operation, a, b) {
    // 条件性依赖
    if (operation === 'sin' || operation === 'cos') {
      var advancedMath = require('./advanced-math');
      return advancedMath[operation](a);
    }
    
    return exports.calculate(operation, a, b);
  };
});
```

#### 异步依赖加载

```javascript
// app.js
define(function(require, exports, module) {
  
  exports.init = function() {
    var $ = require('jquery');
    var calculator = require('./calculator');
    
    // 异步加载模块
    require.async('./chart', function(chart) {
      var result = calculator.calculate('add', 10, 5);
      chart.render(result);
    });
  };
  
  exports.loadModule = function(moduleName, callback) {
    require.async(moduleName, function(module) {
      callback(module);
    });
  };
});
```

### Sea.js 实现

Sea.js 是 CMD 规范的参考实现：

```html
<!DOCTYPE html>
<html>
<head>
  <script src="sea.js"></script>
</head>
<body>
  <script>
    // 配置
    seajs.config({
      base: './scripts/',
      alias: {
        'jquery': 'lib/jquery'
      }
    });
    
    // 使用模块
    seajs.use('./app', function(app) {
      app.init();
    });
  </script>
</body>
</html>
```

### 插件扩展

```javascript
// Sea.js 插件示例
define(function(require, exports, module) {
  
  // 文本插件
  var template = require('text!./template.html');
  
  // JSON插件
  var config = require('json!./config.json');
  
  // CSS插件
  require('css!./style.css');
  
  exports.render = function() {
    return template.replace('{{title}}', config.title);
  };
});
```

### CMD vs AMD

| 特性 | AMD | CMD |
|------|-----|-----|
| 依赖声明 | 依赖前置 | 依赖就近 |
| 执行时机 | 提前执行 | 延迟执行 |
| 语法复杂度 | 相对复杂 | 相对简单 |
| 性能 | 可能有冗余加载 | 按需加载 |

## CommonJS

### 理论基础与架构原理

CommonJS 规范最初由 Mozilla 的工程师 Kevin Dangoor 于 2009 年提出，目标是为 JavaScript 创建一个适用于服务器端和桌面应用的模块系统。CommonJS 的设计哲学体现了几个重要的软件工程原则：

#### 1. 同步加载模式的设计考量

CommonJS 采用同步加载模式，这种设计基于以下服务器环境的特点：

I/O特性差异：
- 服务器环境 - 文件系统访问速度极快（通常在微秒级别）
- 本地文件系统 - 没有网络延迟，读取操作几乎瞬时完成
- 内存缓存 - 频繁访问的模块会被操作系统缓存在内存中

执行环境控制：
- 服务器端代码运行在可控环境中，不需要考虑用户界面阻塞
- 启动时的模块加载时间对整体性能影响较小
- 错误处理可以直接通过异常机制实现，无需复杂的回调处理

#### 2. 模块封装的实现机制

Node.js 对 CommonJS 的实现采用了模块包装器（Module Wrapper）模式。每个模块在执行前都会被包装在一个函数中：

包装器机制的作用：
- 作用域隔离 - 防止模块间的变量污染
- 上下文注入 - 提供模块运行所需的环境变量
- 生命周期管理 - 控制模块的加载和初始化过程

#### 3. 缓存机制的设计原理

CommonJS实现了单例模式（Singleton Pattern）的模块缓存：

缓存策略：
- 首次加载原则 - 模块在首次require时执行并缓存结果
- 路径标识符 - 使用绝对路径作为缓存的唯一标识
- 引用共享 - 同一模块的多次引用共享同一个实例

性能优化效果：
- 避免重复的文件I/O操作
- 防止模块代码的重复执行
- 实现模块间状态的共享

### 概念介绍

CommonJS 是 Node.js 采用的模块规范，主要用于服务端 JavaScript 开发。CommonJS 规范采用同步加载的方式，适合服务器环境。

### 核心机制

#### 1. 模块包装

Node.js 将每个模块包装在一个函数中。

```javascript
(function(exports, require, module, __filename, __dirname) {
  // 模块代码
});
```

#### 2. 缓存机制

```javascript
// Node.js 模块缓存机制
function Module(id, parent) {
  this.id = id;
  this.exports = {};
  this.parent = parent;
  this.children = [];
  this.loaded = false;
}

// 模块缓存
Module._cache = {};

// 加载模块
Module.prototype.load = function(filename) {
  if (Module._cache[filename]) {
    return Module._cache[filename].exports;
  }
  
  // 创建新模块实例
  var module = new Module(filename);
  Module._cache[filename] = module;
  
  // 执行模块代码
  this._compile(content, filename);
  
  return module.exports;
};
```

### 详细语法

#### 导出模块

```javascript
// math.js - 方式一：使用 exports
exports.add = function(a, b) {
  return a + b;
};

exports.subtract = function(a, b) {
  return a - b;
};

exports.PI = 3.14159;

// 方式二：使用 module.exports
module.exports = {
  add: function(a, b) {
    return a + b;
  },
  subtract: function(a, b) {
    return a - b;
  },
  PI: 3.14159
};

// 方式三：导出构造函数
module.exports = function Calculator() {
  this.add = function(a, b) {
    return a + b;
  };
};

// 方式四：导出类
class Calculator {
  add(a, b) {
    return a + b;
  }
  
  subtract(a, b) {
    return a - b;
  }
}

module.exports = Calculator;
```

#### 导入模块

```javascript
// 导入自定义模块
const math = require('./math');
const { add, subtract } = require('./math');

// 导入核心模块
const fs = require('fs');
const path = require('path');

// 导入第三方模块
const express = require('express');
const lodash = require('lodash');

// 使用导入的模块
console.log(math.add(5, 3)); // 8
console.log(add(5, 3)); // 8
```

### 模块查找机制

#### 1. 核心模块查找

```javascript
// 核心模块优先级最高
const fs = require('fs'); // 加载核心模块
```

#### 2. 文件模块查找

```javascript
// 相对路径
const myModule = require('./my-module');
const utils = require('../utils/index');

// 绝对路径
const config = require('/path/to/config');
```

#### 3. 目录模块查找

```javascript
// package.json 中的 main 字段
{
  "name": "my-package",
  "main": "./lib/index.js"
}

// 查找顺序：
// 1. ./my-package/package.json 的 main 字段
// 2. ./my-package/index.js
// 3. ./my-package/index.json
// 4. ./my-package/index.node
```

#### 4. node_modules 查找

```javascript
// 查找路径示例
// 当前文件：/Users/project/src/app.js
// require('lodash') 的查找路径：

// 1. /Users/project/src/node_modules/lodash
// 2. /Users/project/node_modules/lodash
// 3. /Users/node_modules/lodash
// 4. /node_modules/lodash
```

### 高级特性

#### 1. 循环依赖处理

```javascript
// a.js
console.log('a starting');
exports.done = false;
const b = require('./b.js');
console.log('in a, b.done = %j', b.done);
exports.done = true;
console.log('a done');

// b.js
console.log('b starting');
exports.done = false;
const a = require('./a.js');
console.log('in b, a.done = %j', a.done);
exports.done = true;
console.log('b done');

// main.js
console.log('main starting');
const a = require('./a.js');
const b = require('./b.js');
console.log('in main, a.done=%j, b.done=%j', a.done, b.done);

// 输出：
// main starting
// a starting
// b starting
// in b, a.done = false
// b done
// in a, b.done = true
// a done
// in main, a.done=true, b.done=true
```

#### 2. 模块作用域变量

```javascript
// my-module.js
console.log('__filename:', __filename);
console.log('__dirname:', __dirname);
console.log('module:', module);
console.log('exports:', exports);
console.log('require:', require);

// 输出示例：
// __filename: /Users/project/src/my-module.js
// __dirname: /Users/project/src
// module: Module { ... }
// exports: {}
// require: [Function: require]
```

#### 3. 动态导入

```javascript
// 条件导入
const isDevelopment = process.env.NODE_ENV === 'development';
const logger = isDevelopment ? require('./dev-logger') : require('./prod-logger');

// 运行时导入
function loadPlugin(name) {
  try {
    return require(`./plugins/${name}`);
  } catch (error) {
    console.error(`Plugin ${name} not found`);
    return null;
  }
}

// 延迟导入
let heavyModule;
function getHeavyModule() {
  if (!heavyModule) {
    heavyModule = require('./heavy-computation-module');
  }
  return heavyModule;
}
```

### CommonJS 优缺点

优点：

- 同步加载适合服务器环境
- 支持动态导入

缺点：

- 同步加载不适合浏览器
- 运行时解析依赖
- 无法进行静态分析优化

## ESM (ECMAScript Modules)

### 理论基础与语言设计原理

ESM（ECMAScript Modules）是JavaScript语言规范（ECMAScript 2015/ES6）的官方模块系统，代表了JavaScript模块化的终极解决方案。ESM的设计融合了前期各种模块系统的经验，同时体现了现代编程语言设计的先进理念。

#### 1. 静态模块结构的设计哲学

ESM采用静态模块结构（Static Module Structure），这是其最重要的创新之一：

编译时确定性（Compile-time Determinism）：
- 静态分析优势 - 在代码执行前就能确定模块的导入导出关系
- tree-shaking基础 - 未使用的代码可以在构建时被移除
- 循环依赖检测 - 编译器可以提前发现并处理循环依赖
- 类型检查支持 - 为TypeScript等类型系统提供了坚实基础

与动态加载的对比：
```javascript
// 静态结构 - 编译时确定
import { functionA } from './module.js';

// 动态结构 - 运行时确定
const moduleName = getUserChoice();
const module = require(moduleName);
```

#### 2. 异步加载模型的实现原理

ESM的异步加载基于Promise和事件循环机制：

加载阶段（Loading Phases）：
1. Construction - 查找、下载、解析模块
2. Instantiation - 分配内存空间，建立模块间连接
3. Evaluation - 执行模块代码

异步加载的优势：
- 非阻塞性 - 不会阻塞主线程执行
- 并行化 - 多个模块可以并行加载
- 渐进式 - 支持代码分割和按需加载

#### 3. 实时绑定机制（Live Binding）

ESM实现了实时绑定，这是与CommonJS的重要区别：

实时绑定的含义：
- 导入的变量是对原始变量的引用，而非拷贝
- 当导出模块中的值发生变化时，导入模块中的值也会同步变化
- 这种机制类似于JavaScript中的引用传递

技术实现原理：
```javascript
// moduleA.js
export let counter = 0;
export function increment() {
  counter++; // 修改导出值
}

// moduleB.js
import { counter, increment } from './moduleA.js';
console.log(counter); // 0
increment();
console.log(counter); // 1 - 实时同步！
```

#### 4. 词法作用域和模块作用域

ESM为每个模块创建独立的模块作用域（Module Scope）：

作用域特性：
- 顶级作用域隔离 - 模块顶级变量不会污染全局作用域
- 严格模式默认 - 所有ESM模块自动运行在严格模式下
- this绑定 - 模块顶级的this值为undefined

### 概念介绍

ESM 是 ECMAScript 2015 (ES6) 引入的官方模块规范，是 JavaScript 语言层面的模块化标准。ESM 采用静态模块结构，支持编译时优化。

### 核心特性

1. 静态结构 - 编译时确定依赖关系
2. 异步加载 - 支持异步加载
3. 严格模式 - 自动启用严格模式
4. 顶级作用域 - 模块顶级作用域不是全局作用域

### 语法规范

#### 导出语法

```javascript
// math.js

// 命名导出
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

export const PI = 3.14159;

// 批量导出
function multiply(a, b) {
  return a * b;
}

function divide(a, b) {
  return a / b;
}

export { multiply, divide };

// 重命名导出
function power(base, exponent) {
  return Math.pow(base, exponent);
}

export { power as pow };

// 默认导出
export default class Calculator {
  constructor() {
    this.history = [];
  }
  
  add(a, b) {
    const result = a + b;
    this.history.push(`${a} + ${b} = ${result}`);
    return result;
  }
}

// 混合导出
export const version = '1.0.0';
export default Calculator;
```

#### 导入语法

```javascript
// 命名导入
import { add, subtract, PI } from './math.js';

// 重命名导入
import { pow as power } from './math.js';

// 批量导入
import * as math from './math.js';

// 默认导入
import Calculator from './math.js';

// 混合导入
import Calculator, { version, PI } from './math.js';

// 动态导入
const mathModule = await import('./math.js');
const { add, subtract } = mathModule;

// 条件动态导入
if (condition) {
  const { advancedFunction } = await import('./advanced-math.js');
  advancedFunction();
}
```

### 高级特性

#### 1. 重新导出

```javascript
// utils/index.js - 统一导出入口
export { add, subtract, multiply, divide } from './math.js';
export { formatDate, formatNumber } from './format.js';
export { default as Calculator } from './calculator.js';

// 重新导出所有
export * from './string-utils.js';

// 重新导出并重命名
export { default as StringUtils } from './string-utils.js';
```

#### 2. 动态导入高级用法

```javascript
// 懒加载组件
async function loadComponent(componentName) {
  try {
    const module = await import(`./components/${componentName}.js`);
    return module.default;
  } catch (error) {
    console.error(`Failed to load component: ${componentName}`);
    return null;
  }
}

// 并行加载多个模块
async function loadModules() {
  const [mathModule, utilsModule, configModule] = await Promise.all([
    import('./math.js'),
    import('./utils.js'),
    import('./config.js')
  ]);
  
  return {
    math: mathModule,
    utils: utilsModule,
    config: configModule
  };
}

// 条件加载
async function getLocalization(language) {
  switch (language) {
    case 'zh':
      return await import('./locales/zh.js');
    case 'en':
      return await import('./locales/en.js');
    default:
      return await import('./locales/en.js');
  }
}
```

#### 3. 模块的执行时机

```javascript
// side-effect-module.js
console.log('This module has side effects');

// 全局状态
window.globalState = window.globalState || {};
window.globalState.moduleLoaded = true;

// 修改DOM
document.body.classList.add('module-loaded');

// main.js
import './side-effect-module.js'; // 仅执行副作用，不导入值
```

#### 4. Top-level await

```javascript
// config.js
const response = await fetch('/api/config');
const config = await response.json();

export default config;

// main.js
import config from './config.js'; // 会等待config模块的异步操作完成
console.log(config);
```

### 浏览器环境使用

#### 1. 原生支持

```html
<!DOCTYPE html>
<html>
<head>
  <title>ESM Example</title>
</head>
<body>
  <script type="module">
    import { add } from './math.js';
    import Calculator from './calculator.js';
    
    console.log(add(5, 3));
    
    const calc = new Calculator();
    console.log(calc.add(10, 20));
  </script>
  
  <!-- 模块脚本 -->
  <script type="module" src="./main.js"></script>
  
  <!-- 降级支持 -->
  <script nomodule src="./legacy-bundle.js"></script>
</body>
</html>
```

#### 2. Import Maps

```html
<script type="importmap">
{
  "imports": {
    "lodash": "/node_modules/lodash/lodash.js",
    "react": "/node_modules/react/index.js",
    "utils/": "./src/utils/"
  }
}
</script>

<script type="module">
  import _ from 'lodash';
  import React from 'react';
  import { formatDate } from 'utils/date.js';
</script>
```

#### 3. 动态导入在浏览器中的应用

```javascript
// 代码分割
async function loadPage(pageName) {
  const pageModule = await import(`./pages/${pageName}.js`);
  const page = new pageModule.default();
  page.render();
}

// 按需加载polyfill
async function loadPolyfills() {
  if (!window.fetch) {
    await import('./polyfills/fetch.js');
  }
  
  if (!window.Promise) {
    await import('./polyfills/promise.js');
  }
}

// 懒加载图表库
async function renderChart(data) {
  const { Chart } = await import('https://cdn.jsdelivr.net/npm/chart.js');
  return new Chart(document.getElementById('chart'), {
    type: 'bar',
    data: data
  });
}
```

### Node.js 环境使用

#### 1. 启用ESM支持

```json
// package.json
{
  "type": "module",
  "main": "./src/index.js"
}
```

或使用 `.mjs` 扩展名：

```javascript
// math.mjs
export function add(a, b) {
  return a + b;
}

// main.mjs
import { add } from './math.mjs';
console.log(add(5, 3));
```

#### 2. 与CommonJS互操作

```javascript
// 在ESM中导入CommonJS模块
import fs from 'fs';
import express from 'express';

// 命名导入需要解构
import { readFile } from 'fs';

// 导入CommonJS默认导出
import lodash from 'lodash';

// createRequire用于导入CommonJS
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const oldModule = require('./legacy-commonjs-module');
```

#### 3. __dirname 和 __filename 的替代

```javascript
// ESM中获取文件路径信息
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// 或使用import.meta
console.log('Current file URL:', import.meta.url);

// 动态导入相对路径
const modulePath = new URL('./utils.js', import.meta.url);
const utils = await import(modulePath);
```

### 构建工具支持

#### Webpack 配置

```javascript
// webpack.config.js
module.exports = {
  mode: 'production',
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  },
  experiments: {
    outputModule: true
  },
  output: {
    library: {
      type: 'module'
    }
  }
};
```

#### Rollup 配置

```javascript
// rollup.config.js
export default {
  input: 'src/main.js',
  output: {
    file: 'dist/bundle.js',
    format: 'es'
  }
};
```

#### Vite 配置

```javascript
// vite.config.js
import { defineConfig } from 'vite';

export default defineConfig({
  build: {
    lib: {
      entry: 'src/main.js',
      formats: ['es', 'cjs']
    }
  }
});
```

### Tree Shaking 优化

```javascript
// utils.js
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

export function multiply(a, b) {
  return a * b;
}

export function divide(a, b) {
  return a / b;
}

// main.js - 只导入需要的函数
import { add, subtract } from './utils.js';

console.log(add(5, 3));
console.log(subtract(10, 4));

// 构建时，multiply和divide函数会被tree-shaking移除
```

### ESM 优缺点

优点：

- 官方标准，长期支持
- 静态分析，支持tree-shaking
- 异步加载，适合浏览器
- 语法简洁明了
- 支持顶级await

缺点：

- 浏览器兼容性（旧版本）
- Node.js支持相对较新
- 与CommonJS生态的兼容性问题

## 模块系统对比

### 功能对比表

| 特性 | CommonJS | AMD | CMD | ESM |
|------|----------|-----|-----|-----|
| 加载方式 | 同步 | 异步 | 异步 | 异步/同步 |
| 环境 | 服务端 | 浏览器 | 浏览器 | 通用 |
| 依赖声明 | 运行时 | 编译时 | 运行时 | 编译时 |
| 语法复杂度 | 简单 | 中等 | 简单 | 简单 |
| 循环依赖 | 支持 | 支持 | 支持 | 支持 |
| 静态分析 | 不支持 | 部分支持 | 不支持 | 支持 |
| Tree Shaking | 不支持 | 不支持 | 不支持 | 支持 |
| 动态导入 | 支持 | 支持 | 支持 | 支持 |
| 标准化 | 事实标准 | 社区标准 | 社区标准 | 官方标准 |

### 性能对比

#### 1. 加载性能

```javascript
// CommonJS - 同步阻塞
const moduleA = require('./moduleA'); // 阻塞
const moduleB = require('./moduleB'); // 阻塞
const moduleC = require('./moduleC'); // 阻塞

// AMD - 异步并行
define(['./moduleA', './moduleB', './moduleC'], function(A, B, C) {
  // 所有依赖并行加载
});

// ESM - 静态分析 + 异步
import A from './moduleA.js'; // 静态分析，可优化
import B from './moduleB.js';
import C from './moduleC.js';
```

#### 2. 打包体积

```javascript
// CommonJS - 无法tree-shaking
const _ = require('lodash'); // 整个lodash都会被打包

// ESM - 支持tree-shaking
import { debounce, throttle } from 'lodash-es'; // 只打包用到的函数
```

### 语法对比示例

#### 导出对比

```javascript
// CommonJS
exports.add = function(a, b) { return a + b; };
module.exports = Calculator;

// AMD
define(function() {
  return {
    add: function(a, b) { return a + b; }
  };
});

// CMD
define(function(require, exports, module) {
  exports.add = function(a, b) { return a + b; };
});

// ESM
export function add(a, b) { return a + b; }
export default Calculator;
```

#### 导入对比

```javascript
// CommonJS
const math = require('./math');
const { add } = require('./math');

// AMD
define(['./math'], function(math) {
  // 使用math
});

// CMD
define(function(require) {
  const math = require('./math');
});

// ESM
import math from './math.js';
import { add } from './math.js';
```

## 总结

## 深度技术分析

### 模块系统的底层实现机制

#### 1. JavaScript引擎的模块加载机制

V8引擎中的ESM实现：

现代JavaScript引擎（如Chrome的V8）对ESM的实现涉及多个复杂的内部机制：

模块记录（Module Record）：
```javascript
// V8内部的模块记录数据结构（简化版）
class ModuleRecord {
  constructor(source, url) {
    this.source = source;           // 模块源代码
    this.url = url;                 // 模块URL
    this.namespace = new Map();     // 导出命名空间
    this.requestedModules = [];     // 依赖模块列表
    this.importEntries = [];        // 导入条目
    this.exportEntries = [];        // 导出条目
    this.dfsIndex = undefined;      // 深度优先搜索索引
    this.dfsAncestorIndex = undefined;
    this.status = 'unlinked';       // linking, linked, evaluating, evaluated
  }
}
```

模块解析和链接过程：
```javascript
// 模块解析的核心算法（简化说明）
class ModuleLoader {
  async loadModule(specifier, referrer) {
    // 1. 解析模块说明符
    const url = this.resolveModuleSpecifier(specifier, referrer);
    
    // 2. 检查模块缓存
    if (this.moduleMap.has(url)) {
      return this.moduleMap.get(url);
    }
    
    // 3. 获取模块源码
    const source = await this.fetchModule(url);
    
    // 4. 解析模块
    const moduleRecord = this.parseModule(source, url);
    
    // 5. 缓存模块记录
    this.moduleMap.set(url, moduleRecord);
    
    // 6. 递归加载依赖模块
    for (const dependency of moduleRecord.requestedModules) {
      await this.loadModule(dependency, url);
    }
    
    return moduleRecord;
  }
  
  linkModule(moduleRecord) {
    // 强连通分量算法检测循环依赖
    const stronglyConnectedComponents = this.findSCC(moduleRecord);
    
    // 按拓扑顺序链接模块
    for (const component of stronglyConnectedComponents) {
      this.linkComponentModules(component);
    }
  }
  
  evaluateModule(moduleRecord) {
    // 深度优先遍历求值
    if (moduleRecord.status === 'evaluated') {
      return;
    }
    
    // 先求值所有依赖
    for (const dependency of moduleRecord.dependencies) {
      this.evaluateModule(dependency);
    }
    
    // 执行模块代码
    this.executeModuleCode(moduleRecord);
    moduleRecord.status = 'evaluated';
  }
}
```

#### 2. Tree Shaking的深层原理

静态分析的工作机制：

Tree Shaking基于ESM的静态结构特性，通过静态分析确定哪些代码可以安全移除：

```javascript
// Webpack/Rollup中Tree Shaking的简化算法
class TreeShaker {
  constructor(moduleGraph) {
    this.moduleGraph = moduleGraph;
    this.usedExports = new Set();
    this.sideEffectModules = new Set();
  }
  
  analyze() {
    // 1. 标记阶段 - 从入口点开始标记所有使用的导出
    this.markPhase();
    
    // 2. 扫描阶段 - 移除未标记的代码
    this.sweepPhase();
  }
  
  markPhase() {
    const queue = [this.moduleGraph.entryPoint];
    const visited = new Set();
    
    while (queue.length > 0) {
      const module = queue.shift();
      if (visited.has(module)) continue;
      visited.add(module);
      
      // 分析模块的导入语句
      for (const importStmt of module.imports) {
        if (importStmt.isNamespaceImport) {
          // import * as foo from 'bar' - 标记所有导出
          this.markAllExports(importStmt.source);
        } else {
          // import { foo } from 'bar' - 只标记特定导出
          for (const specifier of importStmt.specifiers) {
            this.markExport(importStmt.source, specifier.imported);
          }
        }
      }
      
      // 检查副作用
      if (this.hasSideEffects(module)) {
        this.sideEffectModules.add(module);
      }
    }
  }
  
  sweepPhase() {
    for (const module of this.moduleGraph.modules) {
      // 保留有副作用的模块
      if (this.sideEffectModules.has(module)) {
        continue;
      }
      
      // 移除未使用的导出
      const newExports = [];
      for (const exportStmt of module.exports) {
        if (this.usedExports.has(`${module.id}:${exportStmt.name}`)) {
          newExports.push(exportStmt);
        }
      }
      module.exports = newExports;
    }
  }
  
  hasSideEffects(module) {
    // 检查模块是否有副作用
    return this.analyzeSideEffects(module.ast);
  }
  
  analyzeSideEffects(ast) {
    // 简化的副作用分析
    for (const node of ast.body) {
      switch (node.type) {
        case 'ExpressionStatement':
          // 函数调用可能有副作用
          if (node.expression.type === 'CallExpression') {
            return true;
          }
          break;
        case 'VariableDeclaration':
          // 检查变量初始化是否有副作用
          for (const declarator of node.declarations) {
            if (declarator.init && this.expressionHasSideEffects(declarator.init)) {
              return true;
            }
          }
          break;
      }
    }
    return false;
  }
}
```

#### 3. 模块缓存和热更新机制

Webpack HMR的实现原理：

```javascript
// Webpack热模块替换的核心机制
class HotModuleReplacementRuntime {
  constructor() {
    this.moduleCache = new Map();
    this.hotUpdateCallbacks = new Map();
    this.websocket = null;
  }
  
  initialize() {
    // 建立与开发服务器的WebSocket连接
    this.websocket = new WebSocket('ws://localhost:3000/sockjs-node');
    this.websocket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleUpdate(data);
    };
  }
  
  async handleUpdate(updateData) {
    if (updateData.type === 'hot-update') {
      // 下载更新的模块
      const updatedModules = await this.downloadUpdate(updateData.chunks);
      
      // 应用更新
      for (const [moduleId, moduleFactory] of updatedModules) {
        await this.applyModuleUpdate(moduleId, moduleFactory);
      }
    }
  }
  
  async applyModuleUpdate(moduleId, newModuleFactory) {
    const oldModule = this.moduleCache.get(moduleId);
    
    // 检查模块是否接受更新
    if (!this.isHotAcceptable(moduleId)) {
      // 如果模块不接受热更新，则刷新页面
      window.location.reload();
      return;
    }
    
    // 执行新的模块工厂函数
    const newModule = {
      exports: {},
      hot: this.createHotAPI(moduleId)
    };
    
    try {
      newModuleFactory.call(
        newModule.exports,
        newModule,
        newModule.exports,
        this.createRequire(moduleId)
      );
      
      // 更新模块缓存
      this.moduleCache.set(moduleId, newModule);
      
      // 调用热更新回调
      const callbacks = this.hotUpdateCallbacks.get(moduleId) || [];
      for (const callback of callbacks) {
        callback(newModule.exports);
      }
      
    } catch (error) {
      console.error('Hot update failed:', error);
      window.location.reload();
    }
  }
  
  createHotAPI(moduleId) {
    return {
      accept: (dependencies, callback) => {
        if (typeof dependencies === 'function') {
          callback = dependencies;
          dependencies = [moduleId];
        }
        
        for (const dep of dependencies) {
          if (!this.hotUpdateCallbacks.has(dep)) {
            this.hotUpdateCallbacks.set(dep, []);
          }
          this.hotUpdateCallbacks.get(dep).push(callback);
        }
      },
      
      dispose: (callback) => {
        // 模块销毁时的清理逻辑
        if (!this.disposeCallbacks) {
          this.disposeCallbacks = new Map();
        }
        this.disposeCallbacks.set(moduleId, callback);
      }
    };
  }
}
```
