# 扫码登录

## 概述

## 实现流程

### 登录信息过期验证

用户在浏览器中输入站点 URL 时，首先要判断登录信息是否存在或者过期。如果当前用户身份信息没有过期，则直接加载相应的页面，否则跳转到登录页面。

登录身份信息的验证，需要执行服务器接口来获取结果，下面是服务器端这部分身份验证逻辑的实现。

```javascript
// server/index.js

app.post('/api/auth/status', async (req, res) => {
  try {
    const token = extractTokenFromRequest(req);
    
    if (!token) {
      return res.json({
        success: false,
        message: '未提供认证令牌',
        isLoggedIn: false
      });
    }
    
    const decoded = verifyToken(token);
    
    const user = await User.findById(decoded.userId);
    
    if (!user || !user.isActive) {
      return res.json({
        success: false,
        message: '用户不存在或已被禁用',
        isLoggedIn: false
      });
    }
    
    res.json({
      success: true,
      isLoggedIn: true,
      data: {
        token: token,
        userInfo: {
          id: user._id,
          role: user.role,
          username: user.username
        }
      }
    });
  } catch {
    res.status(500).json({
      success: false,
      message: '检查登录状态失败',
      isLoggedIn: false
    });
  }
});
```

应用启动时，只需请求上面的接口即可获取当前用户身份过期信息，扫码登录的实现，主要是处理用户登录信息过期时，即上面的响应中 `isLoggedIn` 为 `false` 时的情况。客户端获取结果后，只要发现登录信息过期，就跳转到登录页面，引导用户登录。

### 获取登录二维码

```javascript
// server/index.js

app.post('/api/qr/generate', async (req, res) => {
  try {
    const sessionId = uuid();
    
    const qrCodeDataURL = await generateQRCode(sessionId);
    
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);
    const qrSession = new QRCodeSession({
      sessionId,
      qrCode: qrCodeDataURL,
      status: 'pending',
      expiresAt
    });
    
    await qrSession.save();
    
    res.json({
      success: true,
      data: {
        sessionId,
        qrCodeDataURL,
        expiresIn: 5 * 60 * 1000
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: '生成二维码失败'
    });
  }
});
```

### 手机端扫码登录

```javascript

```

### 服务器生成临时 Token

```javascript

```

### 手机端确认是否登录

```javascript

```

### 服务器返回 PC 端 Token

```javascript

```

### PC 端轮询获取登录状态

```javascript

```

### 服务器返回登录结果

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

```javascript

```

































































## 一、扫码登录技术方案概览

### 1.1 主流实现方式对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| WebSocket | 实时性好、双向通信 | 服务器压力大 | 高并发场景 |
| 轮询 | 实现简单、兼容性好 | 延迟高、资源浪费 | 低频场景 |
| Server-Sent Events | 实时性好、单向推送 | 单向通信 | 状态推送 |
| 长轮询 | 实时性好、资源适中 | 实现复杂 | 中等并发 |
| WebRTC | 点对点通信 | 实现复杂 | 特殊场景 |

### 1.2 扫码登录流程

```
用户端(PC) ←→ 服务器 ←→ 移动端(APP)
     ↓           ↓           ↓
   生成二维码   存储状态    扫码确认
     ↓           ↓           ↓
   轮询状态     更新状态    授权登录
     ↓           ↓           ↓
   登录成功     清理状态     登录完成
```

## 二、WebSocket方案（推荐）

### 2.1 服务端实现（Node.js + Socket.io）

```javascript
/**
 * 扫码登录服务端实现
 */
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');

class QRLoginServer {
  constructor() {
    this.app = express();
    this.server = http.createServer(this.app);
    this.io = socketIo(this.server, {
      cors: {
        origin: "*",
        methods: ["GET", "POST"]
      }
    });
    
    this.qrCodes = new Map(); // 存储二维码状态
    this.userSessions = new Map(); // 存储用户会话
    
    this.setupRoutes();
    this.setupSocketHandlers();
  }

  setupRoutes() {
    // 生成二维码
    this.app.post('/api/qr/generate', (req, res) => {
      const qrData = this.generateQRCode();
      res.json({
        success: true,
        data: {
          qrId: qrData.qrId,
          qrCode: qrData.qrCode,
          expiresAt: qrData.expiresAt
        }
      });
    });

    // 检查二维码状态
    this.app.get('/api/qr/status/:qrId', (req, res) => {
      const { qrId } = req.params;
      const qrData = this.qrCodes.get(qrId);
      
      if (!qrData) {
        return res.json({
          success: false,
          message: '二维码不存在或已过期'
        });
      }

      res.json({
        success: true,
        data: {
          status: qrData.status,
          userInfo: qrData.userInfo,
          expiresAt: qrData.expiresAt
        }
      });
    });

    // 移动端扫码确认
    this.app.post('/api/qr/scan', (req, res) => {
      const { qrId, token } = req.body;
      const qrData = this.qrCodes.get(qrId);
      
      if (!qrData) {
        return res.json({
          success: false,
          message: '二维码不存在或已过期'
        });
      }

      // 验证移动端token
      try {
        const decoded = jwt.verify(token, process.env.MOBILE_JWT_SECRET);
        qrData.status = 'scanned';
        qrData.userInfo = decoded;
        qrData.scannedAt = new Date();
        
        // 通知PC端
        this.io.to(qrId).emit('qrScanned', {
          userInfo: decoded,
          scannedAt: qrData.scannedAt
        });
        
        res.json({ success: true, message: '扫码成功' });
      } catch (error) {
        res.json({
          success: false,
          message: 'Token验证失败'
        });
      }
    });

    // 移动端确认登录
    this.app.post('/api/qr/confirm', (req, res) => {
      const { qrId, token } = req.body;
      const qrData = this.qrCodes.get(qrId);
      
      if (!qrData || qrData.status !== 'scanned') {
        return res.json({
          success: false,
          message: '请先扫码'
        });
      }

      try {
        const decoded = jwt.verify(token, process.env.MOBILE_JWT_SECRET);
        
        // 生成PC端登录token
        const pcToken = jwt.sign(
          { 
            userId: decoded.userId,
            username: decoded.username,
            loginType: 'qr'
          },
          process.env.PC_JWT_SECRET,
          { expiresIn: '7d' }
        );
        
        qrData.status = 'confirmed';
        qrData.pcToken = pcToken;
        qrData.confirmedAt = new Date();
        
        // 通知PC端登录成功
        this.io.to(qrId).emit('loginSuccess', {
          token: pcToken,
          userInfo: decoded,
          confirmedAt: qrData.confirmedAt
        });
        
        // 清理二维码数据
        setTimeout(() => {
          this.qrCodes.delete(qrId);
        }, 5000);
        
        res.json({ success: true, message: '登录成功' });
      } catch (error) {
        res.json({
          success: false,
          message: 'Token验证失败'
        });
      }
    });
  }

  setupSocketHandlers() {
    this.io.on('connection', (socket) => {
      console.log('用户连接:', socket.id);
      
      // 加入二维码房间
      socket.on('joinQR', (qrId) => {
        socket.join(qrId);
        console.log(`用户 ${socket.id} 加入二维码房间 ${qrId}`);
      });
      
      // 离开二维码房间
      socket.on('leaveQR', (qrId) => {
        socket.leave(qrId);
        console.log(`用户 ${socket.id} 离开二维码房间 ${qrId}`);
      });
      
      // 用户断开连接
      socket.on('disconnect', () => {
        console.log('用户断开连接:', socket.id);
      });
    });
  }

  generateQRCode() {
    const qrId = crypto.randomUUID();
    const qrCode = `qr://login/${qrId}`;
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5分钟过期
    
    const qrData = {
      qrId,
      qrCode,
      status: 'pending', // pending, scanned, confirmed, expired
      createdAt: new Date(),
      expiresAt,
      userInfo: null,
      scannedAt: null,
      confirmedAt: null,
      pcToken: null
    };
    
    this.qrCodes.set(qrId, qrData);
    
    // 设置过期清理
    setTimeout(() => {
      if (this.qrCodes.has(qrId)) {
        const qrData = this.qrCodes.get(qrId);
        if (qrData.status === 'pending') {
          qrData.status = 'expired';
          this.io.to(qrId).emit('qrExpired');
        }
        this.qrCodes.delete(qrId);
      }
    }, 5 * 60 * 1000);
    
    return qrData;
  }

  start(port = 3000) {
    this.server.listen(port, () => {
      console.log(`扫码登录服务器启动在端口 ${port}`);
    });
  }
}

// 启动服务器
const qrLoginServer = new QRLoginServer();
qrLoginServer.start();
```

### 2.2 前端实现（PC端）

```javascript
/**
 * PC端扫码登录实现
 */
class QRLoginClient {
  constructor(options = {}) {
    this.apiBase = options.apiBase || '/api/qr';
    this.wsUrl = options.wsUrl || 'ws://localhost:3000';
    this.socket = null;
    this.currentQRId = null;
    this.pollingInterval = null;
    this.onStatusChange = options.onStatusChange || (() => {});
    this.onLoginSuccess = options.onLoginSuccess || (() => {});
    this.onError = options.onError || (() => {});
  }

  /**
   * 初始化WebSocket连接
   */
  initWebSocket() {
    this.socket = io(this.wsUrl);
    
    this.socket.on('connect', () => {
      console.log('WebSocket连接成功');
    });
    
    this.socket.on('disconnect', () => {
      console.log('WebSocket连接断开');
    });
    
    this.socket.on('qrScanned', (data) => {
      console.log('二维码已扫描:', data);
      this.onStatusChange('scanned', data);
    });
    
    this.socket.on('loginSuccess', (data) => {
      console.log('登录成功:', data);
      this.onLoginSuccess(data);
      this.cleanup();
    });
    
    this.socket.on('qrExpired', () => {
      console.log('二维码已过期');
      this.onStatusChange('expired');
      this.cleanup();
    });
  }

  /**
   * 生成二维码
   */
  async generateQRCode() {
    try {
      const response = await fetch(`${this.apiBase}/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      const result = await response.json();
      
      if (result.success) {
        this.currentQRId = result.data.qrId;
        
        // 加入WebSocket房间
        if (this.socket) {
          this.socket.emit('joinQR', this.currentQRId);
        }
        
        // 开始轮询状态（备用方案）
        this.startPolling();
        
        return result.data;
      } else {
        throw new Error(result.message);
      }
    } catch (error) {
      console.error('生成二维码失败:', error);
      this.onError(error);
      throw error;
    }
  }

  /**
   * 开始轮询状态
   */
  startPolling() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
    }
    
    this.pollingInterval = setInterval(async () => {
      try {
        await this.checkQRStatus();
      } catch (error) {
        console.error('检查二维码状态失败:', error);
      }
    }, 2000); // 每2秒检查一次
  }

  /**
   * 检查二维码状态
   */
  async checkQRStatus() {
    if (!this.currentQRId) return;
    
    try {
      const response = await fetch(`${this.apiBase}/status/${this.currentQRId}`);
      const result = await response.json();
      
      if (result.success) {
        const { status, userInfo } = result.data;
        
        if (status === 'scanned' && userInfo) {
          this.onStatusChange('scanned', { userInfo });
        } else if (status === 'confirmed') {
          // 登录成功，停止轮询
          clearInterval(this.pollingInterval);
          this.pollingInterval = null;
        } else if (status === 'expired') {
          this.onStatusChange('expired');
          this.cleanup();
        }
      }
    } catch (error) {
      console.error('检查二维码状态失败:', error);
    }
  }

  /**
   * 清理资源
   */
  cleanup() {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }
    
    if (this.socket && this.currentQRId) {
      this.socket.emit('leaveQR', this.currentQRId);
    }
    
    this.currentQRId = null;
  }

  /**
   * 销毁客户端
   */
  destroy() {
    this.cleanup();
    
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }
}

// 使用示例
const qrLoginClient = new QRLoginClient({
  onStatusChange: (status, data) => {
    console.log('状态变化:', status, data);
    
    switch (status) {
      case 'scanned':
        // 显示用户信息，等待确认
        showUserInfo(data.userInfo);
        break;
      case 'expired':
        // 显示过期提示
        showExpiredMessage();
        break;
    }
  },
  
  onLoginSuccess: (data) => {
    console.log('登录成功:', data);
    // 保存token，跳转到主页
    localStorage.setItem('token', data.token);
    window.location.href = '/dashboard';
  },
  
  onError: (error) => {
    console.error('登录错误:', error);
    showErrorMessage(error.message);
  }
});

// 初始化WebSocket连接
qrLoginClient.initWebSocket();

// 生成二维码
async function generateQR() {
  try {
    const qrData = await qrLoginClient.generateQRCode();
    // 显示二维码
    showQRCode(qrData.qrCode);
  } catch (error) {
    console.error('生成二维码失败:', error);
  }
}
```

### 2.3 移动端实现（React Native）

```javascript
/**
 * 移动端扫码登录实现
 */
import React, { useState, useEffect } from 'react';
import { View, Text, Button, Alert } from 'react-native';
import { RNCamera } from 'react-native-camera';
import AsyncStorage from '@react-native-async-storage/async-storage';

const QRLoginMobile = () => {
  const [isScanning, setIsScanning] = useState(false);
  const [scannedQR, setScannedQR] = useState(null);
  const [token, setUserToken] = useState(null);

  useEffect(() => {
    // 获取用户token
    getCurrentUserToken();
  }, []);

  const getCurrentUserToken = async () => {
    try {
      const token = await AsyncStorage.getItem('token');
      if (token) {
        setUserToken(token);
      } else {
        // 用户未登录，需要先登录
        Alert.alert('提示', '请先登录APP');
      }
    } catch (error) {
      console.error('获取用户token失败:', error);
    }
  };

  const handleBarCodeRead = async (event) => {
    if (!isScanning) return;
    
    const { data } = event;
    console.log('扫描到二维码:', data);
    
    // 解析二维码内容
    if (data.startsWith('qr://login/')) {
      const qrId = data.split('/').pop();
      setScannedQR(qrId);
      setIsScanning(false);
      
      // 显示确认对话框
      Alert.alert(
        '确认登录',
        '是否确认在PC端登录？',
        [
          { text: '取消', style: 'cancel' },
          { text: '确认', onPress: () => confirmLogin(qrId) }
        ]
      );
    } else {
      Alert.alert('错误', '无效的登录二维码');
    }
  };

  const confirmLogin = async (qrId) => {
    try {
      // 发送扫码确认请求
      const response = await fetch(`${API_BASE}/qr/scan`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ qrId, token: token })
      });
      
      const result = await response.json();
      
      if (result.success) {
        // 显示用户信息确认对话框
        Alert.alert(
          '登录确认',
          '确认使用当前账号登录PC端？',
          [
            { text: '取消', style: 'cancel' },
            { text: '确认', onPress: () => finalConfirmLogin(qrId) }
          ]
        );
      } else {
        Alert.alert('错误', result.message);
      }
    } catch (error) {
      console.error('扫码确认失败:', error);
      Alert.alert('错误', '网络请求失败');
    }
  };

  const finalConfirmLogin = async (qrId) => {
    try {
      const response = await fetch(`${API_BASE}/qr/confirm`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ qrId, token: token })
      });
      
      const result = await response.json();
      
      if (result.success) {
        Alert.alert('成功', 'PC端登录成功！');
        setScannedQR(null);
      } else {
        Alert.alert('错误', result.message);
      }
    } catch (error) {
      console.error('确认登录失败:', error);
      Alert.alert('错误', '网络请求失败');
    }
  };

  const startScanning = () => {
    if (!token) {
      Alert.alert('提示', '请先登录APP');
      return;
    }
    
    setIsScanning(true);
    setScannedQR(null);
  };

  const stopScanning = () => {
    setIsScanning(false);
  };

  return (
    <View style={{ flex: 1 }}>
      {isScanning ? (
        <View style={{ flex: 1 }}>
          <RNCamera
            style={{ flex: 1 }}
            onBarCodeRead={handleBarCodeRead}
            barCodeTypes={[RNCamera.Constants.BarCodeType.qr]}
          />
          <View style={{ 
            position: 'absolute', 
            bottom: 50, 
            left: 0, 
            right: 0, 
            alignItems: 'center' 
          }}>
            <Button title="停止扫描" onPress={stopScanning} />
          </View>
        </View>
      ) : (
        <View style={{ 
          flex: 1, 
          justifyContent: 'center', 
          alignItems: 'center',
          padding: 20 
        }}>
          <Text style={{ fontSize: 18, marginBottom: 20 }}>
            扫码登录PC端
          </Text>
          <Button title="开始扫描" onPress={startScanning} />
        </View>
      )}
    </View>
  );
};

export default QRLoginMobile;
```

## 三、轮询方案

### 3.1 服务端实现

```javascript
/**
 * 轮询方案服务端实现
 */
class PollingQRLoginServer {
  constructor() {
    this.app = express();
    this.qrCodes = new Map();
    this.setupRoutes();
  }

  setupRoutes() {
    // 生成二维码
    this.app.post('/api/qr/generate', (req, res) => {
      const qrData = this.generateQRCode();
      res.json({
        success: true,
        data: {
          qrId: qrData.qrId,
          qrCode: qrData.qrCode,
          expiresAt: qrData.expiresAt
        }
      });
    });

    // 检查二维码状态
    this.app.get('/api/qr/status/:qrId', (req, res) => {
      const { qrId } = req.params;
      const qrData = this.qrCodes.get(qrId);
      
      if (!qrData) {
        return res.json({
          success: false,
          message: '二维码不存在或已过期'
        });
      }

      res.json({
        success: true,
        data: {
          status: qrData.status,
          userInfo: qrData.userInfo,
          expiresAt: qrData.expiresAt
        }
      });
    });

    // 移动端扫码确认
    this.app.post('/api/qr/scan', (req, res) => {
      const { qrId, token } = req.body;
      const qrData = this.qrCodes.get(qrId);
      
      if (!qrData) {
        return res.json({
          success: false,
          message: '二维码不存在或已过期'
        });
      }

      try {
        const decoded = jwt.verify(token, process.env.MOBILE_JWT_SECRET);
        qrData.status = 'scanned';
        qrData.userInfo = decoded;
        qrData.scannedAt = new Date();
        
        res.json({ success: true, message: '扫码成功' });
      } catch (error) {
        res.json({
          success: false,
          message: 'Token验证失败'
        });
      }
    });

    // 移动端确认登录
    this.app.post('/api/qr/confirm', (req, res) => {
      const { qrId, token } = req.body;
      const qrData = this.qrCodes.get(qrId);
      
      if (!qrData || qrData.status !== 'scanned') {
        return res.json({
          success: false,
          message: '请先扫码'
        });
      }

      try {
        const decoded = jwt.verify(token, process.env.MOBILE_JWT_SECRET);
        
        // 生成PC端登录token
        const pcToken = jwt.sign(
          { 
            userId: decoded.userId,
            username: decoded.username,
            loginType: 'qr'
          },
          process.env.PC_JWT_SECRET,
          { expiresIn: '7d' }
        );
        
        qrData.status = 'confirmed';
        qrData.pcToken = pcToken;
        qrData.confirmedAt = new Date();
        
        res.json({ 
          success: true, 
          message: '登录成功',
          data: { token: pcToken }
        });
      } catch (error) {
        res.json({
          success: false,
          message: 'Token验证失败'
        });
      }
    });
  }

  generateQRCode() {
    const qrId = crypto.randomUUID();
    const qrCode = `qr://login/${qrId}`;
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);
    
    const qrData = {
      qrId,
      qrCode,
      status: 'pending',
      createdAt: new Date(),
      expiresAt,
      userInfo: null,
      scannedAt: null,
      confirmedAt: null,
      pcToken: null
    };
    
    this.qrCodes.set(qrId, qrData);
    
    // 设置过期清理
    setTimeout(() => {
      if (this.qrCodes.has(qrId)) {
        const qrData = this.qrCodes.get(qrId);
        if (qrData.status === 'pending') {
          qrData.status = 'expired';
        }
        this.qrCodes.delete(qrId);
      }
    }, 5 * 60 * 1000);
    
    return qrData;
  }
}
```

### 3.2 前端实现

```javascript
/**
 * 轮询方案前端实现
 */
class PollingQRLoginClient {
  constructor(options = {}) {
    this.apiBase = options.apiBase || '/api/qr';
    this.pollingInterval = options.pollingInterval || 2000;
    this.currentQRId = null;
    this.pollingTimer = null;
    this.onStatusChange = options.onStatusChange || (() => {});
    this.onLoginSuccess = options.onLoginSuccess || (() => {});
    this.onError = options.onError || (() => {});
  }

  async generateQRCode() {
    try {
      const response = await fetch(`${this.apiBase}/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      const result = await response.json();
      
      if (result.success) {
        this.currentQRId = result.data.qrId;
        this.startPolling();
        return result.data;
      } else {
        throw new Error(result.message);
      }
    } catch (error) {
      console.error('生成二维码失败:', error);
      this.onError(error);
      throw error;
    }
  }

  startPolling() {
    if (this.pollingTimer) {
      clearInterval(this.pollingTimer);
    }
    
    this.pollingTimer = setInterval(async () => {
      try {
        await this.checkQRStatus();
      } catch (error) {
        console.error('检查二维码状态失败:', error);
      }
    }, this.pollingInterval);
  }

  async checkQRStatus() {
    if (!this.currentQRId) return;
    
    try {
      const response = await fetch(`${this.apiBase}/status/${this.currentQRId}`);
      const result = await response.json();
      
      if (result.success) {
        const { status, userInfo } = result.data;
        
        if (status === 'scanned' && userInfo) {
          this.onStatusChange('scanned', { userInfo });
        } else if (status === 'confirmed') {
          // 登录成功，停止轮询
          this.stopPolling();
          this.onLoginSuccess({ userInfo });
        } else if (status === 'expired') {
          this.onStatusChange('expired');
          this.stopPolling();
        }
      }
    } catch (error) {
      console.error('检查二维码状态失败:', error);
    }
  }

  stopPolling() {
    if (this.pollingTimer) {
      clearInterval(this.pollingTimer);
      this.pollingTimer = null;
    }
  }

  cleanup() {
    this.stopPolling();
    this.currentQRId = null;
  }

  destroy() {
    this.cleanup();
  }
}
```

## 四、Server-Sent Events方案

### 4.1 服务端实现

```javascript
/**
 * SSE方案服务端实现
 */
class SSEQRLoginServer {
  constructor() {
    this.app = express();
    this.qrCodes = new Map();
    this.sseConnections = new Map();
    this.setupRoutes();
  }

  setupRoutes() {
    // 生成二维码
    this.app.post('/api/qr/generate', (req, res) => {
      const qrData = this.generateQRCode();
      res.json({
        success: true,
        data: {
          qrId: qrData.qrId,
          qrCode: qrData.qrCode,
          expiresAt: qrData.expiresAt
        }
      });
    });

    // SSE连接
    this.app.get('/api/qr/events/:qrId', (req, res) => {
      const { qrId } = req.params;
      
      // 设置SSE响应头
      res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control'
      });

      // 发送连接确认
      res.write(`data: ${JSON.stringify({ type: 'connected', qrId })}\n\n`);

      // 存储连接
      this.sseConnections.set(qrId, res);

      // 连接断开时清理
      req.on('close', () => {
        this.sseConnections.delete(qrId);
      });
    });

    // 移动端扫码确认
    this.app.post('/api/qr/scan', (req, res) => {
      const { qrId, token } = req.body;
      const qrData = this.qrCodes.get(qrId);
      
      if (!qrData) {
        return res.json({
          success: false,
          message: '二维码不存在或已过期'
        });
      }

      try {
        const decoded = jwt.verify(token, process.env.MOBILE_JWT_SECRET);
        qrData.status = 'scanned';
        qrData.userInfo = decoded;
        qrData.scannedAt = new Date();
        
        // 通过SSE推送扫码事件
        this.pushSSEEvent(qrId, {
          type: 'scanned',
          userInfo: decoded,
          scannedAt: qrData.scannedAt
        });
        
        res.json({ success: true, message: '扫码成功' });
      } catch (error) {
        res.json({
          success: false,
          message: 'Token验证失败'
        });
      }
    });

    // 移动端确认登录
    this.app.post('/api/qr/confirm', (req, res) => {
      const { qrId, token } = req.body;
      const qrData = this.qrCodes.get(qrId);
      
      if (!qrData || qrData.status !== 'scanned') {
        return res.json({
          success: false,
          message: '请先扫码'
        });
      }

      try {
        const decoded = jwt.verify(token, process.env.MOBILE_JWT_SECRET);
        
        // 生成PC端登录token
        const pcToken = jwt.sign(
          { 
            userId: decoded.userId,
            username: decoded.username,
            loginType: 'qr'
          },
          process.env.PC_JWT_SECRET,
          { expiresIn: '7d' }
        );
        
        qrData.status = 'confirmed';
        qrData.pcToken = pcToken;
        qrData.confirmedAt = new Date();
        
        // 通过SSE推送登录成功事件
        this.pushSSEEvent(qrId, {
          type: 'loginSuccess',
          token: pcToken,
          userInfo: decoded,
          confirmedAt: qrData.confirmedAt
        });
        
        // 清理二维码数据
        setTimeout(() => {
          this.qrCodes.delete(qrId);
          this.sseConnections.delete(qrId);
        }, 5000);
        
        res.json({ success: true, message: '登录成功' });
      } catch (error) {
        res.json({
          success: false,
          message: 'Token验证失败'
        });
      }
    });
  }

  pushSSEEvent(qrId, data) {
    const connection = this.sseConnections.get(qrId);
    if (connection) {
      connection.write(`data: ${JSON.stringify(data)}\n\n`);
    }
  }

  generateQRCode() {
    const qrId = crypto.randomUUID();
    const qrCode = `qr://login/${qrId}`;
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000);
    
    const qrData = {
      qrId,
      qrCode,
      status: 'pending',
      createdAt: new Date(),
      expiresAt,
      userInfo: null,
      scannedAt: null,
      confirmedAt: null,
      pcToken: null
    };
    
    this.qrCodes.set(qrId, qrData);
    
    // 设置过期清理
    setTimeout(() => {
      if (this.qrCodes.has(qrId)) {
        const qrData = this.qrCodes.get(qrId);
        if (qrData.status === 'pending') {
          qrData.status = 'expired';
          this.pushSSEEvent(qrId, { type: 'expired' });
        }
        this.qrCodes.delete(qrId);
        this.sseConnections.delete(qrId);
      }
    }, 5 * 60 * 1000);
    
    return qrData;
  }
}
```

### 4.2 前端实现

```javascript
/**
 * SSE方案前端实现
 */
class SSEQRLoginClient {
  constructor(options = {}) {
    this.apiBase = options.apiBase || '/api/qr';
    this.currentQRId = null;
    this.eventSource = null;
    this.onStatusChange = options.onStatusChange || (() => {});
    this.onLoginSuccess = options.onLoginSuccess || (() => {});
    this.onError = options.onError || (() => {});
  }

  async generateQRCode() {
    try {
      const response = await fetch(`${this.apiBase}/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      const result = await response.json();
      
      if (result.success) {
        this.currentQRId = result.data.qrId;
        this.connectSSE();
        return result.data;
      } else {
        throw new Error(result.message);
      }
    } catch (error) {
      console.error('生成二维码失败:', error);
      this.onError(error);
      throw error;
    }
  }

  connectSSE() {
    if (!this.currentQRId) return;
    
    this.eventSource = new EventSource(`${this.apiBase}/events/${this.currentQRId}`);
    
    this.eventSource.onopen = () => {
      console.log('SSE连接已建立');
    };
    
    this.eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.handleSSEEvent(data);
      } catch (error) {
        console.error('解析SSE数据失败:', error);
      }
    };
    
    this.eventSource.onerror = (error) => {
      console.error('SSE连接错误:', error);
      this.onError(error);
    };
  }

  handleSSEEvent(data) {
    switch (data.type) {
      case 'connected':
        console.log('SSE连接确认');
        break;
      case 'scanned':
        console.log('二维码已扫描:', data);
        this.onStatusChange('scanned', data);
        break;
      case 'loginSuccess':
        console.log('登录成功:', data);
        this.onLoginSuccess(data);
        this.cleanup();
        break;
      case 'expired':
        console.log('二维码已过期');
        this.onStatusChange('expired');
        this.cleanup();
        break;
    }
  }

  cleanup() {
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }
    this.currentQRId = null;
  }

  destroy() {
    this.cleanup();
  }
}
```

## 五、安全考虑

### 5.1 安全措施

```javascript
/**
 * 扫码登录安全增强
 */
class SecureQRLoginServer {
  constructor() {
    this.app = express();
    this.qrCodes = new Map();
    this.failedAttempts = new Map();
    this.setupSecurity();
  }

  setupSecurity() {
    // 请求频率限制
    this.app.use('/api/qr', this.rateLimitMiddleware());
    
    // IP白名单
    this.app.use('/api/qr', this.ipWhitelistMiddleware());
    
    // 请求签名验证
    this.app.use('/api/qr', this.signatureMiddleware());
  }

  rateLimitMiddleware() {
    return (req, res, next) => {
      const clientId = req.ip;
      const now = Date.now();
      const windowMs = 60000; // 1分钟
      const maxRequests = 10; // 最多10次请求
      
      if (!this.requestCounts) {
        this.requestCounts = new Map();
      }
      
      const clientRequests = this.requestCounts.get(clientId) || [];
      const recentRequests = clientRequests.filter(time => now - time < windowMs);
      
      if (recentRequests.length >= maxRequests) {
        return res.status(429).json({
          success: false,
          message: '请求过于频繁，请稍后再试'
        });
      }
      
      recentRequests.push(now);
      this.requestCounts.set(clientId, recentRequests);
      
      next();
    };
  }

  ipWhitelistMiddleware() {
    return (req, res, next) => {
      const allowedIPs = process.env.ALLOWED_IPS?.split(',') || [];
      const clientIP = req.ip;
      
      if (allowedIPs.length > 0 && !allowedIPs.includes(clientIP)) {
        return res.status(403).json({
          success: false,
          message: 'IP地址不在白名单中'
        });
      }
      
      next();
    };
  }

  signatureMiddleware() {
    return (req, res, next) => {
      const signature = req.headers['x-signature'];
      const timestamp = req.headers['x-timestamp'];
      const nonce = req.headers['x-nonce'];
      
      if (!signature || !timestamp || !nonce) {
        return res.status(400).json({
          success: false,
          message: '缺少必要的签名参数'
        });
      }
      
      // 验证时间戳（防止重放攻击）
      const now = Date.now();
      const requestTime = parseInt(timestamp);
      
      if (Math.abs(now - requestTime) > 300000) { // 5分钟
        return res.status(400).json({
          success: false,
          message: '请求时间戳无效'
        });
      }
      
      // 验证签名
      const expectedSignature = this.generateSignature(req.body, timestamp, nonce);
      
      if (signature !== expectedSignature) {
        return res.status(401).json({
          success: false,
          message: '签名验证失败'
        });
      }
      
      next();
    };
  }

  generateSignature(body, timestamp, nonce) {
    const secret = process.env.API_SECRET;
    const data = JSON.stringify(body) + timestamp + nonce;
    return crypto.createHmac('sha256', secret).update(data).digest('hex');
  }

  // 二维码加密
  generateSecureQRCode() {
    const qrId = crypto.randomUUID();
    const payload = {
      qrId,
      timestamp: Date.now(),
      nonce: crypto.randomBytes(16).toString('hex')
    };
    
    const encryptedPayload = this.encryptPayload(payload);
    const qrCode = `qr://login/${encryptedPayload}`;
    
    const qrData = {
      qrId,
      qrCode,
      status: 'pending',
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 5 * 60 * 1000),
      userInfo: null,
      scannedAt: null,
      confirmedAt: null,
      pcToken: null
    };
    
    this.qrCodes.set(qrId, qrData);
    
    return qrData;
  }

  encryptPayload(payload) {
    const cipher = crypto.createCipher('aes-256-cbc', process.env.QR_SECRET);
    let encrypted = cipher.update(JSON.stringify(payload), 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
  }

  decryptPayload(encryptedPayload) {
    try {
      const decipher = crypto.createDecipher('aes-256-cbc', process.env.QR_SECRET);
      let decrypted = decipher.update(encryptedPayload, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
      return JSON.parse(decrypted);
    } catch (error) {
      throw new Error('二维码解密失败');
    }
  }
}
```

## 六、最佳实践建议

### 6.1 性能优化

1. **WebSocket连接池**：合理管理连接数量
2. **二维码过期机制**：及时清理过期数据
3. **请求频率限制**：防止恶意请求
4. **缓存策略**：合理使用Redis缓存

### 6.2 安全考虑

1. **Token验证**：严格验证移动端token
2. **请求签名**：防止重放攻击
3. **IP白名单**：限制访问来源
4. **二维码加密**：保护二维码内容

### 6.3 用户体验

1. **实时反馈**：及时显示状态变化
2. **错误处理**：友好的错误提示
3. **超时处理**：合理的超时机制
4. **重试机制**：网络异常时的重试

这套完整的扫码登录方案涵盖了从基础实现到安全增强的各个方面，可以根据项目需求选择合适的实现方式！
