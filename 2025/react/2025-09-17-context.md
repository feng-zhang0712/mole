# React Context

## Context 的问题

React Context 提供了一种跨组件通信的解决方案，但是如果使用不当，当 Context 的值发生变化时，所有消费该 Context 的组件都会重新渲染，即使它们只使用了 Context 中的部分数据。

```javascript
const AppContext = createContext();

function App() {
  const [user, setUser] = useState({ name: 'John', age: 25 });
  const [theme, setTheme] = useState('light');
  
  // 每次 user 或 theme 变化，所有消费者都会重新渲染
  const value = { user, theme, setUser, setTheme };
  
  return (
    <AppContext.Provider value={value}>
      <Header />
      <Main />
      <Footer />
    </AppContext.Provider>
  );
}
```

这个问题常见于下面这些场景。

- 单一 Context 包含多个不相关的状态。
- Context 中包含频繁更新的状态。
- Context 值是一个大型对象，即使只有部分属性变化。
- 每次渲染都创建新的函数引用，从而导致函数引用变化。

## 解决方案

### Context 分离策略

将不同的状态分离到不同的 Context 中，避免不相关的状态变化影响其他组件。

```javascript
const UserContext = createContext();
const ThemeContext = createContext();

function App() {
  const [user, setUser] = useState({ name: 'John', age: 25 });
  const [theme, setTheme] = useState('light');
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <ThemeContext.Provider value={{ theme, setTheme }}>
        <Header />
        <Main />
        <Footer />
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}

// 只有使用 UserContext 的组件会在 user 变化时重新渲染
function Header() {
  const { user } = useContext(UserContext);
  return <header>Welcome, {user.name}</header>;
}

// 只有使用 ThemeContext 的组件会在 theme 变化时重新渲染
function Main() {
  const { theme } = useContext(ThemeContext);
  return <main className={theme}>Main content</main>;
}
```

### 使用 useMemo 优化 Context 值

使用 `useMemo` 缓存 Context 的值，避免每次渲染都创建新的对象。

```javascript
function App() {
  const [user, setUser] = useState({ name: 'John', age: 25 });
  const [theme, setTheme] = useState('light');
  
  const userValue = useMemo(() => ({ user, setUser }), [user]);
  const themeValue = useMemo(() => ({ theme, setTheme }), [theme]);
  
  return (
    <UserContext.Provider value={userValue}>
      <ThemeContext.Provider value={themeValue}>
        <Header />
        <Main />
        <Footer />
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}
```

### 使用 useCallback 优化函数引用

使用 `useCallback` 缓存函数引用，避免每次渲染都创建新的函数。

```javascript
function App() {
  const [user, setUser] = useState({ name: 'John', age: 25 });
  
  const updateUser = useCallback((newUser) => {
    setUser(newUser);
  }, []);
  
  const userValue = useMemo(() => ({ user, updateUser }), [user, updateUser]);
  
  return (
    <UserContext.Provider value={userValue}>
      <Header />
      <Main />
      <Footer />
    </UserContext.Provider>
  );
}
```

### 使用 React.memo 优化消费者组件

使用 `React.memo` 包装消费 Context 的组件，避免不必要的重新渲染。

```javascript
const Header = React.memo(() => {
  const { user } = useContext(UserContext);
  return <header>Welcome, {user.name}</header>;
});

const Main = React.memo(() => {
  const { theme } = useContext(ThemeContext);
  return <main className={theme}>Main content</main>;
});
```

### 使用 useReducer 管理复杂状态

对于复杂的状态逻辑，使用 `useReducer` 替代多个 `useState`。

```javascript
// 使用 useReducer 管理复杂状态
const initialState = {
  user: { name: 'John', age: 25 },
  theme: 'light',
  loading: false,
  error: null
};

function appReducer(state, action) {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    case 'SET_LOADING':
      return { ...state, loading: action.payload };
    case 'SET_ERROR':
      return { ...state, error: action.payload };
    default:
      return state;
  }
}

function App() {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  const value = useMemo(() => ({ state, dispatch }), [state]);
  
  return (
    <AppContext.Provider value={value}>
      <Header />
      <Main />
      <Footer />
    </AppContext.Provider>
  );
}
```

### 使用自定义 Hook 封装 Context 逻辑

创建自定义 Hook 来封装 Context 的使用逻辑，提供更好的类型安全和复用性。

```javascript
function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within UserProvider');
  }
  return context;
}

function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

function Header() {
  const { user } = useUser();
  return <header>Welcome, {user.name}</header>;
}

function Main() {
  const { theme } = useTheme();
  return <main className={theme}>Main content</main>;
}
```

### 使用 Context Selector 模式

实现一个 Context Selector 模式，只订阅 Context 中的特定部分。

```javascript
// Context Selector Hook
function useContextSelector(context, selector) {
  const contextValue = useContext(context);
  const selectedValue = useMemo(() => selector(contextValue), [contextValue, selector]);
  
  return selectedValue;
}

// 使用 Context Selector
function Header() {
  // 只订阅 user.name，当其他属性变化时不会重新渲染
  const userName = useContextSelector(UserContext, (state) => state.user.name);
  return <header>Welcome, {userName}</header>;
}

function Main() {
  // 只订阅 theme，当 user 变化时不会重新渲染
  const theme = useContextSelector(ThemeContext, (state) => state.theme);
  return <main className={theme}>Main content</main>;
}
```

## 三、高级优化技巧

### 使用 Context 组合模式

将多个相关的 Context 组合在一起，提供更好的开发体验。

```javascript
// Context 组合
function AppProvider({ children }) {
  const [user, setUser] = useState({ name: 'John', age: 25 });
  const [theme, setTheme] = useState('light');
  
  const userValue = useMemo(() => ({ user, setUser }), [user]);
  const themeValue = useMemo(() => ({ theme, setTheme }), [theme]);
  
  return (
    <UserContext.Provider value={userValue}>
      <ThemeContext.Provider value={themeValue}>
        {children}
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}

// 使用组合的 Provider
function App() {
  return (
    <AppProvider>
      <Header />
      <Main />
      <Footer />
    </AppProvider>
  );
}
```

### 使用 Context 中间件模式

实现一个中间件系统来处理 Context 的副作用。

```javascript
// Context 中间件
function createContextMiddleware(context, middleware) {
  return function ContextProvider({ children }) {
    const [state, setState] = useState(context.initialState);
    
    const enhancedSetState = useCallback((newState) => {
      const result = middleware(state, newState);
      setState(result);
    }, [state, middleware]);
    
    const value = useMemo(() => ({ state, setState: enhancedSetState }), [state, enhancedSetState]);
    
    return (
      <context.Provider value={value}>
        {children}
      </context.Provider>
    );
  };
}

// 使用中间件
const userMiddleware = (state, newState) => {
  // 添加日志
  console.log('User state changed:', newState);
  return newState;
};

const UserProvider = createContextMiddleware(UserContext, userMiddleware);
```

### 使用 Context 缓存策略

实现一个缓存策略来避免重复计算。

```javascript
// Context 缓存
function createCachedContext(initialState, cacheKey) {
  const Context = createContext();
  
  function Provider({ children }) {
    const [state, setState] = useState(() => {
      const cached = localStorage.getItem(cacheKey);
      return cached ? JSON.parse(cached) : initialState;
    });
    
    useEffect(() => {
      localStorage.setItem(cacheKey, JSON.stringify(state));
    }, [state]);
    
    const value = useMemo(() => ({ state, setState }), [state]);
    
    return (
      <Context.Provider value={value}>
        {children}
      </Context.Provider>
    );
  }
  
  return { Context, Provider };
}

// 使用缓存的 Context
const { Context: UserContext, Provider: UserProvider } = createCachedContext(
  { name: 'John', age: 25 },
  'user-cache'
);
```
