# React 事件系统

## 概述

React 的事件系统是一个**合成事件系统**，是对原生 DOM 事件的一层封装。React 通过**事件委托**机制，将所有事件监听器绑定到**根节点**（`ReactDOM.createRoot()` 的参数节点），而不是绑定到具体的 DOM 元素上，这种设计带来很多优势。

- 跨浏览器兼容性。合成事件能够处理过时的事件 API，同时为浏览器不支持的 API 提供支持，统一了不同浏览器事件之间的差异。
- 性能优化。事件委托减少了内存占用，批量更新避免了频繁渲染。
- 开发体验提升。合成事件提供了统一的 API 接口。

下面列出了 React 事件系统的核心组件架构。

```javascript
const EventSystem = {
  // 事件注册表
  EventRegistry: {
    allNativeEvents: Set<DOMEventName>,
    registrationNameDependencies: Map<string, Array<DOMEventName>>,
    topLevelEventsToReactNames: Map<DOMEventName, string>
  },
  
  // 事件插件系统
  EventPlugins: [
    SimpleEventPlugin,      // 处理大部分标准事件
    EnterLeaveEventPlugin,  // 处理 mouseenter/mouseleave
    ChangeEventPlugin,      // 处理复杂的 change 事件
    SelectEventPlugin,      // 处理 select 事件
    BeforeInputEventPlugin, // 处理输入前事件
    FormActionEventPlugin   // 处理表单动作事件
  ],
  
  // 合成事件构造器
  SyntheticEvents: {
    SyntheticEvent,
    SyntheticKeyboardEvent,
    SyntheticMouseEvent,
    SyntheticFocusEvent,
    SyntheticTouchEvent,
    // ... 更多特定类型的合成事件
  },
  
  // 事件分发器
  EventDispatcher: {
    dispatchEvent,
    dispatchEventForPluginEventSystem,
    processDispatchQueue
  }
};
```

## 事件系统初始化

### 事件注册表初始化

React 在模块加载时开始构建事件注册表。

```javascript
// react/packages/react-dom-bindings/src/events/EventRegistry.js

// 全局事件注册表
export const allNativeEvents: Set<DOMEventName> = new Set(); 

// React 事件名到原生事件名的映射
export const registrationNameDependencies: {
  [registrationName: string]: Array<DOMEventName>,
} = {};

// 原生事件名到 React 事件名的映射
export const topLevelEventsToReactNames: Map<DOMEventName, string | null> = new Map();

// 注册双阶段事件（捕获 + 冒泡）
export function registerTwoPhaseEvent(
  registrationName: string,
  dependencies: Array<DOMEventName>,
): void {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + 'Capture', dependencies);
}

export function registerDirectEvent(
  registrationName: string,
  dependencies: Array<DOMEventName>,
) {
  // 建立 React 事件名到原生事件名的映射
  registrationNameDependencies[registrationName] = dependencies;

  // 将所有依赖的原生事件添加到全局集合
  for (let i = 0; i < dependencies.length; i++) {
    allNativeEvents.add(dependencies[i]);
  }
}
```

- `allNativeEvents` 存放所有原生事件的集合。
- `registerTwoPhaseEvent` 用于注册某个事件，包括捕获阶段和冒泡阶段。
- `registerDirectEvent` 将事件添加到 `allNativeEvents` 集合中，其中 `registrationNameDependencies` 中存放着合成事件到原生事件名称的映射。

```javascript
registrationNameDependencies = {
  'onClick': ['click'],
  'onChange': ['change', 'input'],
  'onKeyDown': ['keydown'],
  'onMouseEnter': ['mouseenter'],
  'onMouseLeave': ['mouseleave'],
  // ...
}
```

### 事件插件注册

每个事件插件都有自己的注册逻辑。

```javascript
SimpleEventPlugin.registerEvents();
EnterLeaveEventPlugin.registerEvents();
ChangeEventPlugin.registerEvents();
SelectEventPlugin.registerEvents();
BeforeInputEventPlugin.registerEvents();
if (enableScrollEndPolyfill) {
  ScrollEndEventPlugin.registerEvents();
}
```

不同的插件负责注册不同的事件，下面是 `SimpleEventPlugin` 的注册事件，这个插件负责注册大部分的原生事件。

```javascript
// react/packages/react-dom-bindings/src/events/DOMEventProperties.js

const simpleEventPluginEvents = [
  'abort', 'click', 'drag', 'drop', 'resize', 'scroll', 'wheel',
  // ...
];

// 注册简单事件的函数
function registerSimpleEvent(domEventName: DOMEventName, reactName: string) {
  topLevelEventsToReactNames.set(domEventName, reactName);
  registerTwoPhaseEvent(reactName, [domEventName]);
}

// `SimpleEventPlugin.registerEvents()` 方法就是下面的方法
export function registerSimpleEvents() {
  for (let i = 0; i < simpleEventPluginEvents.length; i++) {
    const eventName = ((simpleEventPluginEvents[i]: any): string);
    const domEventName = ((eventName.toLowerCase(): any): DOMEventName);
    const capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
    registerSimpleEvent(domEventName, 'on' + capitalizedEvent);
  }

  // 特殊事件注册
  registerSimpleEvent(ANIMATION_END, 'onAnimationEnd');
  registerSimpleEvent(ANIMATION_ITERATION, 'onAnimationIteration');
  registerSimpleEvent(ANIMATION_START, 'onAnimationStart');
  registerSimpleEvent('dblclick', 'onDoubleClick');
  registerSimpleEvent('focusin', 'onFocus');
  registerSimpleEvent('focusout', 'onBlur');

  // ...
}
```

下面是 `ChangeEventPlugin` 插件的注册事件。

```javascript
// react/packages/react-dom-bindings/src/events/plugins/ChangeEventPlugin.js

function registerEvents() {
  // onChange 事件依赖多个原生事件，这意味着当任何一个依赖事件触发时，都可能产生 onChange 合成事件
  registerTwoPhaseEvent('onChange', [
    'change', 'click', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'selectionchange',
  ]);
}
```

从上面的注册过程可以看出，大部分合成事件和原生事件，都是一对一的关系，但是像 `onChange` 这样的合成事件，对应多个原生事件。

## 合成事件的创建与标准化

### 合成事件工厂函数

React 采用工厂模式来创建不同类型的合成事件。

```javascript
// react/packages/react-dom-bindings/src/events/SyntheticEvent.js

// 事件接口定义
const EventInterface = {
  eventPhase: 0, // 事件阶段
  bubbles: 0, // 是否冒泡
  cancelable: 0, // 是否可取消
  defaultPrevented: 0, // 是否阻止默认行为
  isTrusted: 0, // 是否可信事件
  timeStamp: function (event: {[propName: string]: mixed}) {
    return event.timeStamp || Date.now();
  },
};

// 合成事件构造函数
function createSyntheticEvent(Interface: EventInterfaceType) {
  function SyntheticBaseEvent(
    reactName: string | null,
    reactEventType: string,
    targetInst: Fiber | null,
    nativeEvent: {[propName: string]: mixed, ...},
    nativeEventTarget: null | EventTarget,
  ) {
    //...
  }

  assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      // ...
    },
    stopPropagation: function () {
      // ...
    },

    isPersistent: functionThatReturnsTrue,
    persist: function () {
      // React 17+ 中，事件不再被池化，这个方法变成空操作
    },
  });

  return SyntheticBaseEvent;
}
```

`SyntheticBaseEvent` 构造函数用于创建合成事件对象。

```javascript
function SyntheticBaseEvent(
  reactName: string | null,
  reactEventType: string,
  targetInst: Fiber | null,
  nativeEvent: {[propName: string]: mixed, ...},
  nativeEventTarget: null | EventTarget,
) {
  this._reactName = reactName; // React 事件名称（如 onClick）
  this._targetInst = targetInst; // 目标 Fiber 节点
  this.type = reactEventType; // 事件类型
  this.nativeEvent = nativeEvent; // 原生事件对象
  this.target = nativeEventTarget; // 事件目标
  this.currentTarget = null; // 当前处理事件的元素（绑定事件处理器的元素）

  for (const propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    const normalize = Interface[propName];
    // 使用规范化函数处理属性或者直接将原生事件属性复制到合成事件
    this[propName] = normalize ? normalize(nativeEvent) : nativeEvent[propName];
  }

  // 处理默认阻止状态
  const defaultPrevented =
    nativeEvent.defaultPrevented != null
      ? nativeEvent.defaultPrevented
      : nativeEvent.returnValue === false;
  this.isDefaultPrevented = defaultPrevented ? functionThatReturnsTrue : functionThatReturnsFalse;
  this.isPropagationStopped = functionThatReturnsFalse;
  
  return this;
}
```

不难看出，合成事件对象主要执行了下面这些操作。

- 将事件类型、名称、目标节点信息挂载到合成事件对象。
- 将原生对象以及原生事件阻止默认行为的结果挂载到合成事件对象。
- 执行事件的规范化，将不同浏览器中不一致的事件 API 统一为标准格式，同时兼容过时的 API，为浏览器不支持的 API 提供 Polyfill。

注意，`SyntheticBaseEvent` 构造方法中的 `normalize` 方法，用于执行事件 API 的规范化。所谓规范化，是指 React 将不同浏览器中不一致的事件 API 统一为标准格式的过程。这是 React 合成事件系统最重要的特性之一。

比如，经过规范化处理后，如果按下键盘上的左方向键，React 最终会达成这样的效果。

```javascript
// 不同浏览器中的原始值
// Chrome: event.key = "ArrowLeft"
// Firefox: event.key = "Left" (旧版本)
// IE: event.key = undefined, event.keyCode = 37

// React 规范化后的统一值
// 所有浏览器: event.key = "ArrowLeft"

// 经过上面的处理，就不需要考虑浏览器差异
function handleKeyPress(event) {
  if (event.key === 'ArrowLeft') {
    // 这个条件在所有浏览器中都成立
    console.log('用户按下了方向左键键');
  }
}
```

从上面 React 对 `KeyboardEventInterface` 接口的处理不难看出，React 消除了事件 API 在不同浏览器之间的差异，同时对过时的以及浏览器不支持的 API 提供了支持。这使得开发人员在基于 React 开发时，能够获得一致的开发体验。

```javascript
assign(SyntheticBaseEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    const event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = functionThatReturnsTrue;
  },

  stopPropagation: function () {
    const event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // IE 兼容性处理
      // ChangeEventPlugin 为 IE 注册了 "propertychange" 事件
      // 该事件不支持冒泡或取消，任何对 cancelBubble 的引用都会抛出 "Member not found"
      // 使用 typeof 检查 "unknown" 可以避免这个问题
      event.cancelBubble = true;
    }

    this.isPropagationStopped = functionThatReturnsTrue;
  },
});
```

合成事件的核心方法就两个：`preventDefault` 和 `stopPropagation`，前者用于阻止默认事件，后者阻止向上冒泡，他们分别执行了相应的原生事件方法。

### 键盘事件的标准化处理

`EventInterfaceType` 定义了多种不同类型的事件接口，`KeyboardEventInterface` 便是其中之一，下面列出了它的定义。

```javascript
// react/packages/react-dom-bindings/src/events/SyntheticEvent.js

// 规范化过时的 HTML5 `key` 值
const normalizeKey = {
  Esc: 'Escape', // 旧标准 -> 新标准
  Spacebar: ' ', // 空格键的旧表示 -> 新表示
  Left: 'ArrowLeft', // 方向键的旧表示
  MozPrintableKey: 'Unidentified', // Firefox 的特殊值
  // ...
};

// 从传统的 `keyCode` 到 HTML5 `key` 的转换映射
const translateToKey = {
  '8': 'Backspace', // keyCode 8 -> 标准键名
  '9': 'Tab', // keyCode 9 -> 标准键名
  // ...
  '37': 'ArrowLeft', // keyCode 37 -> 标准键名
  // ...
};

const KeyboardEventInterface = {
  ...UIEventInterface,
  key: getEventKey,
  code: 0,
  // ...
  getModifierState: getEventModifierState,
  charCode: function (event: {[propName: string]: mixed}) {
    if (event.type === 'keypress') {
      return getEventCharCode(
        event,
      );
    }
    return 0;
  },
  keyCode: function (event: {[propName: string]: mixed}) {
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event: {[propName: string]: mixed}) {
    if (event.type === 'keypress') {
      return getEventCharCode(
        event,
      );
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
};

function getEventKey(nativeEvent: {[propName: string]: mixed}) {
  // 如果浏览器支持 key 属性
  if (nativeEvent.key) {
    // FireFox 实现了 `key` 但对于所有可打印字符都返回 `MozPrintableKey`
    // 这被标准化为 `Unidentified`，所以代码需要忽略这种情况
    const key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // 如果浏览器不支持 `key` 属性，则为它添加 Polyfill
  if (nativeEvent.type === 'keypress') {
    const charCode = getEventCharCode(nativeEvent);
    // Enter 键的特殊处理
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }

  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // 虽然用户键盘布局决定了每个 `keyCode` 值的实际含义，但是功能键（如 F1、F2 等）几乎都有通用的标准值
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }

  return '';
}
```

之后，各种合成事件都通过 `createSyntheticEvent` 创建，比如下面是键盘合成事件 `SyntheticKeyboardEvent` 的创建。

```javascript
const SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
```

这个过程还包括其他事件的标准化处理，比如鼠标事件的标准化处理 `SyntheticMouseEvent`，流程跟上面的键盘事件的标准化处理类似，这里不做过多介绍。

## 事件委托机制

### 根节点监听设置

React 将所有事件监听器绑定到根容器节点。

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js

// 媒体事件类型（这些事件不冒泡）
export const mediaEventTypes: Array<DOMEventName> = [
  'abort', 'canplay', 'ended', 'error', 'pause', 'play', 'playing', 'progress',
  // ...
];

// 非委托事件（直接绑定到目标元素）
export const nonDelegatedEvents: Set<DOMEventName> = new Set([
  'beforetoggle', 'cancel', 'close', 'invalid', 'load', 'scroll', 'scrollend', 'toggle',
  ...mediaEventTypes,
]);

// 监听标记，防止重复绑定
const listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);

// 监听所有支持的原生事件
export function listenToAllSupportedEvents(rootContainerElement: EventTarget) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = true;
    allNativeEvents.forEach(domEventName => {
      // selectionchange 事件特殊处理，因为它不冒泡
      if (domEventName !== 'selectionchange') {
        // 非委托事件只绑定冒泡监听器
        if (!nonDelegatedEvents.has(domEventName)) {
          listenToNativeEvent(domEventName, false, rootContainerElement);
        }
        // 所有事件都绑定捕获监听器
        listenToNativeEvent(domEventName, true, rootContainerElement);
      }
    });

    // 特殊处理 selectionchange 事件，绑定到 document 上
    const ownerDocument =
      rootContainerElement.nodeType === DOCUMENT_NODE
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    if (ownerDocument !== null) {
      if (!ownerDocument[listeningMarker]) {
        ownerDocument[listeningMarker] = true;
        listenToNativeEvent('selectionchange', false, ownerDocument);
      }
    }
  }
}
```

这个方法执行的操作包括：

- 遍历 `allNativeEvents` 集合中的所有原生。对于可冒泡的事件，设置冒泡阶段监听。全部事件都绑定捕获阶段监听（`selectionchange` 事件除外）。
- 将 `selectionchange` 事件绑定到 document 节点。

rootContainerElement 作为代理，基于事件冒泡机制，而 `selectionchange` 事件不会冒泡，所以无法绑定到 rootContainer。另外，`selectionchange` 事件是全局性的，与当前焦点元素相关，无论用户在哪个输入框中操作，都会触发 document 上的 `selectionchange` 事件，也就是说，通常不需要知道具体是哪个元素的选择变了。

### 事件监听器的创建和绑定

`addTrappedEventListener` 方法执行最后具体的事件注册操作。这个方法会根据事件是否是被动类型（即 `passive`）、是否注册在捕获阶段等信息，执行原生的 `addEventListener` 方法。

```javascript
export function listenToNativeEvent(
  domEventName: DOMEventName,
  isCapturePhaseListener: boolean,
  target: EventTarget,
): void {
  let eventSystemFlags = 0;
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE;
  }

  addTrappedEventListener(
    target,
    domEventName,
    eventSystemFlags,
    isCapturePhaseListener,
  );
}

function addTrappedEventListener(
  targetContainer: EventTarget,
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  isCapturePhaseListener: boolean,
  isDeferredListenerForLegacyFBSupport?: boolean,
) {
  // 创建带优先级的事件监听器包装器
  let listener = createEventListenerWrapperWithPriority(
    targetContainer,
    domEventName,
    eventSystemFlags,
  );

  // 处理被动监听器（passive listeners）
  let isPassiveListener: void | boolean = undefined;
  if (passiveBrowserEventsSupported) {
    if (
      domEventName === 'touchstart' ||
      domEventName === 'touchmove' ||
      domEventName === 'wheel'
    ) {
      isPassiveListener = true;
    }
  }

  // 根据阶段和被动性选择不同的绑定方式
  if (isCapturePhaseListener) {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(
        targetContainer,
        domEventName,
        listener,
        isPassiveListener,
      );
    } else {
      unsubscribeListener = addEventCaptureListener(
        targetContainer,
        domEventName,
        listener,
      );
    }
  } else {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(
        targetContainer,
        domEventName,
        listener,
        isPassiveListener,
      );
    } else {
      unsubscribeListener = addEventBubbleListener(
        targetContainer,
        domEventName,
        listener,
      );
    }
  }
}
```

### 实际的 DOM 事件绑定

```javascript
// react/packages/react-dom-bindings/src/events/EventListener.js

export function addEventBubbleListener(
  target: EventTarget,
  eventType: string,
  listener: Function,
): Function {
  target.addEventListener(eventType, listener, false);
  return listener;
}

export function addEventCaptureListener(
  target: EventTarget,
  eventType: string,
  listener: Function,
): Function {
  target.addEventListener(eventType, listener, true);
  return listener;
}

export function addEventCaptureListenerWithPassiveFlag(
  target: EventTarget,
  eventType: string,
  listener: Function,
  passive: boolean,
): Function {
  target.addEventListener(eventType, listener, {
    capture: true,
    passive,
  });
  return listener;
}

export function addEventBubbleListenerWithPassiveFlag(
  target: EventTarget,
  eventType: string,
  listener: Function,
  passive: boolean,
): Function {
  target.addEventListener(eventType, listener, {
    passive,
  });
  return listener;
}
```

## 事件优先级系统

### 优先级定义

React 根据事件类型定义了不同的优先级，下面列出了 React 合成事件的优先级分类。

```javascript
// react/packages/react-reconciler/src/ReactEventPriorities.js

export const NoEventPriority: EventPriority = NoLane;           // 无优先级
export const DiscreteEventPriority: EventPriority = SyncLane;   // 离散事件优先级（最高）
export const ContinuousEventPriority: EventPriority = InputContinuousLane; // 连续事件优先级
export const DefaultEventPriority: EventPriority = DefaultLane; // 默认事件优先级
export const IdleEventPriority: EventPriority = IdleLane;       // 空闲事件优先级（最低）
```

- `DiscreteEventPriority` 离散事件。拥有最高优先级，这类事件会立即处理且不可批处理。通常是由用户直接触发的、有明确意图的交互事件，比如 `click`、`change`、`drop` 等事件。
- `ContinuousEventPriority` 连续事件。中等优先级，这类事件可以中断低优先级任务的执行，可以被批处理。通常是用户直接触发的、连续的事件，比如 `mousemove`、`drag`、`scroll` 等事件。
- `DefaultEventPriority` 默认事件。低优先级，这类事件可被中断、可被批处理。通常是非用户直接触发的背景事件，比如 `load` 事件。

```javascript
// react/packages/react-dom-bindings/src/events/ReactDOMEventListener.js

// 获取事件优先级
export function getEventPriority(domEventName: DOMEventName): EventPriority {
  switch (domEventName) {
    // 离散事件 - 最高优先级
    case 'beforetoggle':
    case 'cancel':
    case 'click':
    case 'close':
    case 'contextmenu':
    case 'copy':
    case 'cut':
    case 'auxclick':
    case 'dblclick':
    case 'dragend':
    case 'dragstart':
    case 'drop':
    case 'focusin':
    case 'focusout':
    case 'input':
    case 'invalid':
    case 'keydown':
    case 'keypress':
    case 'keyup':
    case 'mousedown':
    case 'mouseup':
    case 'paste':
    case 'pause':
    case 'play':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointerup':
    case 'ratechange':
    case 'reset':
    case 'resize':
    case 'seeked':
    case 'submit':
    case 'toggle':
    case 'touchcancel':
    case 'touchend':
    case 'touchstart':
    case 'volumechange':
    case 'change':
    case 'selectionchange':
    case 'textInput':
    case 'compositionstart':
    case 'compositionend':
    case 'compositionupdate':
    case 'beforeblur':
    case 'afterblur':
    case 'beforeinput':
    case 'blur':
    case 'fullscreenchange':
    case 'focus':
    case 'hashchange':
    case 'popstate':
    case 'select':
    case 'selectstart':
      return DiscreteEventPriority;

    // 连续事件 - 中等优先级
    case 'drag':
    case 'dragenter':
    case 'dragexit':
    case 'dragleave':
    case 'dragover':
    case 'mousemove':
    case 'mouseout':
    case 'mouseover':
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'scroll':
    case 'touchmove':
    case 'wheel':
    case 'mouseenter':
    case 'mouseleave':
    case 'pointerenter':
    case 'pointerleave':
      return ContinuousEventPriority;
    
    // 默认事件 - 低优先级
    case 'message': {
      // 可能是连续的，也可能不是
      const schedulerPriority = getCurrentSchedulerPriorityLevel();
      switch (schedulerPriority) {
        case ImmediateSchedulerPriority:
          return DiscreteEventPriority;
        case UserBlockingSchedulerPriority:
          return ContinuousEventPriority;
        case NormalSchedulerPriority:
        case LowSchedulerPriority:
          return DefaultEventPriority;
        case IdleSchedulerPriority:
          return IdleEventPriority;
        default:
          return DefaultEventPriority;
      }
    }
    default:
      return DefaultEventPriority;
  }
}
```

### 优先级包装器的创建

```javascript
// react/packages/react-dom-bindings/src/events/ReactDOMEventListener.js

export function createEventListenerWrapperWithPriority(
  targetContainer: EventTarget,
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
): Function {
  const eventPriority = getEventPriority(domEventName);
  let listenerWrapper;
  switch (eventPriority) {
    case DiscreteEventPriority:
      listenerWrapper = dispatchDiscreteEvent;
      break;
    case ContinuousEventPriority:
      listenerWrapper = dispatchContinuousEvent;
      break;
    case DefaultEventPriority:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }
  return listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer,
  );
}
```

`createEventListenerWrapperWithPriority` 方法用于根据事件的优先级，创建不同的事件监听器（`listener`）。这个方法在上一阶段的 `addTrappedEventListener` 方法中执行。

```javascript
let listener = createEventListenerWrapperWithPriority(
  targetContainer,
  domEventName,
  eventSystemFlags,
);
```

这里所说的事件监听器，就是最终传递给原生 `addEventListener` 方法的第二个参数，也就是回调函数。

```javascript
// 离散事件分发器
function dispatchDiscreteEvent(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  container: EventTarget,
  nativeEvent: AnyNativeEvent,
) {
  const prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  const previousPriority = getCurrentUpdatePriority();

  try {
    // 设置为离散事件优先级
    setCurrentUpdatePriority(DiscreteEventPriority);
    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    // 恢复之前的优先级
    setCurrentUpdatePriority(previousPriority);
    ReactSharedInternals.T = prevTransition;
  }
}

// 连续事件分发器
function dispatchContinuousEvent(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  container: EventTarget,
  nativeEvent: AnyNativeEvent,
) {
  const prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  const previousPriority = getCurrentUpdatePriority();

  try {
    // 设置为连续事件优先级
    setCurrentUpdatePriority(ContinuousEventPriority);
    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    // 恢复之前的优先级
    setCurrentUpdatePriority(previousPriority);
    ReactSharedInternals.T = prevTransition;
  }
}
```

## 事件处理生命周期

### 事件触发到处理的完整流程

```javascript
// 完整的事件处理流程
const EventHandlingLifecycle = {
  // 1. 原生事件触发
  nativeEventTriggered: (nativeEvent) => {
    // 用户操作触发原生 DOM 事件
    // 例如：用户点击按钮
  },

  // 2. 根节点捕获事件
  rootContainerCapture: (nativeEvent) => {
    // React 在根节点捕获事件
    // 调用 dispatchEvent
  },

  // 3. 事件分发
  eventDispatch: (domEventName, eventSystemFlags, nativeEvent) => {
    // 根据优先级包装事件处理器
    // 调用相应的分发器（discrete/continuous/default）
  },

  // 4. 事件提取
  eventExtraction: (nativeEvent) => {
    // 各个插件提取合成事件
    // 创建合成事件对象
    // 收集监听器
  },

  // 5. 监听器执行
  listenerExecution: (syntheticEvent, listeners) => {
    // 按照捕获->冒泡的顺序执行监听器
    // 处理事件传播控制
  }
};
```

### 原生事件触发

```javascript
// 用户操作触发原生 DOM 事件
// 例如：用户点击按钮
button.dispatchEvent(new MouseEvent('click', {
  bubbles: true,
  cancelable: true
}));

// React 在根节点捕获事件
rootContainerElement.addEventListener('click', nativeEvent => {
  // React 的事件处理入口
  dispatchEvent('click', eventSystemFlags, nativeEvent, targetInst, document);
});
```

### 事件分发的实现

```javascript
// react/packages/react-dom-bindings/src/events/ReactDOMEventListener.js

export function dispatchEvent(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
  nativeEvent: AnyNativeEvent,
): void {
  // 检查事件系统是否启用
  if (!_enabled) {
    return;
  }

  // 检查是否有阻塞事件（如 Suspense 边界、脱水根等）
  let blockedOn = findInstanceBlockingEvent(nativeEvent);
  if (blockedOn === null) {
    // 没有阻塞，直接分发事件
    dispatchEventForPluginEventSystem(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      return_targetInst,
      targetContainer,
    );
    clearIfContinuousEvent(domEventName, nativeEvent);
    return;
  }

  // 处理连续事件的排队
  if (
    queueIfContinuousEvent(
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent,
    )
  ) {
    nativeEvent.stopPropagation();
    return;
  }

  // 清理连续事件（只有在没有排队时才清理，因为排队是累积的）
  clearIfContinuousEvent(domEventName, nativeEvent);

  // 处理需要水合的离散事件
  if (
    eventSystemFlags & IS_CAPTURE_PHASE &&
    isDiscreteEventThatRequiresHydration(domEventName)
  ) {
    while (blockedOn !== null) {
      const fiber = getInstanceFromNode(blockedOn);
      if (fiber !== null) {
        attemptSynchronousHydration(fiber);
      }
      const nextBlockedOn = findInstanceBlockingEvent(nativeEvent);
      if (nextBlockedOn === null) {
        dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          return_targetInst,
          targetContainer,
        );
      }
      if (nextBlockedOn === blockedOn) {
        break;
      }
      blockedOn = nextBlockedOn;
    }
    if (blockedOn !== null) {
      nativeEvent.stopPropagation();
    }
    return;
  }

  // 对于不可重放的事件，在没有目标的情况下调用，以防事件系统需要追踪它
  dispatchEventForPluginEventSystem(
    domEventName,
    eventSystemFlags,
    nativeEvent,
    null,
    targetContainer,
  );
}
```

### 插件系统的事件分发

`dispatchEventForPluginEventSystem` 方法负责将原生 DOM 事件分发给 React 的事件插件系统。它是连接原生事件和 React 合成事件处理的关键桥梁。

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js

export function dispatchEventForPluginEventSystem(
  domEventName: DOMEventName, // 原生 DOM 事件名称（如'click'、'keydown'）
  eventSystemFlags: EventSystemFlags, // 事件系统标志位
  nativeEvent: AnyNativeEvent, // 原生 DOM 事件对象
  targetInst: null | Fiber, // 目标 Fiber 节点
  targetContainer: EventTarget, // 目标容器（React 根节点）
): void {
  let ancestorInst = targetInst;

  // 只有委托事件才需要后续的祖先节点查找逻辑
  if (
    (eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 &&
    (eventSystemFlags & IS_NON_DELEGATED) === 0
  ) {
    const targetContainerNode = ((targetContainer: any): Node);

    // 祖先节点查找逻辑（核心部分）
    if (targetInst !== null) {
      let node: null | Fiber = targetInst;

      mainLoop: while (true) {
        if (node === null) {
          return;
        }
        const nodeTag = node.tag;

        // 检查是否为根节点或 Portal 节点
        if (nodeTag === HostRoot || nodeTag === HostPortal) {
          let container = node.stateNode.containerInfo;
          if (isMatchingRootContainer(container, targetContainerNode)) {
            break;
          }

          // Portal 特殊处理
          if (nodeTag === HostPortal) {
            let grandNode = node.return;
            while (grandNode !== null) {
              const grandTag = grandNode.tag;
              if (grandTag === HostRoot || grandTag === HostPortal) {
                const grandContainer = grandNode.stateNode.containerInfo;
                if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                  return;
                }
              }
              grandNode = grandNode.return;
            }
          }

          // 继续向上查找
          while (container !== null) {
            const parentNode = getClosestInstanceFromNode(container);
            if (parentNode === null) {
              return;
            }
            const parentTag = parentNode.tag;
            if (
              parentTag === HostComponent ||
              parentTag === HostText ||
              parentTag === HostHoistable ||
              parentTag === HostSingleton
            ) {
              node = ancestorInst = parentNode;
              continue mainLoop;
            }
            container = container.parentNode;
          }
        }
        node = node.return;
      }
    }
  }

  // 在批处理上下文中执行事件分发
  batchedUpdates(() =>
    dispatchEventsForPlugins(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      ancestorInst,
      targetContainer,
    ),
  );
}

function dispatchEventsForPlugins(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  nativeEvent: AnyNativeEvent,
  targetInst: null | Fiber,
  targetContainer: EventTarget,
): void {
  const nativeEventTarget = getEventTarget(nativeEvent);
  const dispatchQueue: DispatchQueue = [];

  // 提取事件：将原生事件转换为合成事件
  extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer,
  );

  // 处理事件队列
  processDispatchQueue(dispatchQueue, eventSystemFlags);
}
```

### 事件提取

React 执行事件提取操作的主要目的是**将原生 DOM 事件转换为 React 合成事件**，并在这个过程中实现多个重要功能：

1. 事件标准化和跨浏览器兼容性。
2. 事件过滤和优化。
3. 复杂事件的模拟实现。
4. 事件状态管理和追踪。

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js

function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
) {
  // 处理简单插件的事件提取
  SimpleEventPlugin.extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer,
  );

  // 处理其他插件的事件提取
  const shouldProcessPolyfillPlugins = 
    (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
  if (shouldProcessPolyfillPlugins) {
    EnterLeaveEventPlugin.extractEvents(/* ... */);
    ChangeEventPlugin.extractEvents(/* ... */);
    SelectEventPlugin.extractEvents(/* ... */);
    BeforeInputEventPlugin.extractEvents(/* ... */);
    FormActionEventPlugin.extractEvents(/* ... */);
  }
  if (enableScrollEndPolyfill) {
    ScrollEndEventPlugin.extractEvents(/* ... */);
  }
}
```

下面是 `SimpleEventPlugin` 插件创建合成事件和执行标准化的过程。

```javascript
// react/packages/react-dom-bindings/src/events/plugins/SimpleEventPlugin.js

function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
): void {
  const reactName = topLevelEventsToReactNames.get(domEventName);
  if (reactName === undefined) {
    return;
  }

  let SyntheticEventCtor = SyntheticEvent;
  let reactEventType: string = domEventName;

  switch (domEventName) {
    case 'keypress':
      // Firefox 为功能键也创建 keypress 事件，这里过滤掉不需要的事件
      if (getEventCharCode(((nativeEvent: any): KeyboardEvent)) === 0) {
        return;
      }
    case 'keydown':
    case 'keyup':
      SyntheticEventCtor = SyntheticKeyboardEvent;
      break;
    case 'focusin':
      reactEventType = 'focus';  // 标准化 focusin 为 focus
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case 'focusout':
      reactEventType = 'blur'; // 标准化 focusout 为 blur
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case 'beforeblur':
    case 'afterblur':
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case 'click':
      // Firefox 在右键点击时创建 click 事件，这里过滤掉
      if (nativeEvent.button === 2) {
        return;
      }
    // 其他事件类型...
  }

  // 收集监听器，只有在有监听器时才创建标准化的合成事件
  if (
    enableCreateEventHandleAPI &&
    eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE
  ) {
    const listeners = accumulateEventHandleNonManagedNodeListeners(/* ... */);
    if (listeners.length > 0) {
      const event: ReactSyntheticEvent = new SyntheticEventCtor(
        reactName,
        reactEventType,
        null,
        nativeEvent,
        nativeEventTarget,
      );
      dispatchQueue.push({event, listeners});
    }
  } else {
    const listeners = accumulateSinglePhaseListeners(/* ... */);
    if (listeners.length > 0) {
      const event: ReactSyntheticEvent = new SyntheticEventCtor(
        reactName,
        reactEventType,
        null,
        nativeEvent,
        nativeEventTarget,
      );
      dispatchQueue.push({event, listeners});
    }
  }
}
```

### 监听器收集机制

下面是事件监听器的获取机制。

```javascript
export default function getListener(
  inst: Fiber,
  registrationName: string,
): Function | null {
  const stateNode = inst.stateNode;
  if (stateNode === null) {
    return null;
  }

  // 从 DOM 节点获取当前的 props
  const props = getFiberCurrentPropsFromNode(stateNode);
  if (props === null) {
    // 工作在进行中，props 还未更新
    return null;
  }
  
  const listener = props[registrationName];
  // 特殊情况：阻止鼠标事件
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }

  // 验证监听器类型
  if (listener && typeof listener !== 'function') {
    throw new Error(
      `Expected \`${registrationName}\` listener to be a function, instead got a value of \`${typeof listener}\` type.`,
    );
  }

  return listener;
}

// 检查是否应该阻止鼠标事件
function shouldPreventMouseEvent(name: string, type: string, props: Props): boolean {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
    case 'onMouseEnter':
      return !!(props.disabled && isInteractiveElement(type));
    default:
      return false;
  }
}

// 判断是否为交互式元素
function isInteractiveElement(type: string): boolean {
  return (
    type === 'button' ||
    type === 'input' ||
    type === 'select' ||
    type === 'textarea'
  );
}
```

下面部分是监听器收集机制。

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js

// 单向事件监听器收集
export function accumulateSinglePhaseListeners(
  targetFiber: Fiber | null,
  reactName: string | null,
  nativeEventType: string,
  inCapturePhase: boolean,
  accumulateTargetOnly: boolean,
  nativeEvent: AnyNativeEvent,
): Array<DispatchListener> {
  const captureName = reactName !== null ? reactName + 'Capture' : null;
  const reactEventName = inCapturePhase ? captureName : reactName;
  let listeners: Array<DispatchListener> = [];

  let instance = targetFiber;
  let lastHostComponent = null;

  // 从目标节点向上遍历
  while (instance !== null) {
    const {stateNode, tag} = instance;
    if (
      (tag === HostComponent ||
        tag === HostHoistable ||
        tag === HostSingleton) &&
      stateNode !== null
    ) {
      lastHostComponent = stateNode;

      if (enableCreateEventHandleAPI) {
        const eventHandlerListeners =
          getEventHandlerListeners(lastHostComponent);
        if (eventHandlerListeners !== null) {
          eventHandlerListeners.forEach(entry => {
            if (
              entry.type === nativeEventType &&
              entry.capture === inCapturePhase
            ) {
              listeners.push(
                createDispatchListener(
                  instance,
                  entry.callback,
                  (lastHostComponent: any),
                ),
              );
            }
          });
        }
      }

      // 收集标准 React 监听器
      if (reactEventName !== null) {
        const listener = getListener(instance, reactEventName);
        if (listener != null) {
          listeners.push(
            createDispatchListener(instance, listener, lastHostComponent),
          );
        }
      }
    } else if (
      enableCreateEventHandleAPI &&
      enableScopeAPI &&
      tag === ScopeComponent &&
      lastHostComponent !== null &&
      stateNode !== null
    ) {
      const reactScopeInstance = stateNode;
      const eventHandlerListeners =
        getEventHandlerListeners(reactScopeInstance);
      if (eventHandlerListeners !== null) {
        eventHandlerListeners.forEach(entry => {
          if (
            entry.type === nativeEventType &&
            entry.capture === inCapturePhase
          ) {
            listeners.push(
              createDispatchListener(
                instance,
                entry.callback,
                (lastHostComponent: any),
              ),
            );
          }
        });
      }
    }
    
    if (accumulateTargetOnly) {
      break;
    }
    
    if (enableCreateEventHandleAPI && nativeEvent.type === 'beforeblur') {
      const detachedInterceptFiber = nativeEvent._detachedInterceptFiber;
      if (
        detachedInterceptFiber !== null &&
        (detachedInterceptFiber === instance ||
          detachedInterceptFiber === instance.alternate)
      ) {
        listeners = [];
      }
    }
    instance = instance.return;
  }
  return listeners;
}

// 双阶段监听器收集（捕获 + 冒泡）
export function accumulateTwoPhaseListeners(
  targetFiber: Fiber | null,
  reactName: string,
): Array<DispatchListener> {
  const captureName = reactName + 'Capture';
  const listeners: Array<DispatchListener> = [];
  let instance = targetFiber;

  // 从目标节点向上遍历到根节点
  while (instance !== null) {
    const {stateNode, tag} = instance;
    // 处理 HostComponent（如 div、button 等）
    if (
      (tag === HostComponent ||
        tag === HostHoistable ||
        tag === HostSingleton) &&
      stateNode !== null
    ) {
      const currentTarget = stateNode;

      // 收集捕获阶段监听器（添加到数组开头）
      const captureListener = getListener(instance, captureName);
      if (captureListener != null) {
        listeners.unshift(
          createDispatchListener(instance, captureListener, currentTarget),
        );
      }

      // 收集冒泡阶段监听器（添加到数组末尾）
      const bubbleListener = getListener(instance, reactName);
      if (bubbleListener != null) {
        listeners.push(
          createDispatchListener(instance, bubbleListener, currentTarget),
        );
      }
    }

    // 到达根节点时停止
    if (instance.tag === HostRoot) {
      return listeners;
    }
    instance = instance.return;
  }

  // 如果没有到达根节点，说明组件已卸载
  return [];
}

// 创建分发监听器对象
function createDispatchListener(
  instance: null | Fiber,
  listener: Function,
  currentTarget: EventTarget,
): DispatchListener {
  return {
    instance,
    listener,
    currentTarget,
  };
}
```

### 事件队列处理

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js

export function processDispatchQueue(
  dispatchQueue: DispatchQueue,
  eventSystemFlags: EventSystemFlags,
): void {
  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
  for (let i = 0; i < dispatchQueue.length; i++) {
    const {event, listeners} = dispatchQueue[i];
    // 按顺序处理每个事件的监听器
    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
  }
}

// 监听器按顺序执行
function processDispatchQueueItemsInOrder(
  event: ReactSyntheticEvent,
  dispatchListeners: Array<DispatchListener>,
  inCapturePhase: boolean,
): void {
  let previousInstance;

  if (inCapturePhase) {
    // 捕获阶段：从外到内（数组末尾到开头）
    for (let i = dispatchListeners.length - 1; i >= 0; i--) {
      const {instance, currentTarget, listener} = dispatchListeners[i];
      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }
      // 执行监听器
      executeDispatch(event, listener, currentTarget);
      previousInstance = instance;
    }
  } else {
    // 冒泡阶段：从内到外（数组开头到末尾）
    for (let i = 0; i < dispatchListeners.length; i++) {
      const {instance, currentTarget, listener} = dispatchListeners[i];
      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }
      // 执行监听器
      executeDispatch(event, listener, currentTarget);
      previousInstance = instance;
    }
  }
}

// 单个监听器执行
function executeDispatch(
  event: ReactSyntheticEvent,
  listener: Function,
  currentTarget: EventTarget,
): void {
  event.currentTarget = currentTarget;
  try {
    listener(event);
  } catch (error) {
    // 错误处理机制
    reportGlobalError(error);
  }
  event.currentTarget = null;
}
```

## 特殊事件处理

### Change 事件的复杂处理

`ChangeEventPlugin` 是 React 事件系统中最复杂的插件之一，它需要处理不同表单元素的 change 事件：

```javascript
// react/packages/react-dom-bindings/src/events/plugins/ChangeEventPlugin.js

// 不同输入类型的 change 事件处理策略
const changeEventTypes = {
  // 文本输入框
  text: {
    dependencies: ['input', 'keydown', 'keyup'],
    extractEvents: extractEventsForInputEventPolyfill,
  },
  
  // 数字输入框
  number: {
    dependencies: ['input', 'keydown', 'keyup'],
    extractEvents: extractEventsForInputEventPolyfill,
  },
  
  // 复选框和单选按钮
  checkbox: {
    dependencies: ['click'],
    extractEvents: extractEventsForInputEventPolyfill,
  },
  
  radio: {
    dependencies: ['click'],
    extractEvents: extractEventsForInputEventPolyfill,
  },
  
  // 选择框
  select: {
    dependencies: ['focusout', 'change', 'selectionchange'],
    extractEvents: extractEventsForSelectEventPolyfill,
  },
};

function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
) {
  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;

  let getTargetInstFunc, handleEventFunc;
  
  // 根据目标节点类型选择处理策略
  if (shouldUseChangeEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForChangeEvent;
  } else if (shouldUseClickEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForClickEvent;
  } else if (shouldUseInputEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
  }

  if (getTargetInstFunc) {
    const inst = getTargetInstFunc(domEventName, targetInst);
    if (inst) {
      const event = createAndAccumulateChangeEvent(
        inst,
        nativeEvent,
        nativeEventTarget,
      );
      dispatchQueue.push({event, listeners: []});
    }
  }

  // 处理输入事件的特殊逻辑
  if (handleEventFunc) {
    handleEventFunc(domEventName, targetNode, targetInst);
  }
}

// 判断是否应该使用原生 change 事件
function shouldUseChangeEvent(elem) {
  const nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return (
    nodeName === 'select' || 
    (nodeName === 'input' && elem.type === 'file')
  );
}

// 判断是否应该使用 click 事件模拟 change
function shouldUseClickEvent(elem) {
  const nodeName = elem.nodeName;
  return (
    nodeName &&
    nodeName.toLowerCase() === 'input' &&
    (elem.type === 'checkbox' || elem.type === 'radio')
  );
}

// 判断是否应该使用 input 事件模拟 change
function shouldUseInputEvent(elem) {
  const nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return (
    nodeName === 'input' &&
    (elem.type === 'text' ||
     elem.type === 'number' ||
     elem.type === 'password' ||
     elem.type === 'search' ||
     elem.type === 'tel' ||
     elem.type === 'url' ||
     elem.type === 'email')
  );
}
```

### Enter/Leave 事件的模拟实现

React 需要模拟 `mouseenter` 和 `mouseleave` 事件，因为这些事件不冒泡：

```javascript
// react/packages/react-dom-bindings/src/events/plugins/EnterLeaveEventPlugin.js

function registerEvents() {
  registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover']);
  registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover']);
  registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover']);
  registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover']);
}

function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
): void {
  const isOverEvent = domEventName === 'mouseover' || domEventName === 'pointerover';
  const isOutEvent = domEventName === 'mouseout' || domEventName === 'pointerout';

  if (isOverEvent && nativeEvent !== null) {
    const related = nativeEvent.relatedTarget || nativeEvent.fromElement;
    if (related) {
      // 检查相关目标是否在同一个 React 树中
      if (
        getClosestInstanceFromNode(related) ||
        isContainerMarkedAsRoot(related)
      ) {
        return;
      }
    }
  }

  if (!isOutEvent && !isOverEvent) {
    return;
  }

  let win;
  if (nativeEventTarget.window === nativeEventTarget) {
    win = nativeEventTarget;
  } else {
    const doc = nativeEventTarget.ownerDocument;
    if (doc) {
      win = doc.defaultView || doc.parentWindow;
    } else {
      win = window;
    }
  }

  let from;
  let to;
  
  if (isOutEvent) {
    from = targetInst;
    const related = nativeEvent.relatedTarget || nativeEvent.toElement;
    to = related ? getClosestInstanceFromNode(related) : null;
  } else {
    from = null;
    to = targetInst;
  }

  if (from === to) {
    return;
  }

  let eventInterface, leaveEventType, enterEventType, eventTypePrefix;

  if (domEventName === 'mouseout' || domEventName === 'mouseover') {
    eventInterface = SyntheticMouseEvent;
    leaveEventType = 'onMouseLeave';
    enterEventType = 'onMouseEnter';
    eventTypePrefix = 'mouse';
  } else {
    eventInterface = SyntheticPointerEvent;
    leaveEventType = 'onPointerLeave';
    enterEventType = 'onPointerEnter';
    eventTypePrefix = 'pointer';
  }

  const fromNode = from == null ? win : getNodeFromInstance(from);
  const toNode = to == null ? win : getNodeFromInstance(to);

  const leave = new eventInterface(
    leaveEventType,
    eventTypePrefix + 'leave',
    from,
    nativeEvent,
    nativeEventTarget,
  );
  leave.target = fromNode;
  leave.relatedTarget = toNode;

  let enterReturnValue = null;

  const nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
  if (nativeTargetInst === to) {
    const enter = new eventInterface(
      enterEventType,
      eventTypePrefix + 'enter',
      to,
      nativeEvent,
      nativeEventTarget,
    );
    enter.target = toNode;
    enter.relatedTarget = fromNode;
    enterReturnValue = enter;
  }

  accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enterReturnValue, from, to);
}
```

### BeforeInput 事件的处理

```javascript
// react/packages/react-dom-bindings/src/events/plugins/BeforeInputEventPlugin.js

function registerEvents() {
  registerTwoPhaseEvent('onBeforeInput', [
    'compositionend',
    'keypress',
    'textInput',
    'paste',
  ]);
}

function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
): void {
  let chars;

  switch (domEventName) {
    case 'keypress':
      // 只处理会产生字符的按键
      const which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return;
      }
      hasSpaceKeypress = true;
      chars = SPACEBAR_CHAR;
      break;

    case 'textInput':
      // Text input 事件
      chars = nativeEvent.data;
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return;
      }
      break;

    case 'compositionend':
      // 输入法组合结束
      if (useFallbackCompositionData) {
        chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
      } else {
        chars = nativeEvent.data;
      }
      break;

    case 'paste':
      // 粘贴事件
      chars = null;
      break;

    default:
      return;
  }

  if (chars) {
    const listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');
    if (listeners.length > 0) {
      const event = new SyntheticInputEvent(
        'onBeforeInput',
        'beforeinput',
        null,
        nativeEvent,
        nativeEventTarget,
      );
      dispatchQueue.push({event, listeners});
      event.data = chars;
    }
  }
}
```

## 性能优化机制

### 事件委托的性能优势

```javascript
// 传统方式：每个元素都绑定事件监听器
// 内存使用：O(n) - n 是元素数量
// 性能问题：大量监听器影响页面性能

function traditionalEventBinding() {
  const buttons = document.querySelectorAll('button');
  buttons.forEach(button => {
    button.addEventListener('click', handleClick); // 每个按钮都有监听器
  });
}

// React 方式：只在根节点绑定监听器
// 内存使用：O(1) - 固定数量的监听器
// 性能优势：减少内存占用，提高页面性能

function reactEventDelegation() {
  // 只在根容器绑定一个监听器
  rootContainer.addEventListener('click', (nativeEvent) => {
    // 通过事件冒泡机制处理所有子元素的点击事件
    const targetFiber = getClosestInstanceFromNode(nativeEvent.target);
    if (targetFiber) {
      dispatchEvent('click', eventSystemFlags, nativeEvent, targetFiber);
    }
  });
}
```

### 批处理优化

```javascript
// react/packages/react-reconciler/src/ReactFiberWorkLoop.js

// 事件批处理：将多个状态更新合并为一次重新渲染
export function batchedUpdates<A, R>(fn: (a: A) => R, a: A): R {
  const prevExecutionContext = executionContext;
  executionContext |= BatchedContext;
  
  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;
    // 如果没有其他工作在进行，立即刷新同步工作
    if (executionContext === NoContext) {
      resetRenderTimer();
      flushSyncCallbacks();
    }
  }
}

// 示例：批处理多个状态更新
function handleClick() {
  // 这些状态更新会被批处理为一次重新渲染
  setCount(c => c + 1);
  setFlag(f => !f);
  setData(d => [...d, newItem]);
  // 只会触发一次重新渲染，而不是三次
}
```

### 事件对象复用（React 16 及之前）

```javascript
// React 16 及之前版本的事件池化机制
// 注意：React 17+ 已移除事件池化

const eventPool = [];
const EVENT_POOL_SIZE = 10;

function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
  const EventConstructor = this;
  
  if (EventConstructor.eventPool.length) {
    const instance = EventConstructor.eventPool.pop();
    EventConstructor.call(
      instance,
      dispatchConfig,
      targetInst,
      nativeEvent,
      nativeInst,
    );
    return instance;
  }
  
  return new EventConstructor(
    dispatchConfig,
    targetInst,
    nativeEvent,
    nativeInst,
  );
}

function releasePooledEvent(event) {
  const EventConstructor = this;
  
  // 重置事件对象的所有属性
  event.destructor();
  
  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
    EventConstructor.eventPool.push(event);
  }
}

// React 17+ 移除了事件池化，因为：
// 1. 现代 JavaScript 引擎的垃圾回收已经足够高效
// 2. 事件池化增加了复杂性和潜在的 bug
// 3. 用户经常忘记调用 event.persist()
```

### 优先级调度优化

```javascript
// react/packages/react-reconciler/src/ReactFiberWorkLoop.js

// 根据事件优先级调度更新
function scheduleUpdateOnFiber(
  fiber: Fiber,
  lane: Lane,
  eventTime: number,
): FiberRoot | null {
  // 检查是否有无限更新循环
  checkForNestedUpdates();

  const root = markUpdateLaneFromFiberToRoot(fiber, lane);
  if (root === null) {
    return null;
  }

  // 标记根节点有待处理的更新
  markRootUpdated(root, lane, eventTime);

  if (root === workInProgressRoot) {
    // 如果正在渲染这个根节点，检查是否需要中断
    if (
      deferRenderPhaseUpdateToNextBatch ||
      (executionContext & RenderContext) !== NoContext
    ) {
      // 延迟到下一个批次
      workInProgressRootUpdatedLanes = mergeLanes(
        workInProgressRootUpdatedLanes,
        lane,
      );
    } else {
      // 标记根节点被挂起
      workInProgressRootInterleavedUpdatedLanes = mergeLanes(
        workInProgressRootInterleavedUpdatedLanes,
        lane,
      );
    }
  }

  // 根据优先级决定调度策略
  if (lane === SyncLane) {
    if (
      (executionContext & LegacyUnbatchedContext) !== NoContext &&
      (executionContext & (RenderContext | CommitContext)) === NoContext
    ) {
      // 同步渲染
      performSyncWorkOnRoot(root);
    } else {
      // 调度同步回调
      ensureRootIsScheduled(root, eventTime);
      if (executionContext === NoContext) {
        resetRenderTimer();
        flushSyncCallbacks();
      }
    }
  } else {
    // 异步渲染
    ensureRootIsScheduled(root, eventTime);
  }

  return root;
}
```

## 源码实现细节

### 事件系统的初始化时机

```javascript
// react/packages/react-dom/src/client/ReactDOMRoot.js

export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions,
): RootType {
  // 验证容器
  if (!isValidContainer(container)) {
    throw new Error('createRoot(...): Target container is not a DOM element.');
  }

  // 创建 Fiber 根节点
  const root = createContainer(
    container,
    ConcurrentRoot,
    null,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
    identifierPrefix,
    onRecoverableError,
    transitionCallbacks,
  );

  // 标记容器为 React 根节点
  markContainerAsRoot(root.current, container);

  // 设置事件监听器 - 这是事件系统初始化的关键步骤
  const rootContainerElement = container.nodeType === COMMENT_NODE 
    ? container.parentNode 
    : container;
  
  listenToAllSupportedEvents(rootContainerElement);

  return new ReactDOMRoot(root);
}
```

### Fiber 节点与事件的关联

```javascript
// react/packages/react-reconciler/src/ReactFiberHostConfig.js

// 将 Fiber 实例与 DOM 节点关联
export function precacheFiberNode(hostInst: Fiber, node: Instance): void {
  (node: any)[internalInstanceKey] = hostInst;
}

// 将当前 props 缓存到 DOM 节点
export function updateFiberProps(node: Instance, props: Props): void {
  (node: any)[internalPropsKey] = props;
}

// 从 DOM 节点获取 Fiber 实例
export function getInstanceFromNode(node: Node): Fiber | null {
  const inst = (node: any)[internalInstanceKey] || (node: any)[internalContainerInstanceKey];
  if (inst) {
    if (
      inst.tag === HostComponent ||
      inst.tag === HostText ||
      inst.tag === SuspenseComponent ||
      inst.tag === HostRoot ||
      inst.tag === HostPortal ||
      inst.tag === HostHoistable ||
      inst.tag === HostSingleton
    ) {
      return inst;
    } else {
      return null;
    }
  }
  return null;
}

// 从 DOM 节点获取当前 props
export function getFiberCurrentPropsFromNode(node: Instance): Props {
  return (node: any)[internalPropsKey] || null;
}
```

### 事件监听器的获取机制

```javascript
// react/packages/react-dom-bindings/src/events/getListener.js

export default function getListener(
  inst: Fiber,
  registrationName: string,
): Function | null {
  const stateNode = inst.stateNode;
  if (stateNode === null) {
    // 工作在进行中，stateNode 还未创建
    return null;
  }

  // 从 DOM 节点获取当前的 props
  const props = getFiberCurrentPropsFromNode(stateNode);
  if (props === null) {
    // 工作在进行中，props 还未更新
    return null;
  }
  
  const listener = props[registrationName];
  
  // 特殊情况：阻止鼠标事件
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }

  // 验证监听器类型
  if (listener && typeof listener !== 'function') {
    throw new Error(
      `Expected \`${registrationName}\` listener to be a function, instead got a value of \`${typeof listener}\` type.`,
    );
  }

  return listener;
}

// 检查是否应该阻止鼠标事件
function shouldPreventMouseEvent(name: string, type: string, props: Props): boolean {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
    case 'onMouseEnter':
      return !!(props.disabled && isInteractiveElement(type));
    default:
      return false;
  }
}

// 判断是否为交互式元素
function isInteractiveElement(type: string): boolean {
  return (
    type === 'button' ||
    type === 'input' ||
    type === 'select' ||
    type === 'textarea'
  );
}
```

### 错误处理机制

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js

function reportGlobalError(error: mixed): void {
  if (typeof window !== 'undefined' && typeof window.ErrorEvent === 'function') {
    // 在浏览器环境中，使用 ErrorEvent
    const event = new window.ErrorEvent('error', {
      bubbles: false,
      cancelable: false,
      message: typeof error === 'object' && error !== null && typeof error.message === 'string'
        ? error.message
        : String(error),
      error: error,
    });

    const shouldLog = window.dispatchEvent(event);
    if (!shouldLog) {
      return;
    }
  }

  // 回退到控制台错误
  console['error'](error);
}

// 在事件执行中捕获错误
function executeDispatch(
  event: ReactSyntheticEvent,
  listener: Function,
  currentTarget: EventTarget,
): void {
  event.currentTarget = currentTarget;
  
  try {
    listener(event);
  } catch (error) {
    // 捕获并报告事件处理器中的错误
    reportGlobalError(error);
  }
  
  event.currentTarget = null;
}
```

## 完整的事件绑定流程

```text
1. 模块加载
   ↓
2. 事件插件注册 (registerEvents)
   ↓
3. 事件注册表填充 (allNativeEvents, registrationNameDependencies)
   ↓
4. React 应用初始化
   ↓
5. 根节点事件监听 (listenToAllSupportedEvents)
   ↓
6. 创建事件监听器包装器 (createEventListenerWrapperWithPriority)
   ↓
7. 绑定原生事件监听器 (addTrappedEventListener)
   ↓
8. 等待用户交互
   ↓
9. 原生事件触发
   ↓
10. 事件分发 (dispatchEvent)
    ↓
11. 事件提取 (extractEvents)
    ↓
12. 合成事件创建 (new SyntheticEventCtor)
    ↓
13. 监听器收集 (accumulateTwoPhaseListeners)
    ↓
14. 事件执行 (processDispatchQueue)
```

## 参考

- [react](https://github.com/facebook/react)
