# React 事件系统

## 概述

React 的事件系统是一个**合成事件系统**，它是对原生 DOM 事件的一层封装。React 通过**事件委托**机制，将所有事件监听器绑定到**根节点**（也就是 `ReactDOM.createRoot()` 的参数节点），而不是绑定到具体的 DOM 元素上。

这种设计能够带来很多优势。

- 跨浏览器兼容性。合成事件能够处理过时的事件 API，同时为浏览器不支持的 API 提供了支持，从而统一了不同浏览器的事件 API 之间的差异。
- 性能优化。事件委托减少了内存占用，批量更新避免了频繁重渲染。
- 开发体验提升。合成事件提供了统一的 API 接口，同时在类组件中，自动绑定 this。

## 合成事件

React 采用**抽象工厂模式**来创建不同类型的合成事件。合成事件构造函数，位于 `function createSyntheticEvent(Interface: EventInterfaceType)` 中。

```javascript
function createSyntheticEvent(Interface: EventInterfaceType) {
  function SyntheticBaseEvent(
    reactName: string | null,
    reactEventType: string,
    targetInst: Fiber | null,
    nativeEvent: {[propName: string]: mixed, ...},
    nativeEventTarget: null | EventTarget,
  ) {
    //...
  }

  assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      //...
    },

    stopPropagation: function () {
      //...
    },
  });

  return SyntheticBaseEvent;
}
```

`EventInterfaceType` 定义了多种不同类型的事件接口，下面列出了 `KeyboardEventInterface` 的接口定义。

```javascript
const EventInterface = {
  eventPhase: 0, // 事件阶段
  bubbles: 0, // 是否冒泡
  cancelable: 0, // 是否可取消
  defaultPrevented: 0, // 是否阻止默认行为
  isTrusted: 0, // 是否可信事件
  timeStamp: function (event: {[propName: string]: mixed}) {
    return event.timeStamp || Date.now();
  },
};

// 规范化过时的 HTML5 key 值
const normalizeKey = {
  Esc: 'Escape', // 旧标准 -> 新标准
  Spacebar: ' ', // 空格键的旧表示 -> 新表示
  Left: 'ArrowLeft', // 方向键的旧表示
  MozPrintableKey: 'Unidentified', // Firefox 的特殊值
  // ...
};

// 从传统的 keyCode 到 HTML5 key 的转换映射
const translateToKey = {
  '8': 'Backspace', // keyCode 8 -> 标准键名
  '9': 'Tab', // keyCode 9 -> 标准键名
  // ...
  '37': 'ArrowLeft', // keyCode 37 -> 标准键名
  // ...
};

const KeyboardEventInterface = {
  ...UIEventInterface,
  key: getEventKey,
  code: 0,
  // ...
  getModifierState: getEventModifierState,
  charCode: function (event: {[propName: string]: mixed}) {
    if (event.type === 'keypress') {
      return getEventCharCode(
        event,
      );
    }
    return 0;
  },
  keyCode: function (event: {[propName: string]: mixed}) {
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event: {[propName: string]: mixed}) {
    if (event.type === 'keypress') {
      return getEventCharCode(
        event,
      );
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
};

function getEventKey(nativeEvent: {[propName: string]: mixed}) {
  // 如果浏览器支持 key 属性
  if (nativeEvent.key) {
    // FireFox 实现了 `key` 但对于所有可打印字符都返回 `MozPrintableKey`
    // 这被标准化为 `Unidentified`，所以代码需要忽略这种情况
    const key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // 如果浏览器不支持 `key` 属性，则为它添加 Polyfill
  if (nativeEvent.type === 'keypress') {
    const charCode = getEventCharCode(nativeEvent);
    // Enter 键的特殊处理
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }

  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // 虽然用户键盘布局决定了每个 `keyCode` 值的实际含义，但是功能键（如 F1、F2 等）几乎都有通用的标准值
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }

  return '';
}
```

`SyntheticBaseEvent` 构造函数用于创建合成事件对象。

```javascript
function SyntheticBaseEvent(
  reactName: string | null,
  reactEventType: string,
  targetInst: Fiber | null,
  nativeEvent: {[propName: string]: mixed, ...},
  nativeEventTarget: null | EventTarget,
) {
  this._reactName = reactName; // React 事件名称（如 onClick）
  this._targetInst = targetInst; // 目标 Fiber 节点
  this.type = reactEventType; // 事件类型
  this.nativeEvent = nativeEvent; // 原生事件对象
  this.target = nativeEventTarget; // 事件目标
  this.currentTarget = null; // 当前处理事件的元素（绑定事件处理器的元素）

  for (const propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    const normalize = Interface[propName];
    // 使用规范化函数处理属性或者直接将原生事件属性复制到合成事件
    this[propName] = normalize ? normalize(nativeEvent) : nativeEvent[propName];
  }

  // 处理默认阻止状态
  const defaultPrevented =
    nativeEvent.defaultPrevented != null
      ? nativeEvent.defaultPrevented
      : nativeEvent.returnValue === false;
  this.isDefaultPrevented = defaultPrevented ? functionThatReturnsTrue : functionThatReturnsFalse;
  this.isPropagationStopped = functionThatReturnsFalse;
  
  return this;
}
```

不难看出，合成事件对象主要执行了下面这些操作。

- 将事件类型、名称、目标节点信息挂载到合成事件对象。
- 将原生对象以及原生事件对阻止默认行为的结果挂载到合成事件对象。
- 执行事件的规范化，将不同浏览器中不一致的事件 API 统一为标准格式，同时兼容过时的 API，为浏览器不支持的 API 提供 Polyfill。

注意，`SyntheticBaseEvent` 构造方法中的 `normalize` 方法，用于执行事件 API 的规范化，所谓规范化，是指 React 将不同浏览器中不一致的事件 API 统一为标准格式的过程。这是 React 合成事件系统最重要的特性之一。

比如，经过规范化处理后，如果按下键盘上的方向左键，React 最终会达成这样的效果。

```javascript
// 不同浏览器中的原始值
// Chrome: event.key = "ArrowLeft"
// Firefox: event.key = "Left" (旧版本)
// IE: event.key = undefined, event.keyCode = 37

// React规范化后的统一值
// 所有浏览器: event.key = "ArrowLeft"

// 经过上面的处理，就不需要考虑浏览器差异
function handleKeyPress(event) {
  if (event.key === 'ArrowLeft') {
    // 这个条件在所有浏览器中都成立
    console.log('用户按下了方向左键键');
  }
}
```

从上面 React 对 `KeyboardEventInterface` 接口的处理不难看出，React 消除了事件 API 在不同浏览器之间的差异，同时对过时的以及浏览器不支持的 API 提供了支持。这使得开发人员在基于 React 开发时，能够获得一致的开发体验。

```javascript
assign(SyntheticBaseEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    const event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = functionThatReturnsTrue;
  },

  stopPropagation: function () {
    const event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // IE 兼容性处理
      // ChangeEventPlugin 为 IE 注册了 "propertychange" 事件
      // 该事件不支持冒泡或取消，任何对 cancelBubble 的引用都会抛出 "Member not found"
      // 使用 typeof 检查 "unknown" 可以避免这个问题
      event.cancelBubble = true;
    }

    this.isPropagationStopped = functionThatReturnsTrue;
  },
});
```

合成事件的核心方法就两个：`preventDefault` 和 `stopPropagation`。

- `preventDefault` 用于阻止默认事件，内部调用了原生事件的 `preventDefault` 方法。
- `stopPropagation` 用于阻止向上冒泡，内部调用了原生事件的 `stopPropagation` 方法。

## 合成事件绑定流程

### 第一阶段：事件注册

#### 事件注册表初始化

```javascript
// react/packages/react-dom-bindings/src/events/EventRegistry.js
export const allNativeEvents: Set<DOMEventName> = new Set();
export const registrationNameDependencies: {
  [registrationName: string]: Array<DOMEventName>,
} = {};

export function registerTwoPhaseEvent(
  registrationName: string,
  dependencies: Array<DOMEventName>,
): void {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + 'Capture', dependencies);
}

export function registerDirectEvent(
  registrationName: string,
  dependencies: Array<DOMEventName>,
) {
  registrationNameDependencies[registrationName] = dependencies;
  for (let i = 0; i < dependencies.length; i++) {
    allNativeEvents.add(dependencies[i]);
  }
}
```

- `allNativeEvents` 存放所有原生事件的集合。
- `registerTwoPhaseEvent` 用于注册某个事件，包括捕获阶段和冒泡阶段。
- `registerDirectEvent` 将事件添加到 `allNativeEvents` 集合中。`registrationNameDependencies` 中存放着合成事件与原生事件名称的映射。

```javascript
registrationNameDependencies = {
  'onClick': ['click'],
  'onChange': ['change', 'input'],
  'onKeyDown': ['keydown'],
  'onMouseEnter': ['mouseenter'],
  'onMouseLeave': ['mouseleave'],
  // ...
}
```

#### 事件插件注册

```javascript
SimpleEventPlugin.registerEvents();
EnterLeaveEventPlugin.registerEvents();
ChangeEventPlugin.registerEvents();
SelectEventPlugin.registerEvents();
BeforeInputEventPlugin.registerEvents();
if (enableScrollEndPolyfill) {
  ScrollEndEventPlugin.registerEvents();
}
```

不同的插件负责注册不同的事件，下面是 `SimpleEventPlugin` 的注册事件，这个插件负责注册大部分的原生事件。

```javascript
// react/packages/react-dom-bindings/src/events/DOMEventProperties.js
const simpleEventPluginEvents = [
  'abort', 'click', 'drag', 'drop', 'resize', 'scroll', 'wheel',
  // ...
];

function registerSimpleEvent(domEventName: DOMEventName, reactName: string) {
  topLevelEventsToReactNames.set(domEventName, reactName);
  registerTwoPhaseEvent(reactName, [domEventName]);
}

// `SimpleEventPlugin.registerEvents()` 方法就是下面的方法
export function registerSimpleEvents() {
  for (let i = 0; i < simpleEventPluginEvents.length; i++) {
    const eventName = ((simpleEventPluginEvents[i]: any): string);
    const domEventName = ((eventName.toLowerCase(): any): DOMEventName);
    const capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
    registerSimpleEvent(domEventName, 'on' + capitalizedEvent);
  }

  // 特殊事件注册
  registerSimpleEvent(ANIMATION_END, 'onAnimationEnd');
  registerSimpleEvent(ANIMATION_ITERATION, 'onAnimationIteration');
  registerSimpleEvent(ANIMATION_START, 'onAnimationStart');
  registerSimpleEvent('dblclick', 'onDoubleClick');
  registerSimpleEvent('focusin', 'onFocus');
  registerSimpleEvent('focusout', 'onBlur');

  // ...
}
```

下面是 `ChangeEventPlugin` 插件的注册事件。

```javascript
// react/packages/react-dom-bindings/src/events/plugins/ChangeEventPlugin.js
function registerEvents() {
  registerTwoPhaseEvent('onChange', [
    'change', 'click', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'selectionchange',
  ]);
}
```

从上面的注册过程可以看出，大部分合成事件和原生事件，都是一对一的关系，但是像 `onChange` 这样的合成事件，对应多个原生事件。

### 第二阶段：根节点监听

`listenToAllSupportedEvents` 用于监听所有支持的原生事件。

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js

export const mediaEventTypes: Array<DOMEventName> = [
  'abort', 'canplay', 'ended', 'error', 'pause', 'play', 'playing', 'progress', 'resize',
  // ...
];

// 下面这些事件不冒泡，所以将他们绑定在真实 DOM 节点上
export const nonDelegatedEvents: Set<DOMEventName> = new Set([
  'beforetoggle', 'cancel', 'close', 'invalid', 'load', 'scroll', 'scrollend', 'toggle',
  ...mediaEventTypes,
]);

const listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);

export function listenToAllSupportedEvents(rootContainerElement: EventTarget) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = true;
    allNativeEvents.forEach(domEventName => {
      // selectionchange 事件特殊处理，因为它不冒泡
      if (domEventName !== 'selectionchange') {
        // 非委托事件只绑定冒泡监听器
        if (!nonDelegatedEvents.has(domEventName)) {
          listenToNativeEvent(domEventName, false, rootContainerElement);
        }
        // 所有事件都绑定捕获监听器
        listenToNativeEvent(domEventName, true, rootContainerElement);
      }
    });

    // 特殊处理 selectionchange 事件，绑定到 document 上
    const ownerDocument =
      rootContainerElement.nodeType === DOCUMENT_NODE
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    if (ownerDocument !== null) {
      if (!ownerDocument[listeningMarker]) {
        ownerDocument[listeningMarker] = true;
        listenToNativeEvent('selectionchange', false, ownerDocument);
      }
    }
  }
}
```

这个方法执行的操作包括：

- 遍历 `allNativeEvents` 集合中的所有原生。对于可冒泡的事件，设置冒泡阶段监听。全部事件都绑定捕获阶段监听（`selectionchange` 事件除外）。
- 将 `selectionchange` 事件绑定到 document 节点。

rootContainerElement 作为代理，基于事件冒泡机制，而 `selectionchange` 事件不会冒泡，所以无法绑定到 rootContainer。另外，`selectionchange` 事件是全局性的，与当前焦点元素相关，无论用户在哪个输入框中操作，都会触发 document 上的 `selectionchange` 事件，也就是说，通常不需要知道具体是哪个元素的选择变了。

`addTrappedEventListener` 方法执行最后具体的事件注册操作。这个方法会根据事件是否是被动类型（即 `passive`）、是否注册在捕获阶段等信息，执行原生的 `addEventListener` 方法。

```javascript
export function listenToNativeEvent(
  domEventName: DOMEventName,
  isCapturePhaseListener: boolean,
  target: EventTarget,
): void {
  let eventSystemFlags = 0;
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE;
  }

  addTrappedEventListener(
    target,
    domEventName,
    eventSystemFlags,
    isCapturePhaseListener,
  );
}

function addTrappedEventListener(
  targetContainer: EventTarget,
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  isCapturePhaseListener: boolean,
  isDeferredListenerForLegacyFBSupport?: boolean,
) {
  // 创建带优先级的事件监听器包装器
  let listener = createEventListenerWrapperWithPriority(
    targetContainer,
    domEventName,
    eventSystemFlags,
  );

  // 处理被动监听器（passive listeners）
  let isPassiveListener: void | boolean = undefined;
  if (passiveBrowserEventsSupported) {
    if (
      domEventName === 'touchstart' ||
      domEventName === 'touchmove' ||
      domEventName === 'wheel'
    ) {
      isPassiveListener = true;
    }
  }

  // 根据阶段和被动性选择不同的绑定方式
  if (isCapturePhaseListener) {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(
        targetContainer,
        domEventName,
        listener,
        isPassiveListener,
      );
    } else {
      unsubscribeListener = addEventCaptureListener(
        targetContainer,
        domEventName,
        listener,
      );
    }
  } else {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(
        targetContainer,
        domEventName,
        listener,
        isPassiveListener,
      );
    } else {
      unsubscribeListener = addEventBubbleListener(
        targetContainer,
        domEventName,
        listener,
      );
    }
  }
}
```

### 第三阶段：事件分发

```javascript
// react/packages/react-reconciler/src/ReactEventPriorities.js
export const NoEventPriority: EventPriority = NoLane;           // 无优先级
export const DiscreteEventPriority: EventPriority = SyncLane;   // 离散事件优先级（最高）
export const ContinuousEventPriority: EventPriority = InputContinuousLane; // 连续事件优先级
export const DefaultEventPriority: EventPriority = DefaultLane; // 默认事件优先级
export const IdleEventPriority: EventPriority = IdleLane;       // 空闲事件优先级（最低）
```

为方便理解，上面列出了 React 合成事件的优先级分类。

- `DiscreteEventPriority` 离散事件。拥有最高优先级，这类事件会立即处理且不可批处理。通常是由用户直接触发的、有明确意图的交互事件，比如 `click`、`change`、`drop` 等事件。
- `ContinuousEventPriority` 连续事件。中等优先级，这类事件可以中断低优先级任务的执行，可以被批处理。通常是用户直接触发的、连续的事件，比如 `mousemove`、`drag`、`scroll` 等事件。
- `DefaultEventPriority` 默认事件。低优先级，这类事件可被中断、可被批处理。通常是非用户直接触发的背景事件，比如 `load` 事件。

```javascript
// react/packages/react-dom-bindings/src/events/ReactDOMEventListener.js
export function createEventListenerWrapperWithPriority(
  targetContainer: EventTarget,
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
): Function {
  const eventPriority = getEventPriority(domEventName);
  let listenerWrapper;
  switch (eventPriority) {
    case DiscreteEventPriority:
      listenerWrapper = dispatchDiscreteEvent;
      break;
    case ContinuousEventPriority:
      listenerWrapper = dispatchContinuousEvent;
      break;
    case DefaultEventPriority:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }
  return listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer,
  );
}
```

`createEventListenerWrapperWithPriority` 方法用于根据事件的优先级，创建不同的事件监听器（`listener`）。这个方法在上一阶段的 `addTrappedEventListener` 方法中执行。

```javascript
let listener = createEventListenerWrapperWithPriority(
  targetContainer,
  domEventName,
  eventSystemFlags,
);
```

这里所说的事件监听器，就是最终传递给原生 `addEventListener` 方法的第二个参数，也就是回调函数。

```javascript
function dispatchDiscreteEvent(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  container: EventTarget,
  nativeEvent: AnyNativeEvent,
) {
  const prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  const previousPriority = getCurrentUpdatePriority();

  try {
    setCurrentUpdatePriority(DiscreteEventPriority);
    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    setCurrentUpdatePriority(previousPriority);
    ReactSharedInternals.T = prevTransition;
  }
}

function dispatchContinuousEvent(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  container: EventTarget,
  nativeEvent: AnyNativeEvent,
) {
  const prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  const previousPriority = getCurrentUpdatePriority();

  try {
    setCurrentUpdatePriority(ContinuousEventPriority);
    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    setCurrentUpdatePriority(previousPriority);
    ReactSharedInternals.T = prevTransition;
  }
}

export function dispatchEvent(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
  nativeEvent: AnyNativeEvent,
): void {
  // ...
}
```

### 第四阶段：合成事件创建

React 执行事件提取操作的主要目的是**将原生 DOM 事件转换为 React 合成事件**，并在这个过程中实现多个重要功能：

1. 事件标准化和跨浏览器兼容性。
2. 事件过滤和优化。
3. 复杂事件的模拟实现。
4. 事件状态管理和追踪。

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js
function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
) {
  // 处理简单插件的事件提取
  SimpleEventPlugin.extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer,
  );

  // 处理其他插件的事件提取
  const shouldProcessPolyfillPlugins = 
    (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
  if (shouldProcessPolyfillPlugins) {
    EnterLeaveEventPlugin.extractEvents(/* ... */);
    ChangeEventPlugin.extractEvents(/* ... */);
    SelectEventPlugin.extractEvents(/* ... */);
    BeforeInputEventPlugin.extractEvents(/* ... */);
    FormActionEventPlugin.extractEvents(/* ... */);
  }
  if (enableScrollEndPolyfill) {
    ScrollEndEventPlugin.extractEvents(/* ... */);
  }
}
```

下面是 `SimpleEventPlugin` 插件创建合成事件和执行标准化的过程。

```javascript
// react/packages/react-dom-bindings/src/events/plugins/SimpleEventPlugin.js
function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
): void {
  const reactName = topLevelEventsToReactNames.get(domEventName);
  if (reactName === undefined) {
    return;
  }

  let SyntheticEventCtor = SyntheticEvent;
  let reactEventType: string = domEventName;

  switch (domEventName) {
    case 'keypress':
      // Firefox 为功能键也创建 keypress 事件，这里过滤掉不需要的事件
      if (getEventCharCode(((nativeEvent: any): KeyboardEvent)) === 0) {
        return;
      }
    case 'keydown':
    case 'keyup':
      SyntheticEventCtor = SyntheticKeyboardEvent;
      break;
    case 'focusin':
      reactEventType = 'focus';  // 标准化 focusin 为 focus
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case 'focusout':
      reactEventType = 'blur'; // 标准化 focusout 为 blur
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case 'beforeblur':
    case 'afterblur':
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case 'click':
      // Firefox 在右键点击时创建 click 事件，这里过滤掉
      if (nativeEvent.button === 2) {
        return;
      }
    // 其他事件类型...
  }

  // 收集监听器，只有在有监听器时才创建标准化的合成事件
  if (
    enableCreateEventHandleAPI &&
    eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE
  ) {
    const listeners = accumulateEventHandleNonManagedNodeListeners(/* ... */);
    if (listeners.length > 0) {
      const event: ReactSyntheticEvent = new SyntheticEventCtor(
        reactName,
        reactEventType,
        null,
        nativeEvent,
        nativeEventTarget,
      );
      dispatchQueue.push({event, listeners});
    }
  } else {
    const listeners = accumulateSinglePhaseListeners(/* ... */);
    if (listeners.length > 0) {
      const event: ReactSyntheticEvent = new SyntheticEventCtor(
        reactName,
        reactEventType,
        null,
        nativeEvent,
        nativeEventTarget,
      );
      dispatchQueue.push({event, listeners});
    }
  }
}
```

下面是完整的事件绑定流程。

```text
1. 模块加载
   ↓
2. 事件插件注册 (registerEvents)
   ↓
3. 事件注册表填充 (allNativeEvents, registrationNameDependencies)
   ↓
4. React应用初始化
   ↓
5. 根节点事件监听 (listenToAllSupportedEvents)
   ↓
6. 创建事件监听器包装器 (createEventListenerWrapperWithPriority)
   ↓
7. 绑定原生事件监听器 (addTrappedEventListener)
   ↓
8. 等待用户交互
   ↓
9. 原生事件触发
   ↓
10. 事件分发 (dispatchEvent)
    ↓
11. 事件提取 (extractEvents)
    ↓
12. 合成事件创建 (new SyntheticEventCtor)
    ↓
13. 监听器收集 (accumulateTwoPhaseListeners)
    ↓
14. 事件执行 (processDispatchQueue)
```

## 合成事件执行流程

### 第一阶段：原生事件触发

```javascript
// 用户操作触发原生 DOM 事件
// 例如：用户点击按钮
button.dispatchEvent(new MouseEvent('click', {
  bubbles: true,
  cancelable: true
}));

// React 在根节点捕获事件
rootContainerElement.addEventListener('click', nativeEvent => {
  // React 的事件处理入口
  dispatchEvent('click', eventSystemFlags, nativeEvent, targetInst, document);
});
```

### 第二阶段：事件分发与优先级处理

```javascript
export function dispatchEvent(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
  nativeEvent: AnyNativeEvent,
): void {
  // 检查事件系统是否启用
  if (!_enabled) {
    return;
  }

  // 检查是否有阻塞事件（如 Suspense 边界、脱水根等）
  let blockedOn = findInstanceBlockingEvent(nativeEvent);
  if (blockedOn === null) {
    // 没有阻塞，直接分发事件
    dispatchEventForPluginEventSystem(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      return_targetInst,
      targetContainer,
    );
    clearIfContinuousEvent(domEventName, nativeEvent);
    return;
  }

  // 处理连续事件的排队
  if (
    queueIfContinuousEvent(
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent,
    )
  ) {
    nativeEvent.stopPropagation();
    return;
  }

  // 清理连续事件（只有在没有排队时才清理，因为排队是累积的）
  clearIfContinuousEvent(domEventName, nativeEvent);

  // 处理需要水合的离散事件
  if (
    eventSystemFlags & IS_CAPTURE_PHASE &&
    isDiscreteEventThatRequiresHydration(domEventName)
  ) {
    while (blockedOn !== null) {
      const fiber = getInstanceFromNode(blockedOn);
      if (fiber !== null) {
        attemptSynchronousHydration(fiber);
      }
      const nextBlockedOn = findInstanceBlockingEvent(nativeEvent);
      if (nextBlockedOn === null) {
        dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          return_targetInst,
          targetContainer,
        );
      }
      if (nextBlockedOn === blockedOn) {
        break;
      }
      blockedOn = nextBlockedOn;
    }
    if (blockedOn !== null) {
      nativeEvent.stopPropagation();
    }
    return;
  }

  // 对于不可重放的事件，在没有目标的情况下调用，以防事件系统需要追踪它
  dispatchEventForPluginEventSystem(
    domEventName,
    eventSystemFlags,
    nativeEvent,
    null,
    targetContainer,
  );
}
```

`dispatchEventForPluginEventSystem` 方法负责将原生 DOM 事件分发给 React 的事件插件系统。它是连接原生事件和 React 合成事件处理的关键桥梁。

```javascript
export function dispatchEventForPluginEventSystem(
  domEventName: DOMEventName, // 原生 DOM 事件名称（如'click'、'keydown'）
  eventSystemFlags: EventSystemFlags, // 事件系统标志位
  nativeEvent: AnyNativeEvent, // 原生 DOM 事件对象
  targetInst: null | Fiber, // 目标 Fiber 节点
  targetContainer: EventTarget, // 目标容器（React 根节点）
): void {
  let ancestorInst = targetInst;

  // 只有委托事件才需要后续的祖先节点查找逻辑
  if (
    (eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 &&
    (eventSystemFlags & IS_NON_DELEGATED) === 0
  ) {
    const targetContainerNode = ((targetContainer: any): Node);

    // 祖先节点查找逻辑（核心部分）
    if (targetInst !== null) {
      let node: null | Fiber = targetInst;

      mainLoop: while (true) {
        if (node === null) {
          return;
        }
        const nodeTag = node.tag;

        // 检查是否为根节点或 Portal 节点
        if (nodeTag === HostRoot || nodeTag === HostPortal) {
          let container = node.stateNode.containerInfo;
          if (isMatchingRootContainer(container, targetContainerNode)) {
            break;
          }

          // Portal 特殊处理
          if (nodeTag === HostPortal) {
            let grandNode = node.return;
            while (grandNode !== null) {
              const grandTag = grandNode.tag;
              if (grandTag === HostRoot || grandTag === HostPortal) {
                const grandContainer = grandNode.stateNode.containerInfo;
                if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                  return;
                }
              }
              grandNode = grandNode.return;
            }
          }

          while (container !== null) {
            const parentNode = getClosestInstanceFromNode(container);
            if (parentNode === null) {
              return;
            }
            const parentTag = parentNode.tag;
            if (
              parentTag === HostComponent ||
              parentTag === HostText ||
              parentTag === HostHoistable ||
              parentTag === HostSingleton
            ) {
              node = ancestorInst = parentNode;
              continue mainLoop;
            }
            container = container.parentNode;
          }
        }
        node = node.return;
      }
    }
  }

  // 在批处理上下文中执行事件分发
  batchedUpdates(() =>
    dispatchEventsForPlugins(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      ancestorInst,
      targetContainer,
    ),
  );
}
```

### 第三阶段：事件提取

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js
function dispatchEventsForPlugins(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  nativeEvent: AnyNativeEvent,
  targetInst: null | Fiber,
  targetContainer: EventTarget,
): void {
  const nativeEventTarget = getEventTarget(nativeEvent);
  const dispatchQueue: DispatchQueue = [];

  // 提取事件：将原生事件转换为合成事件
  extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer,
  );

  // 处理事件队列
  processDispatchQueue(dispatchQueue, eventSystemFlags);
}
```

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js
function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
) {
  // 处理简单插件的事件提取
  SimpleEventPlugin.extractEvents(
    dispatchQueue,
    domEventName,
    targetInst,
    nativeEvent,
    nativeEventTarget,
    eventSystemFlags,
    targetContainer,
  );

  // 处理其他插件的事件提取
  const shouldProcessPolyfillPlugins = 
    (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
  if (shouldProcessPolyfillPlugins) {
    EnterLeaveEventPlugin.extractEvents(/* ... */);
    ChangeEventPlugin.extractEvents(/* ... */);
    SelectEventPlugin.extractEvents(/* ... */);
    BeforeInputEventPlugin.extractEvents(/* ... */);
    FormActionEventPlugin.extractEvents(/* ... */);
  }
  if (enableScrollEndPolyfill) {
    ScrollEndEventPlugin.extractEvents(/* ... */);
  }
}
```

```javascript
// react/packages/react-dom-bindings/src/events/plugins/SimpleEventPlugin.js
function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetInst: null | Fiber,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
): void {
  const reactName = topLevelEventsToReactNames.get(domEventName);
  if (reactName === undefined) {
    return;
  }

  let SyntheticEventCtor = SyntheticEvent;
  let reactEventType: string = domEventName;

  switch (domEventName) {
    case 'keypress':
      // Firefox 为功能键也创建 keypress 事件，这里过滤掉不需要的事件
      if (getEventCharCode(((nativeEvent: any): KeyboardEvent)) === 0) {
        return;
      }
    case 'keydown':
    case 'keyup':
      SyntheticEventCtor = SyntheticKeyboardEvent;
      break;
    case 'focusin':
      reactEventType = 'focus';  // 标准化 focusin 为 focus
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case 'focusout':
      reactEventType = 'blur'; // 标准化 focusout 为 blur
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case 'beforeblur':
    case 'afterblur':
      SyntheticEventCtor = SyntheticFocusEvent;
      break;
    case 'click':
      // Firefox 在右键点击时创建 click 事件，这里过滤掉
      if (nativeEvent.button === 2) {
        return;
      }
    // 其他事件类型...
  }

  // 收集监听器，只有在有监听器时才创建标准化的合成事件
  if (
    enableCreateEventHandleAPI &&
    eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE
  ) {
    const listeners = accumulateEventHandleNonManagedNodeListeners(/* ... */);
    if (listeners.length > 0) {
      const event: ReactSyntheticEvent = new SyntheticEventCtor(
        reactName,
        reactEventType,
        null,
        nativeEvent,
        nativeEventTarget,
      );
      dispatchQueue.push({event, listeners});
    }
  } else {
    const listeners = accumulateSinglePhaseListeners(/* ... */);
    if (listeners.length > 0) {
      const event: ReactSyntheticEvent = new SyntheticEventCtor(
        reactName,
        reactEventType,
        null,
        nativeEvent,
        nativeEventTarget,
      );
      dispatchQueue.push({event, listeners});
    }
  }
}
```

### 第四阶段：监听器收集阶段

```javascript
export default function getListener(
  inst: Fiber,
  registrationName: string,
): Function | null {
  const stateNode = inst.stateNode;
  if (stateNode === null) {
    return null;
  }

  // 从 DOM 节点获取当前的 props
  const props = getFiberCurrentPropsFromNode(stateNode);
  if (props === null) {
    // 工作在进行中
    return null;
  }
  
  const listener = props[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    // 工作在进行中
    return null;
  }

  if (listener && typeof listener !== 'function') {
    throw new Error(
      `Expected \`${registrationName}\` listener to be a function, instead got a value of \`${typeof listener}\` type.`,
    );
  }

  return listener;
}
```

单向事件监听器收集。

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js
export function accumulateSinglePhaseListeners(
  targetFiber: Fiber | null,
  reactName: string | null,
  nativeEventType: string,
  inCapturePhase: boolean,
  accumulateTargetOnly: boolean,
  nativeEvent: AnyNativeEvent,
): Array<DispatchListener> {
  const captureName = reactName !== null ? reactName + 'Capture' : null;
  const reactEventName = inCapturePhase ? captureName : reactName;
  let listeners: Array<DispatchListener> = [];

  let instance = targetFiber;
  let lastHostComponent = null;

  // 从目标节点向上遍历
  while (instance !== null) {
    const {stateNode, tag} = instance;
    if (
      (tag === HostComponent ||
        tag === HostHoistable ||
        tag === HostSingleton) &&
      stateNode !== null
    ) {
      lastHostComponent = stateNode;

      if (enableCreateEventHandleAPI) {
        const eventHandlerListeners =
          getEventHandlerListeners(lastHostComponent);
        if (eventHandlerListeners !== null) {
          eventHandlerListeners.forEach(entry => {
            if (
              entry.type === nativeEventType &&
              entry.capture === inCapturePhase
            ) {
              listeners.push(
                createDispatchListener(
                  instance,
                  entry.callback,
                  (lastHostComponent: any),
                ),
              );
            }
          });
        }
      }

      // 收集标准 React 监听器
      if (reactEventName !== null) {
        const listener = getListener(instance, reactEventName);
        if (listener != null) {
          listeners.push(
            createDispatchListener(instance, listener, lastHostComponent),
          );
        }
      }
    } else if (
      enableCreateEventHandleAPI &&
      enableScopeAPI &&
      tag === ScopeComponent &&
      lastHostComponent !== null &&
      stateNode !== null
    ) {
      const reactScopeInstance = stateNode;
      const eventHandlerListeners =
        getEventHandlerListeners(reactScopeInstance);
      if (eventHandlerListeners !== null) {
        eventHandlerListeners.forEach(entry => {
          if (
            entry.type === nativeEventType &&
            entry.capture === inCapturePhase
          ) {
            listeners.push(
              createDispatchListener(
                instance,
                entry.callback,
                (lastHostComponent: any),
              ),
            );
          }
        });
      }
    }
    
    if (accumulateTargetOnly) {
      break;
    }
    
    if (enableCreateEventHandleAPI && nativeEvent.type === 'beforeblur') {
      const detachedInterceptFiber = nativeEvent._detachedInterceptFiber;
      if (
        detachedInterceptFiber !== null &&
        (detachedInterceptFiber === instance ||
          detachedInterceptFiber === instance.alternate)
      ) {
        listeners = [];
      }
    }
    instance = instance.return;
  }
  return listeners;
}
```

双向事件监听器收集。

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js
export function accumulateTwoPhaseListeners(
  targetFiber: Fiber | null,
  reactName: string,
): Array<DispatchListener> {
  const captureName = reactName + 'Capture';
  const listeners: Array<DispatchListener> = [];
  let instance = targetFiber;

  // 从目标节点向上遍历到根节点
  while (instance !== null) {
    const {stateNode, tag} = instance;
    // 处理 HostComponent（如 div、button 等）
    if (
      (tag === HostComponent ||
        tag === HostHoistable ||
        tag === HostSingleton) &&
      stateNode !== null
    ) {
      const currentTarget = stateNode;

      // 收集捕获阶段监听器（添加到数组开头）
      const captureListener = getListener(instance, captureName);
      if (captureListener != null) {
        listeners.unshift(
          createDispatchListener(instance, captureListener, currentTarget),
        );
      }

      // 收集冒泡阶段监听器（添加到数组末尾）
      const bubbleListener = getListener(instance, reactName);
      if (bubbleListener != null) {
        listeners.push(
          createDispatchListener(instance, bubbleListener, currentTarget),
        );
      }
    }

    // 到达根节点时停止
    if (instance.tag === HostRoot) {
      return listeners;
    }
    instance = instance.return;
  }

  // 如果没有到达根节点，说明组件已卸载
  return [];
}
```

### 第五阶段：事件执行

事件队列处理。

```javascript
// react/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js

export function processDispatchQueue(
  dispatchQueue: DispatchQueue,
  eventSystemFlags: EventSystemFlags,
): void {
  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
  for (let i = 0; i < dispatchQueue.length; i++) {
    const {event, listeners} = dispatchQueue[i];
    // 按顺序处理每个事件的监听器
    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
  }
}
```

监听器按顺序执行。

```javascript
function processDispatchQueueItemsInOrder(
  event: ReactSyntheticEvent,
  dispatchListeners: Array<DispatchListener>,
  inCapturePhase: boolean,
): void {
  let previousInstance;

  if (inCapturePhase) {
    // 捕获阶段：从外到内（数组末尾到开头）
    for (let i = dispatchListeners.length - 1; i >= 0; i--) {
      const {instance, currentTarget, listener} = dispatchListeners[i];
      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }
      // 执行监听器
      executeDispatch(event, listener, currentTarget);
      previousInstance = instance;
    }
  } else {
    // 冒泡阶段：从内到外（数组开头到末尾）
    for (let i = 0; i < dispatchListeners.length; i++) {
      const {instance, currentTarget, listener} = dispatchListeners[i];
      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }
      // 执行监听器
      executeDispatch(event, listener, currentTarget);
      previousInstance = instance;
    }
  }
}
```

单个监听器执行。

```javascript
function executeDispatch(
  event: ReactSyntheticEvent,
  listener: Function,
  currentTarget: EventTarget,
): void {
  event.currentTarget = currentTarget;
  try {
    listener(event);
  } catch (error) {
    reportGlobalError(error);
  }
  event.currentTarget = null;
}
```

### 第六阶段：状态更新处理

```javascript

```

```javascript

```

```javascript

```

```javascript

```


```javascript

```


```javascript

```

```javascript

```

```javascript

```

```javascript

```