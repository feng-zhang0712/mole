# 运输层

<!-- 本章重点：

- 运输层为相互通信的应用进程提供逻辑通信。
- 端口和套接字的意义。
- 无连接的 UDP 的特点。
- 面向连接的 TCP 的特点。
- 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议。
- TCP 的滑动窗口、流量控制、拥塞控制和连接管理。 -->

## 一、运输层协议概述

### 1.1 进程之间的通信

从通信和信息处理的角度看，**运输层向上面的应用层提供通信服务**，它属于面向通信部分的最高层，同时也是用户功能中的最低层。

从运输层的角度看，**通信的真正端点并不是主机而是主机中的进程**。也就是说，**端到端的通信**是应用进程之间的通信。

运输层有个重要的功能——复用（multiplexing）和分用（demultiplexing）。

- **复用**：发送方不同的应用进程都可以使用同一个运输层协议传送数据（当然需要加上适当的首部）。
- **分用**：接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。

**网络层为主机之间的通信提供服务，而运输层则在网络层的基础上，为应用进程之间的通信提供服务**。然而正如后面还要讨论的，

运输层有两种不同的运输协议，即**面向连接的 TCP** 和 **无连接的 UDP**。
**运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑，所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道**。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努
力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。但当运输层采用无连接的
UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。

### 1.2 运输层的两个主要协议

TCP/IP 运输层的两个主要协议都是互联网的正式标准，即：

- **用户数据报协议 UDP** （User Datagram Protocol）。UDP 在传送数据之前不需要先建立连接。远地主机的运输层在收到UDP报文后，不需要给出任何确认。UDP 不提供可靠交付，但 UDP 非常简单，在某些情况下是一种最有效的工作方式。UDP 传送的数据单位叫作 **UDP 用户数据报**。
- **传输控制协议 TCP**（Transmission Control Protocol）。TCP 提供**面向连接的服务**。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协数据单元的首部增大很多，还要占用许多的处理机资源。TCP 传送的数据单位叫作 **TCP 报文段**。

<!-- 图5-2 TCP/IP 体系中的运输层协议 -->

### 1.3 运输层的端口

运输层的复用和分用功能也是类似的。应用层所有的应用进程都可以通过运输层再传
送到IP层（网络层），这就是**复用**。运输层从IP层收到发送给各应用进程的数据后，必须
分别交付指明的各应用进程，这就是**分用**。

应用层和运输层进行数据交互时，数据要被发送到端口（port），然后运输层或者物理层从端口读取数据。端口又叫协议端口（protocol port），每个端口用一个称为端口号的正整数来标志。

注意，端口是一种逻辑上的概念，不是物理概念。

TCP/IP 的运输层用一个 16 位端口号来标志一个端口。注意，**端口号只具有本地意义**，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网
不同计算机中，相同的端口号是**没有关联**的。16位的端口号允许有 65535 个不同的端口号。

客户在发起通信请求时，要知道对方服务器的IP地址（用来找到目的主机）和端口号（用来找到目的进程）。因此运输层的端口号分为两大类。

- **服务器端使用的端口号** 这里又分为两类。
  - 熟知端口号（well-known port number）或全球通用端口号，数值为 0~1023。这些端口号被指派给了 TCP/IP 最重要的一些应用程序，让所有的用户都知道。比如，HTTP 协议的熟知端口号是 80，HTTPS 协议的熟知端口号是 443。
  - 登记端口号，数值为1024~49151。这类端口号是为没有熟知端口号的应用程序使用的。要使用这类端口号必须在 IANA 按照规定的手续登记，以防止重复。

- **客户端使用的端口号** 数值为49152~65535。这类端口号仅在客户进程运行时才动态选择，因此又叫作短暂端口号。这类端口号是临时端口号，留给客户进程选择临时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚才已使用过的客户端口号就被系统收回，以便给其他客户进程使用。

当前最新的熟知端口号可在 [IANA 官网]（www.iana.org） 上查到。

## 二、用户数据报协议 UDP

### 2.1 UDP 概述

用户数据报协议 UDP 可以看作是 IP 数据报服务加上复用、分用以及差错检测的功能。UDP 有以下特点。

1. **无连接的**。即发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。
2. **尽最大努力交付**。即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数）。
3. **面向报文**。发送方的 UDP 对应用程序交下来的报文，在添加首部后向下交付给 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是**保留这些报文的边界**。在接收方的 UDP，对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程。因此，应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。反之，若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率。

    ![UDP 是面向报文的](/2025/assets/computer-network/udp-is-packet-oriented.png)

4. **没有拥塞控制**。因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很多的实时应用(如 IP 电话、实时视频会议等)要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延。
5. 支持**一对一**、**一对多**、**多对一**和**多对多**的交互通信。
6. **首部开销小**。只有 8 个字节，比 TCP 的 20 个字节的首部要短。

UDP 所发送的报文传输过程中有可能丢失，同时也不保证报文都能按照发送的先后顺序到达终点。所以，UDP 通信的特点是简单方便，但不可靠。

### 2.2 UDP 的首部格式

UDP 用户数据报有两个字段：首部字段和数据字段。首部字段有 8 个字节，由 4 个字段组成，每个字段的长度都是 2 字节。各字段意义如下。

- **源端口**：源端口号。在需要对方回信时选用。不需要时可用全 0。
- **目的端口**：目的端口号。这在终点交付报文时必须使用。
- **长度**：UDP 用户数据报的长度，最小值是 8（仅有首部）。
- **检验和**：检测 UDP 用户数据报在传输中是否有错。有错就丢弃。

![UDP 用户数据报的首部和伪首部](/2025/assets/computer-network/header-and-pseudo-header-of-a-udp-user-datagram.png)

如果接收方 UDP 发现收到的报文中的目的端口号不正确（即不存在对应于该端口号的应用进程），就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。

UDP 用户数据报在计算检验和时，要在UDP 用户数据报之前增加12个字节的伪首部。所谓“伪首部”是因为这种伪首部并不是UDP用户数据报真正的首部。只是在计算检验和时，临时添加在UDP用户数据报前面，得到一个临时的 UDP 用户数据报。检验和就是按照这个临时的UDP用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和。

UDP计算检验和的方法和计算IP数据报首部检验和的方法相似。但不同的是：IP 数据报的检验和检验IP数据报的首部，但**UDP 的检验和是把首部和数据部分一起都检验**。

在发送方，首先是先把全零放入检验和字段。再把首部以及UDP 用户数据报看成是由许多
16位的字串接起来的。若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全零
字节（但此字节不发送）。然后按二进制反码计算出这些16位字的和。将此和的二进制反码
写入检验和字段后，就发送这样的UDP用户数据报。在接收方，把收到的UDP用户数据报
连同的首部（以及可能的填充全零字节）一起，按二进制反码求这些16位字的和。当无差
错时其结果应为全1。否则就表明有差错出现，接收方就应丢弃这个UDP用户数据报（也
可以上交给应用层，但附上出现了差错的警告）。图5-6给出了一个计算UDP检验和的例子。
这里假定用户数据报的长度是15字节，因此要添加一个全0的字节。读者可以自己检验一
下在接收端是怎样对检验和进行检验的。这种简单的差错检验方法的检错能力并
不强，但它的好处是简单，处理起来较快。

<!-- 图5-6计算 UDP 检验和的例子 -->

如图5-6所示，伪首部的第3字段是全零;第4字段是IP首部中的协议字段的值。以
前曾讲过，对于UDP，此协议字段值为17：第5字段是UDP用户数据报的长度。因此，这
样的检验和，既检查了UDP用户数据报的源端口号和目的端口号以及UDP用户数据报的数
据部分，又检查了IP数据报的源IP地址和目的地址。

## 三、传输控制协议 TCP 概述

### 3.1 TCP 最主要的特点

1. **面向连接的**。应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接。
2. TCP 连接是**点对点**的，即每条 TCP 连接只能有两个端点（endpoint）。
3. 提供**全双工**通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。
4. 提供**可靠交付**的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。
5. **面向字节流**。TCP 中的“流”（stream）指的是**流入到进程或从进程流出的字节序列**。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。TCP 并不知道所传送的字节流的含义。TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的 TCP 共 10 个数据块，但接收方的 TCP 可能只用了 4 个数据块就把收到的字节流交付上层的应用程序）。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。

![TCP 面向字节流的概念](/2025/assets/computer-network/tcp-byte-stream-oriented-concept.png)
*TCP 链接就像一条管道，把字节流可靠地按序传送到目的进程*

TCP 和 UDP 在发送报文时所采用的方式完全不同。TCP 不关心应用进程一次把多长的报文发送到 TCP 的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度，来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。如果应用进程传送到 TCP 缓存的数据块太长，TCP 就可以把它划分为短一些的数据块再传送。如果应用进程一次只发来一个字节，TCP 也可以等待积累足够多的字节后再构成报文段发送出去。

### 3.2 TCP 的连接

TCP 把连接作为最基本的抽象。TCP的许多特性都与TCP是面向连接的这个基本特性有关。

每条 TCP 连接有两个端点，TCP 连接的端点叫作**套接字**（socket）或**插口**。**端口号拼接到 IP 地址即构成了套接字**。因此，套接字的表示方法是在点分十进制的 IP 地址后面写上端口号，中间用冒号或逗号隔开。

$$
套接字 socket = (IP 地址: 端口号)
$$

每条 TCP 连接唯一地被通信两端的两个端点（即**套接字对**）所确定，TCP 连接就是两个套接字之间的连接。即：

$$
TCP 连接 ::= \{socket_1, socket_2\} = \{(IP_1: prot_1), (IP_2: prot_2)\}
$$

TCP 连接的端点是个很抽象的套接字，即（IP 地址：端口号）。同一个 IP 地址可以有多个不同的 TCP 连接，而同一个端口号也可以出现在多个不同的 TCP 连接中。

## 四、可靠传输的工作原理

### 4.1 停止等待协议

“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。

注意，在运输层并不使用这种协议，这里只是为了引出可靠传输的问题才从最简单的概念讲起。在运输层使用的可靠传输协议要复杂得多。

（1）无差错情况
<!-- 图5-8 停止等待协议 -->

下图是最简单的无差错情况。`A` 发送分组 $M_1$，发完就暂停发送，等待 `B` 的确认。`B` 收到了 $M_1$ 就向 `A` 发送确认。`A` 在收到了对 $M_1$ 的确认后，就再发送下一个分组 $M_2$。同样，在收到 `B` 对 $M_2$ 的确认后，再发送 $M_3$。

![停止等待协议](/2025/assets/computer-network/stop-and-wait-protocol.png)

（2）出现差错

上图中（b）是分组在传输过程中出现差错的情况。`B` 接收 $M_1$ 时检测出了差错（也有可能 $M_1$ 在传输过程中丢失了），就丢弃 $M_1$，其他什么也不做（不通知 `A` 收到有差错的分组）。`B` 都不会发送任何信息。可靠传输协议是这样设计的：`A` 只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做**超时重传**。要实现超时重传，就要在每发送完一个分组时设置一个**超时计时器**。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。上图中，`A` 为每个已发送的分组都设置了一个超时计时器。但 `A` 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器。

这里应注意以下三点。

1. `A` 在发送完一个分组后，**必须暂时保留已发送的分组的副本**（在发生超时重传时使用）。只有在收到相应的确认后才能清除暂时保留的分组副本。
2. 分组和确认分组都必须进行**编号**。这样才能明确是哪个发送出去的分组收到了确认，而哪个分组还没有收到确认。
3. 超时计时器设置的重传时间**应当比数据在分组传输的平均往返时间更长一些**。如果重传时间设定得很长，那么通信的效率就会很低。但如果重传时间设定得太短，以致产生不必要的重传，就浪费了网络资源。在运输层重传时间的准确设定是非常复杂的，这是因为已发送出的分组到底会经过哪些网络，以及这些网络将会产生多大的时延（这取决于这些网络当时的拥塞情况），这些都是不确定因素。上图中把往返时间当作固定的（这并不符合网络的实际情况），只是为了讲述原理的方便。

（3）确认丢失和确认迟到

下图中 `B` 所发送的对 $M_1$ 的确认丢失了。`A` 在设定的超时重传时间内没有收到确认，并无法知道是自己发送的分组出错、丢失，或者是 `B` 发送的确认丢失了。因此 `A` 在超时计时器到期后就要重传 $M_1$。假定 `B` 又收到了重传的分组 $M_1$。这时应采取两个行动。

1. 丢弃这个重复的分组 $M_1$，不向上层交付。
2. 向 `A` 发送确认。不能认为已经发送过确认就不再发送，因为 `A` 之所以重传 $M_1$ 就表示 `A` 没有收到对 $M_1$ 的确认。

![确认丢失和确认迟到](/2025/assets/computer-network/confirmation-missing-and-confirmation-late.png)

上图（b）也是一种可能出现的情况。传输过程中没有出现差错，但 `B` 对分组 $M_1$ 的确认迟到了。`A` 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。`B` 仍然会收到重复的 $M_1$ 并且同样要丢弃重复的 $M_1$，并重传确认分组。

通常 `A` 最终总是可以收到对所有发出的分组的确认。如果 `A` 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。

使用上述的确认和重传机制，就可以**在不可靠的传输网络上实现可靠的通信**。

像上述的这种可靠传输协议常称为**自动重传请求** ARQ（Automatic Repeat reQuest）。意思是重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。

（4）信道利用率

停止等待协议的优点是简单，但缺点是信道利用率太低。

为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用**流水线传输**。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据在不间断地传送。这种传输方式可以获得很高的信道利用率。

当使用流水线传输时，就要使用**连续 ARQ 协议**和**滑动窗口协议**。

### 4.2 连续 ARQ 协议

滑动窗口协议比较复杂，是 TCP 协议的精髓所在。

下图表示发送方维持的**发送窗口**，它的意义是：位于发送窗口内的 5 个分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。

![连续 ARQ 协议的工作原理](/2025/assets/computer-network/how-the-continuous-arq-protocol-works.png)

连续 ARQ 协议规定：

- 发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。上图（b）表示发送方收到了对第 1 个分组的确认，于是把发送窗口向前移动一个分组的位置。如果原来已经发送了前 5 个分组，那么现在就可以发送窗口内的第 6 个分组了。
- 接收方一般都是采用**累积确认**的方式。这就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，**对按序到达的最后一个分组发送确认**，表示到这个分组为止的所有分组都已正确收到了。

累积确认有优点也有缺点。优点是：容易实现，即使确认丢失也不必重传。但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。例如，如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。

## 五、TCP 报文段的首部格式

TCP 传送的数据单元是报文段。TCP 报文段分为首部和数据两部分，TCP 的全部功能都体现在它首部中各字段的作用。

TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项（n 是整数）。因此 TCP 首部的最小长度是 20 字节。

首部固定部分各字段的意义如下。

![TCP 报文段的首部格式](/2025/assets/computer-network/the-header-format-of-a-tcp-packet-segment.png)

1. **源端口**和**目的端口**：各占 2 个字节，分别写入源端口号和目的端口号。TCP 的分用功能也是通过端口实现的。
2. **序号**：占 4 字节。序号范围是 [0，$2^{32}$ - 1]，共 $2^{32}$（即 4 294 967 296）个序号。序号增加到 $2^{32}$ − 1 后，下一个序号就又回到 0。也就是说，序号使用 $mod 2^{32}$ 运算。TCP 是面向字节流的。在一个 TCP 连接中传送的字节流中的**每个字节都按顺序编号**。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值指的是**本报文段**所发送的数据的第一个字节的序号。这个字段的名称也叫做“**报文段序号**”。
3. **确认号**：占 4 字节，是**期望收到对方下一个报文段的第一个数据字节的序号**。若确认号 = `N`，则表明：到序号 `N - 1` 为止的所有数据都已正确收到。
4. **数据偏移**：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出 TCP 报文段的**首部长度**。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。注意，“数据偏移”的单位是 32 位字（即以 4 字节长的字为计算单位）。由于 4 位二进制数能够表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节，这也是 TCP 首部的最大长度（即选项长度不能超过 40 字节）。
5. **保留**：占 6 位，保留为今后使用，但目前应置为 0。
6. **紧急 URG**（URGent）：当 `URG = 1` 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序来传送。当 `URG = 1` 时，发送应用进程就告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的**最前面**，而在紧急数据后面的数据仍是普通数据。这时要与首部中**紧急指针**（Urgent Pointer）字段配合使用。
7. **确认 ACK**（ACKnowledgment）：仅当 `ACK = 1` 时确认号字段才有效。当 `ACK = 0` 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 `ACK = 1`。
8. **推送 PSH**（PuSH）：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送操作。这时，发送方 TCP 把 `PSH = 1`，并立即创建一个报文段发送出去。接收方 TCP 收到 `PSH = 1` 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付（推送操作很少使用）。
9. **复位 RST**（ReSeT）：当 `RST = 1` 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立运输连接。`RST = 1` 还用来拒绝一个非法的报文段或拒绝打开一个连接。`RST` 也可称为重建位或重置位。
10. **同步 SYN**（SYNchronization）：在连接建立时用来同步序号。当 `SYN = 1` 而 `ACK = 0` 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 `SYN = 1` 和 `ACK = 1`。因此，`SYN = 1` 就表示这是一个连接请求或连接接受报文。
11. **终止 FIN**（FINish）：用来释放一个连接。当 `FIN = 1` 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。
12. **窗口**：占 2 字节。窗口值是 [0，$2^{16}$ - 1] 之间的整数。窗口指的是发送本报文段的一方的**接收窗口**（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。**窗口值作为接收方让发送方设置其发送窗口的依据**。**窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着**。
13. **检验和**：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 `12` 字节的伪首部。伪首部的格式与 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的 17 改为 6（TCP 的协议号是 6），把第 5 字段中的 UDP 长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。
14. **紧急指针**：占 2 字节。紧急指针仅在 `URG = 1` 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。注意，即使窗口为零时也可发送紧急数据。
15. **选项**：长度可变，最长可达 40 字节。当没有使用“选项“时，TCP 的首部长度是 20 字节。最后的填充字段仅仅是为了使整个 TCP 首部长度是 4 字节的整数倍。

TCP 最初只规定了一种选项，即**最大报文段长度** MSS（Maximum Segment Size）。后来又陆续增加了几个选项。如**窗口扩大**选项、**时间戳**选项、**选择确认**（SACK）选项等。这些选项的位置都在选项字段中。

1. **最大报文段长度** MSS：是**每个** TCP 报文段中的**数据字段的最大长度**。整个的 TCP 报文段的长度，为数据字段加上 TCP 首部。

    为提高网络利用率，MSS 应尽可能大些，只要在 IP 层传输时不需要再分片就行。由于 IP 数据报所经历的路径是动态变化的，在某条路径上不需要分片的 MSS，如果改走另一条路径就可能需要进行分片。因此最佳的 MSS 是很难确定的。在连接建立的过程中，双方都把自己能够支持的 MSS 写入这一字段，以后就按照这个数值传送数据，两个传送方向可以有不同的 MSS 值。若主机未填写这一项，则 MSS 的默认值是 536 字节长。因此，所有在互联网上的主机都应能接受的报文段长度是 536 + 20（固定首部长度）= 556字节。

2. **窗口扩大**选项是为了扩大窗口。我们知道，TCP 首部中窗口字段长度是 16 位，因此最大的窗口大小为 64K 字节。窗口扩大选项占 3 字节，其中有一个字节表示**移位值** S。新的窗口值等于 TCP 首部中的窗口位数从 16 增大到（16 + S）。移位值允许使用的最大值是 14，相当于窗口最大值增大 $2^{（16 + 14）} - 1 = 2^{30} - 1$。窗口扩大选项可以在双方初始建立 TCP 连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送 `S = 0` 的选项，使窗口大小回到 16。

3. **时间戳**选项占 10 字节，其中最主要的字段是**时间戳值**字段（4 字节）和**时间戳回送回答**字段（4 字节）。时间戳选项有两个功能：

    - 第一，计算往返时间 RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出 RTT 来。
    - 第二，处理 TCP 序号超过 $2^{32}$ 的情况，这又称为防止序号绕回 PAWS（Protect Against Wrapped Sequence numbers）。我们知道，TCP 报文段的序号只有 32 位，而每增加 $2^{32}$ 个序号就会重复使用原来用过的序号。当使用高速网络时，在一次 TCP 连接的数据传送中序号很可能会被重复使用。例如，当使用 1.5 Mbit/s 的速率发送报文段时，序号重复要 6 小时以上。但若用 2.5Gbit/s 的速率发送报文段，则不到 14 秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，可以在报文段中加上这种时间戳。

## 六、TCP 可靠传输的实现

### 6.1 以字节为单位的滑动窗口

TCP 的滑动窗口是以字节为单位的。为了便于说明滑动窗口的工作原
理，我们故意把后面图5-14至图5-17中的字节编号都取得很小（实际的窗
口大小多为数千字节）。现假定A收到了B发来的确认报文段，其中窗口是
20 字节，而确认号是31（这表明B期望收到的下一个字节序号是31（请注意，这里不是分
组的序号），而到序号30为止的数据已经收到了）。根据这两个数据，A就构造出自己的发
送窗口，如图5-14所示。

图5-14 根据B给出的窗口值，A构造出自己的发送窗口
我们先讨论发送方A的发送窗口。发送窗口表示：在没有收到B的确认的情况下，A
可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂
时保留，以便在超时重传时使用。
发送窗口里面的序号表示允许发送的序号。显然，窗口越大，发送方就可以在收到对
方确认之前连续发送更多的数据，因而可能获得更高的传输效率。在上面的5.5节我们已经
讲过，接收方会把自己的接收窗口数值放在窗口字段中发送给对方。因此，A的发送窗口一
定不能超过B的接收窗口数值。在后面的5.8节我们将要讨论，发送方的发送窗口大小还要
受到当时网络拥塞程度的制约。但在目前，我们暂不考虑网络拥塞的影响。
发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留了。
而发送窗口前沿的前面部分表示不允许发送，因为接收方没有为这部分数据保留临时存放的
缓存空间。
发送窗口的位置窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种
可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口后沿不可能向后
移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动的，但也有可能不
动。这对应两种情况：一是没有收到新的确认，对方通知的窗口大小也不变;二是收到了新
的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。
发送窗口前沿也有可能向后收缩。这发生在对方通知的窗口缩小了。但TCP的标准强
烈不赞成这样做。因为很可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现
在又要收缩窗口，不让发送这些数据，这样就会产生一些错误。
现在假定A 发送了序号为31~41的数据。这时，发送窗口位置并未改变（如图5-15
所示），但发送窗口内靠后面有11个字节（灰色方框表示）表示已发送但未收到确认。而发
送窗口内靠前面的9个字节（序号42~50）是允许发送但尚未发送的。

图5-15A发送了11个字节的数据

从以上所述可以看出，要描述一个发送窗口的状态需要三个指针：Pi，P2P3（如图 5-15
所示）。指针都指向字节的序号。A的发送窗口中三个指针指向的几个部分的意义如下：
P之前的数据（序号<31）是已发送并已收到确认的部分。
P3之后的数据（序号>50）是不允许发送的部分。
P3-P=A的发送窗口=20（序号31~50）。
P2-P=已发送但尚未收到确认的字节数（序号31~41）。
P3-P2=允许发送但当前尚未发送的字节数（序号42~50）（又称为可用窗口或有效窗
口）。
再看一下 B 的接收窗口。设B 的接收窗口大小是20。在接收窗口外面，到序号为30
的数据是已经发送过确认，并且已经交付主机了。因此在B 可以不再保留这些数据。接收
窗口内的数据（序号31~50）是允许接收的。在图5-15中，B收到了序号为32 和 33 的数
据，但序号为31的数据没有收到（也许丢失了，也许滞留在网络中的某处）。请注意，B 只
能对按序收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是
31（即期望收到的序号）。
现在假定B收到了序号为31的数据，把序号为31~33的数据交付主机，删除这些数
据。接着把接收窗口向前移动3个序号（如图5-16所示），同时给A发送确认，其中窗口
值仍为20，但确认号是34。这表明B已经收到了到序号33为止的数据。我们注意到，B
还收到了序号为37，38和40的数据，但这些数据都没有按序到达，只能先暂存在接收窗口
中。A 收到 B 的确认后，就可以把发送窗口向前滑动3个序号，但指针P，不动。可以看出，
现在A的可用窗口增大了些，可发送的序号范围是42~53。

图5-16A收到新的确认号，发送窗口向前滑动
A 在继续发送完序号42 53 的数据后，指针P，向前移动和P，重合。发送窗口内的序
号都已用完，但还没有再收到确认（如图5-17所示）。由于A的发送窗口已满，可用窗口
已减小到零，因此必须停止发送。请注意，存在下面这种可能性，就是发送窗口内所有的数
据都已正确到达B，B也早已发出了确认。但不幸的是，所有这些确认都滞留在网络中。在
没有收到 B 的确认时，为了保证可靠传输，A只能认为B还没有收到这些数据。于是，A
在经过一段时间后（由超时计时器控制）就重传这部分数据，重新设置超时计时器，直到收
到 B 的确认为止。如果A按序收到落在发送窗口内的确认号，那么A就可以使发送窗口继
续向前滑动，并发送新的数据。

图5-17A的发送窗口内的序号都属于已发送但未被确认

我们在前面的图5-7中曾给出了这样的概念：发送方的应用进程把字节流写入 TCP 的
发送缓存，接收方的应用进程从 TCP 的接收缓存中读取字节流。下面我们就进一步讨论前
面讲的窗口和缓存的关系。图5-18 画出了发送方维持的发送缓存和发送窗口，以及接收方
维持的接收缓存和接收窗口。这里首先要明确两点：

图5-18 TCP的缓存和窗口的关系
第一，缓存空间和序号空间都是有限的，并且都是循环使用的。最好是把它们画成圆
环状的。但这里为了画图的方便，我们还是把它们画成了长条状的。
第二，由于缓存或窗口中实际的字节数可能很大，因此图5-18仅仅是个示意图，没有
标出具体的数值。但用这样的图来说明缓存和发送窗口以及接收窗口的关系是很清楚的。
我们先看一下图5-18（a）所示的发送方的情况。
发送缓存用来暂时存放：
（1）发送应用程序传送给发送方TCP准备发送的数据;
（2）TCP已发送出但尚未收到确认的数据。
发送窗口通常只是发送缓存的一部分。已被确认的数据应当从发送缓存中删除，因此
发送缓存和发送窗口的后沿是重合的。发送应用程序最后写入发送缓存的字节减去最后被确
认的字节，就是还保留在发送缓存中的被写入的字节数。发送应用程序必须控制写入缓存的
速率，不能太快，否则发送缓存就会没有存放数据的空间。
再看一下图5-18（b）所示的接收方的情况。
接收缓存用来暂时存放：
（1）按序到达的，但尚未被接收应用程序读取的数据;
（2）未按序到达的数据。
如果收到的分组被检测出有差错，则要丢弃。如果接收应用程序来不及读取收到的数
据，接收缓存最终就会被填满，使接收窗口减小到零。反之，如果接收应用程序能够及时
从接收缓存中读取收到的数据，接收窗口就可以增大，但最大不能超过接收缓存的大小。

图5-18（b）中还指出了下一个期望收到的字节号。这个字节号也就是接收方给发送方的报文段的首部中的确认号。
根据以上所讨论的，我们还要再强调以下三点。
第一，虽然A的发送窗口是根据B的接收窗口设置的，但在同一时刻，A的发送窗口
并不总是和B的接收窗口一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后
（这个时间是不确定的。另外，正如后面5.7节将要讲到的，发送方A还可能根据网络当
时的拥塞情况适当减小自己的发送窗口数值。
第二，对于不按序到达的数据应如何处理，TCP 标准并无明确规定。如果接收方把不
按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用
不利（因为发送方会重复传送较多的数据）。因此TCP通常是把不按序到达的数据先临时存
放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。
第三，TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以
在合适的时候发送确认，也可以在自己有数据发送时把确认信息顺便捎带上。但请注意两
点。一是接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网
络的资源。TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的
报文段，则必须每隔一个报文段就发送一个确认。二是捎带确认实际上
并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。
最后再强调一下，TCP的通信是全双工通信。通信中的每一方都在发送和接收报文段。
因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清是哪一方的
窗口。

### 6.2 超时重传时间的选择

上面已经讲到，TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。
这种重传的概念是很简单的，但重传时间的选择却是TCP最复杂的问题之一。
由于 TCP 的下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也可
能经过多个低速率的网络，并且每个IP数据报所选择的路由还可能不同。如果把超时重传
时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传
时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。
那么，运输层的超时计时器的超时重传时间究竟应设置为多大呢？
TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的
时间。这两个时间之差就是报文段的往返时间 RTT。TCP 保留了RTT的一个加权平均往返
时间 RTTs（这又称为平滑的往返时间，表示 Smoothed。因为进行的是加权平均，因此得
出的结果更加平滑）。每当第一次测量到 RTT 样本时，RTT值就取为所测量到的 RTT 样本
值。但以后每测量到一个新的RTT样本，就按下式重新计算一次RTTs：
新的 RTTS
<!-- =
（1 - a） × （旧的RTTs）+ax （新的RTT样本）
（5-4） -->
在上式中，0 ≤ a < 1。若a 很接近于零，表示新的RTT值和旧的RTT值相比变化
不大，而对新的 RTT 样本影响不大（RTT值更新较慢）。若选择a接近于1，则表示新的
RTTs值受新的 RTT 样本的影响较大（RTT值更新较快）。已成为建议标准的RFC6298 推荐
的a值为1/8，即0.125。用这种方法得出的加权平均往返时间 RTT，就比测量出的 RTT 值

更加平滑。
显然，超时计时器设置的超时重传时间 RTO （RetransmissionTime-Out）应略大于上面得
出的加权平均往返时间 RTTRFC 6298 建议使用下式计算RTO：
RTO=RTT5 +4×RTTp

而 RTTD 是 RTT的偏差的加权平均值，它与RTT和新的RTT 样本之差有关。RFC
6298 建议这样计算 RTTD。当第一次测量时，RTT值取为测量到的RTT 样本值的一半。在
以后的测量中，则使用下式计算加权平均的RTTp：
新的 RTTD = （1 - B）x（旧的RTTD）+x|RTTs-新的RTT 样本|

这里是个小于1的系数，它的推荐值是1/4，即0.25。
上面所说的往返时间的测量，实现起来相当复杂。试看下面的例子。
如图5-19 所示，发送出一个报文段，设定的重传时间到了，还没有收到确认，于是重
传报文段。经过了一段时间后，收到了确认报文段。现在的问题是：如何判定此确认报文段
是对先发送的报文段的确认，还是对后来重传的报文段的确认？由于重传的报文段和原来的
报文段完全一样，因此源主机在收到确认后，就无法做出正确的判断，而正确的判断对确定
加权平均RTT的值关系很大。
若收到的确认是对重传报文段的确认，但却被源主机当成是对原来的报文段的确认，
则这样计算出的RTT和超时重传时间 RTO 就会偏大。若后面再发送的报文段又是经过重
传后才收到确认报文段，则按此方法得出的超时重传时间 RTO就越来越长。

图5-19 收到的确认是对哪一个报文段的确认？
同样，若收到的确认是对原来的报文段的确认，但被当成是对重传报文段的确认，则
由此计算出的 RTT 和RTO 都会偏小。这就必然导致报文段过多地重传。这样就有可能使
RTO越来越短。
根据以上所述，Karn提出了一个算法：在计算加权平均RTTs时，只要报文段重传了，
就不采用其往返时间样本。这样得出的加权平均RTT和RTO就较准确。
但是，这又引起新的问题。设想出现这样的情况：报文段的时延突然增大了很多。因
此在原来得出的重传时间内不会收到确认报文段，于是就重传报文段。但根据Karn算法，
不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。
因此要对 Karn 算法进行修正。方法是：报文段每重传一次，就把超时重传时间 RTO 增
大一些。典型的做法是取新的重传时间为旧的重传时间的2倍。当不再发生报文段的重传时，
才根据上面给出的式（5-5）计算超时重传时间。实践证明，这种策略较为合理。

总之，Karn 算法能够使运输层区分开有效的和无效的往返时间样本，从而改进了往返
时间的估测，使计算结果更加合理。
5.6.3 选择确认SACK
现在还有一个问题没有讨论。这就是若收到的报文段无差错，只是未按序号，中间还
缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？
答案是可以的。选择确认（Selective ACK）[RFC 2018，建议标准]就是一种可行的处理方法。
我们用一个例子来说明选择确认的工作原理。TCP的接收方在接收对方发送过来的数
据字节流的序号不连续，结果就形成了一些不连续的字节块（如图5-20所示）。可以看出，
序号1~1000收到了，但序号 1001 1500没有收到。接下来的字节流又收到了，可是又缺
少了 3001~3500。再后面从序号4501起又没有收到。也就是说，接收方收到了和前面的字
节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这
些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。

图5-20 接收到的字节流序号不连续
R=4501
从图 5-20 可看出，和前后字节不连续的每一个字节块都有两个边界：左边界和右边界，
因此在图中用四个指针标记这些边界。请注意，第一个字节块的左边界L=1501，但右边界
R=3001 而不是3000。这就是说，左边界指出字节块的第一个字节的序号，但右边界减1才
是字节块的最后一个序号。同理，第二个字节块的左边界L=3501，而右边界R2=4501。
我们知道，TCP 的首部没有哪个字段能够提供上述这些字节块的边界信息。RFC 2018
规定，如果要使用选择确认 SACK，那么在建立TCP连接时，就要在TCP首部的选项中加
上“允许SACK”的选项，而双方必须都事先商定好。如果使用选择确认，那么原来首部中
的“确认号字段”的用法仍然不变。只是以后在TCP报文段的首部中都增加了SACK 选项，
以便报告收到的不连续的字节块的边界。由于首部选项的长度最多只有40字节，而指明一
个边界就要用掉4字节（因为序号有32位，需要使用4个字节表示），因此在选项中最多只
能指明4个字节块的边界信息。这是因为4个字节块共有8个边界，因而需要用32个字节
来描述。另外还需要两个字节，一个字节用来指明是SACK 选项，另一个字节指明这个选
项要占用多少字节。如果要报告5个字节块的边界信息，那么至少需要42个字节。这就超
过了选项长度40字节的上限。互联网建议标准 RFC 2018 还对报告这些边界信息的格式都
做出了非常明确的规定，这里从略。
然而，SACK 文档并没有指明发送方应当怎样响应 SACK。因此大多数的实现还是重传
所有未被确认的数据块。

## 七、TCP 的流量控制

### 7.1 利用滑动窗口实现流量控制

一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据
视频讲解
发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制（flow
control）就是让发送方的发送速率不要太快，要让接收方来得及接收。
利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。
下面通过图5-21的例子说明如何利用滑动窗口机制进行流量控制。

图5-21 利用可变窗口进行流量控制举例

设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口 rwnd 400。”（这里
rwnd 表示 receiver window）因此，发送方的发送窗口不能超过接收方给出的接收窗口的
数值。请注意，TCP的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在
图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1
（见图中第一个箭头上面的序号 seq=1。图中右边的注释可帮助理解整个过程）。请注意，
图中箭头上面大写ACK表示首部中的确认位ACK，小写 ack 表示确认字段的值。

我们应注意到，接收方的主机B进行了三次流量控制。第一次把窗口减小到rwnd 300，
第二次又减到rwnd 100，最后减到rwnd=0，即不允许发送方再发送数据了。这种使发送
方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。我们还应注意到，B向
A 发送的三个报文段都设置了ACK=1，只有在ACK=1时确认号字段才有意义。

现在我们考虑一种情况。在图5-21中，B向A发送了零窗口的报文段后不久，B 的接
收缓存又有了一些存储空间。于是B向A发送了 rwnd 400 的报文段。然而这个报文段在
传送过程中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A 发送的
数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。
为了解决这个问题，TCP为每一个连接设有一个持续计时器（persistence timer）。只要

TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到
期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报
文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持
续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。

### 7.2 TCP 的传输效率

前面已经讲过，应用进程把数据传送到 TCP的发送缓存后，剩下的发
送任务就由TCP来控制了。可以用不同的机制来控制 TCP报文段的发送时
机。例如，第一种机制是TCP维持一个变量，它等于最大报文段长度 MSS。
只要缓存中存放的数据达到 MSS字节时，就组装成一个TCP报文段发送出去。第二种机制
是由发送方的应用进程指明要求发送报文段，即TCP支持的推送（push）操作。第三种机制是
发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过
MSS）发送出去。
但是，如何控制 TCP 发送报文段的时机仍然是一个较为复杂的问题。
例如，一个交互式用户使用一条TELNET连接（运输层为TCP协议）。假设用户只发1
个字符，加上20字节的首部后，得到21字节长的TCP报文段。再加上20字节的IP首部，
形成41字节长的IP数据报。在接收方TCP立即发出确认，构成的数据报是40字节长（假
定没有数据发送）。若用户要求远地主机回送这一字符，则又要发回41字节长的IP数据报
和40字节长的确认IP数据报。这样，用户仅发1个字符时，线路上就需传送总长度为162
字节共4个报文段。当线路带宽并不富裕时，这种传送方法的效率的确不高。因此应适当推
迟发回确认报文，并尽量使用捎带确认的方法。
在TCP 的实现中广泛使用 Nagle 算法。算法如下：若发送应用进程把要发送的数据
个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的
数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数
据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个
报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方
法可明显地减少所用的网络带宽。Nagle 算法还规定，当到达的数据已达到发送窗口大小的
一半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网
络的吞吐量。
另一个问题叫作糊涂窗口综合征（silly window syndrome），有时也会使TCP的性能变坏。
设想一种情况：TCP 接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取 1
个字节（这样就使接收缓存空间仅腾出1个字节），然后向发送方发送确认，并把窗口设置
为1个字节（但发送的数据报是40字节长）。接着，发送方又发来1个字节的数据（请注意，
发送方发送的IP数据报是41字节长）。接收方发回确认，仍然将窗口设置为1个字节。这
样进行下去，使网络的效率很低。
要解决这个问题，可以让接收方等待一段时间，使得或者接收缓存已有足够空间容纳
一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接
①注：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报
文段。

收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报
文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。
上述两种方法可配合使用。使得在发送方不发送很小的报文段的同时，接收方也不要
在缓存刚刚有了一点小的空间就急忙把这个很小的窗口大小信息通知给发送方。

## 八、TCP 的拥塞控制

### 8.1 拥塞控制的一般原理

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫作**拥塞**（congestion）。可以把出现网络拥塞的条件写成如下的关系式：

$$
\sum 对资源的需求 > 可用资源
$$

拥塞控制与流量控制的关系密切，它们之间也存在着一些差别。所谓**拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载**。拥塞控制所要做的都有一个前提，就是**网络能够承受现有的网络负荷**。拥塞控制是一个**全局性的过程**，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。**流量控制往往是指点对点通信量的控制**，是个**端到端**的问题（接收端控制发送端）。流量控制所要做的就是抑制发送端发送数据的速率，以便接收端来得及接收。

### 8.2 TCP 的拥塞控制方法

TCP 进行拥塞控制的算法有四种，即慢开始（slow-start）、拥塞避免
（congestion avoidance）、快重传（fast retransmit）和快恢复（fast recovery）（见草
案标准 RFC 5681）。下面就介绍这些算法的原理。为了集中精力讨论拥塞控
制，我们假定：
（1）数据是单方向传送的，对方只传送确认报文。
视频讲解
（2）接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定。
1.慢开始和拥塞避免
下面讨论的拥塞控制也叫作基于窗口的拥塞控制。为此，发送方维持一个叫作拥塞窗
口 cwnd （congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且是
动态变化着的。发送方让自己的发送窗口等于拥塞窗口。根据假定，对方的接收窗口足够大，
发送方在发送数据时，只需考虑发送方的拥塞窗口。
发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，
以便把更多的分组发送出去，这样就可以提高网络的利用率。但只要网络出现拥塞或有可能
出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现
的拥塞。
发送方又如何知道网络发生了拥塞呢？我们知道，当网络发生拥塞时，路由器就要把
来不及处理而排不上队的分组丢弃。因此只要发送方没有按时收到对方的确认报文，也就是
说，只要出现了超时，就可以估计可能在网络某处出现了拥塞。现在通信线路的传输质量一
般都很好，因传输出差错而丢弃分组的概率是很小的（远小于1%）。因此，发送方在超时
重传计时器启动时，就判断网络出现了拥塞。
下面将讨论拥塞窗口cwnd的大小是怎样变化的。我们从“慢开始算法”讲起。
慢开始算法的思路是这样的：当主机在已建立的 TCP 连接上开始发送数据时，并不清
楚网络当前的负荷情况。如果立即把大量数据字节注入到网络，那么就有可能引起网络发生
拥塞。经验证明，较好的方法是先探测一下，即由小到大逐渐增大注入到网络中的数据字节，
也就是说，由小到大逐渐增大拥塞窗口数值。
旧的规定是这样的：在刚刚开始发送报文段时，先把初始拥塞窗口cwnd设置为1至2
个发送方的最大报文段 SMSS （Sender Maximum Segment Size）的数值，但新的RFC 5681
（草案标准）把初始拥塞窗口wnd设置为不超过2至4个SMSS的数值。具体的规定如下：
若 SMSS>2190字节，
则设置初始拥塞窗口cwnd=2×SMSS 字节，且不得超过2个报文段。
若（SMSS> 1095字节）且（SMSS≤ 2190字节），

则设置初始拥塞窗口cwnd=3×SMSS字节，且不得超过3个报文段。
若 SMSS ≤ 1095字节，
则设置初始拥塞窗口cwnd=4×SMSS字节，且不得超过4个报文段。
可见这个规定就是限制初始拥塞窗口的字节数。
慢开始规定，在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个
SMSS 的数值。更具体些，就是
拥塞窗口 cwnd每次的增加量=min（N，SMSS）
（5-8）
其中N 是原先未被确认的，但现在被刚收到的确认报文段所确认的字节数。不难看出，
当N < SMSS时，拥塞窗口每次的增加量要小于 SMSS。
用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。
下面用例子说明慢开始算法的原理。请注意，虽然实际上 TCP 用字节数作为窗口大小
的单位。但为叙述方便起见，我们用报文段的个数作为窗口大小的单位，这样可以使用较小
的数字来阐明拥塞控制的原理。
在一开始发送方先设置cwnd=1，发送第一个报文段，接收方收到后就发送确认。慢开
始算法规定，发送方每收到一个对新报文段的确认（对重传的确认不算在内），就把发送方
的拥塞窗口加1。因此，经过一个往返时延RTT后，发送方就增大拥塞窗口，使 cwnd = 2，
即发送方现在可连续发送两个报文段。接收方收到这两个报文段后，先后发回两个确认。现
在发送方收到两个确认，根据慢开始算法，拥塞窗口就应当加2，使拥塞窗口从 cwnd = 2增
加到 cwnd = 4，即可连续发送4个报文段。发送方收到这4个确认后，就可以把拥塞窗口再
加 4，使cwnd =8（如图5-24所示）。显然，发送方并不是要在所有的确认都收齐了之后才
调整其拥塞窗口，而是收到一个确认就调整一下拥塞窗口，抓紧时间发送报文段。但这样的
细节不是我们现在所要研究的，我们想知道的只是拥塞窗口的大致增长趋势。

图5-24 发送方每收到1个确认就把拥塞窗口1

由此可见，慢开始的“慢”并不是指 cwnd 的增长速率慢，而是指在TCP 开始发送报
文段时，只发送一个报文段，即设置cwnd = 1，目的是试探一下网络的拥塞情况，然后视情
况再逐渐增大 cwnd。这当然比一开始设置大的cwnd 值，一下子把许多报文段迅速注入到
网络要“慢得多”。这对防止出现网络拥塞是一个非常好的方法。
为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh
状态变量（可以把门限 ssthresh 的数值设置大些，例如达到发送窗口的最大容许值）。慢开

始门限 ssthresh 的用法如下：
当 cwnd < ssthresh时，使用上述的慢开始算法。
当 cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法。
当 cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。
拥塞避免算法的目的是让拥塞窗口cwnd 缓慢地增大（具体算法见）。执行算
法后的结果大约是这样的：每经过一个往返时间 RTT，发送方的拥塞窗口 cwnd 的大小就加
1，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段就称为“加法增大”AI
（Additive Increase），表明在拥塞避免阶段，拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始
算法的拥塞窗口增长速率缓慢得多。
可以用曲线来说明TCP的拥塞窗口cwnd是怎样随时间变化的（如图5-25所示）。但这
里请特别注意横坐标采用的单位是往返时延RTT。在实际的互联网中，TCP 发送的每一个
报文段的往返时延 RTT 都是不一样的（不会像图5-24中所画出的那样很理想的情况）。但
在这里我们是讲解拥塞控制的原理，因此应当把图中的RTT 理解为一个大致的时间，在这
样的时间之内，发送方发出了一批报文段，并且都收到了接收方的确认。图5-25 中的数字
●至是特别要注意的几个点。现假定TCP的发送窗口等于拥塞窗口。

图5-25 TCP拥塞窗口wnd在拥塞控制时的变化情况

当TCP连接已建立后，把拥塞窗口cwnd置为1。在本例中，慢开始门限的初始值设置
为16个报文段，即ssthresh 16。在执行慢开始算法阶段，每经过一个往返时间 RTT，拥
塞窗口wnd就加倍。当拥塞窗口cwnd增长到慢开始门限值 ssthresh时（图中的点●，此时
拥塞窗口 cwnd 16），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。但请注意，
“拥塞避免”并非完全避免拥塞，而是让拥塞窗口增长得缓慢些，使网络不容易出现拥塞。
当拥塞窗口 cwnd 24时，网络出现了超时（图中的点●），这就是网络发生拥塞的标志。
于是调整门限值 ssthresh = cwnd/2=12，同时设置拥塞窗口cwnd = 1，执行慢开始算法。
按照慢开始算法，发送方收到一个对新报文段的确认 ACK，就把拥塞窗口值加1。
当拥塞窗口 cwnd = ssthresh == 12时（图中的点，这是ssthresh第1次调整后的数值），改
为执行拥塞避免算法，拥塞窗口按线性规律增大。
=
当拥塞窗口 cwnd=16时（图中的点），出现了一个新的情况，就是发送方一连收到3
个对同一个报文段的重复确认（图中记为3-ACK）。关于这个问题要解释如下。
有时，个别报文段会在网络中意外丢失，但实际上网络并未发生拥塞。如果发送方迟
迟收不到确认，就会产生超时，并误认为网络发生了拥塞。这就导致发送方错误地启动慢开
始，把拥塞窗口cwnd又设置为1，因而不必要地降低了传输效率。

采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。快重传算法首先要
求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序
的报文段也要立即发出对已收到的报文段的重复确认。如图5-26所示，接收方收到了 M， 和
M，后都分别及时发出了确认。现假定接收方没有收到M，但却收到了Ma。本来接收方可以
什么都不做。但按照快重传算法，接收方必须立即发送对M2的重复确认，以便让发送方及
早知道接收方没有收到报文段 M3。发送方接着发送Ms和M。。接收方收到后也仍要再次分
别发出对M2的重复确认。这样，发送方共收到了接收方的4个对M2的确认，其中后3个
都是重复确认。快重传算法规定，发送方只要一连收到3个重复确认，就可知道现在并未出
现网络拥塞，而只是接收方少收到一个报文段M3，因而立即进行重传M（即“快重传”）。
使用快重传可以使整个网络的吞吐量提高约20%。

图5-26 快重传的示意图

因此，在图 5-25 中的点，发送方知道现在只是丢失了个别的报文段。于是不启动慢
开始，而是执行快恢复算法。这时，发送方第2次调整门限值，使ssthresh = cwnd / 2 = 8，
同时设置拥塞窗口 cwnd = ssthresh=8（见图5-25中的点），并开始执行拥塞避免算法。
在图5-25 中还标注有“TCP Reno 版本”，表示区别于老的TCP Tahao 版本。
请注意，也有的快恢复实现是把快恢复开始时的拥塞窗口 cwnd值再增大一些（增大 3
个报文段的长度），即等于新的ssthresh+3×MSS。这样做的理由是：既然发送方收到3个
重复的确认，就表明有3个分组已经离开了网络。这3个分组不再消耗网络的资源而是停留
在接收方的缓存中（接收方发送出3个重复的确认就证明了这个事实）。可见现在网络中并
不是堆积了分组而是减少了3个分组。因此可以适当把拥塞窗口扩大些。
从图 5-25 可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的，这就是前面
提到过的加法增大AI。而一旦出现超时或3个重复的确认，就要把门限值设置为当前拥塞
窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD （Multiplicative
Decrease）。二者合在一起就是所谓的AIMD算法。
采用这样的拥塞控制方法使得TCP 的性能有明显的改进。
根据以上所述，TCP的拥塞控制可以归纳为图5-27的流程图。这个流程图就比图5-25
所示的特例要更加全面些。例如，图5-25没有说明在慢开始阶段如果出现了超时（即出现
了网络拥塞）或出现3-ACK，发送方应采取什么措施。但从图5-27的流程图就可以很明确
地知道发送方应采取的措施。

图5-27 TCP 的拥塞控制的流程图

在这一节的开始我们就假定了接收方总是有足够大的缓存空间，因而发送窗口的大小
由网络的拥塞程度来决定。但实际上接收方的缓存空间总是有限的。接收方根据自己的接收
能力设定了接收方窗口rwnd，并把这个窗口值写入 TCP 首部中的窗口字段，传送给发送方。
因此，接收方窗口又称为通知窗口（advertised window）。因此，从接收方对发送方的流量控
制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收方窗口值 rwnd。
如果把本节所讨论的拥塞控制和接收方对发送方的流量控制一起考虑，那么很显然，
发送方的窗口的上限值应当取为接收方窗口 rwnd和拥塞窗口 cwnd 这两个变量中较小的一
个，也就是说：
发送方窗口的上限值=Min [rwnd， cwnd]
（5-9）
式（5-9）指出：
当rwnd < cwnd时，是接收方的接收能力限制发送方窗口的最大值。
反之，当cwnd<rwnd时，则是网络的拥塞程度限制发送方窗口的最大值。
也就是说，rwnd和cwnd 中数值较小的一个，控制了发送方发送数据的速率。

### 8.3 主动队列管理 AQM

上一节讨论的 TCP 拥塞控制并没有和网络层采取的策略联系起来。其实，它们之间有
着密切的关系。
例如，假定一个路由器对某些分组的处理时间特别长，那么这就可能使这些分组中的
数据部分（即 TCP报文段）经过很长时间才能到达终点，结果引起发送方对这些报文段的
重传。根据前面所讲的，重传会使 TCP 连接的发送端认为在网络中发生了拥塞。于是在
TCP 的发送端就采取了拥塞控制措施，但实际上网络并没有发生拥塞。
网络层的策略对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。在最简单的情
况下，路由器的队列通常都按照“先进先出”FIFO （First In First Out）的规则处理到来的分
组。由于队列长度总是有限的，因此当队列已满时，以后再到达的所有分组（如果能够继

续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫作尾部丢弃策略（tail-drop
policy）。
路由器的尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使
TCP 进入拥塞控制的慢开始状态，结果使TCP连接的发送方突然把数据的发送速率降低到
很小的数值。更为严重的是，在网络中通常有很多的TCP连接（它们有不同的源点和终点），
这些连接中的报文段通常是复用在网络层的IP数据报中传送的。在这种情况下，若发生了
路由器中的尾部丢弃，就可能会同时影响到很多条TCP连接，结果使这许多TCP 连接在同
一时间突然都进入到慢开始状态。这在TCP的术语中称为全局同步（global synchronization）。
全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很
多。
为了避免发生网络中的全局同步现象，在1998年提出了主动队列管理 AQM （Active
Queue Management）。所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不
得不丢弃后面到达的分组。这样就太被动了。应当在队列长度达到某个值得警惕的数值时
（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。这样就提醒了发送方放慢
发送的速率，因而有可能使网络拥塞的程度减轻，甚至不出现网络拥塞。AQM 可以有不同
实现方法，其中曾流行多年的就是随机早期检测 RED （Random Early Detection）。 RED 还有
几个不同的名称，如 Random Early Drop 或Random Early Discard （随机早期丢弃）。
实现 RED 时需要使路由器维持两个参数，即队列长度最小门限和最大门限。当每一个
分组到达时，RED就按照规定的算法先计算当前的平均队列长度。
（1）若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队。
（2） 若平均队列长度超过最大门限，则把新到达的分组丢弃。
（3）若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率，把新到达的分
组丢弃（这就体现了丢弃分组的随机性）。
由此可见，RED 不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，
而是在检测到网络拥塞的早期征兆时（即路由器的平均队列长度达到一定数值时），就以概
率p丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，因而避免发生全局性的拥
塞控制。
在RED 的操作中，最难处理的就是丢弃概率的选择，因为并不是个常数。对每一
个到达的分组，都必须计算丢弃概率p的数值。IETF 曾经推荐在互联网中的路由器使用
RED 机制[RFC 2309]，但多年的实践证明，RED的使用效果并不太理想。因此，在2015年
公布的 RFC 7567已经把过去的RFC2309列为“陈旧的”，并且不再推荐使用RED。对路
由器进行主动队列管理 AQM 仍是必要的。AQM实际上就是对路由器中的分组排队进行智
能管理，而不是简单地把队列的尾部丢弃。现在已经有几种不同的算法来代替旧的RED，但
都还在实验阶段。目前还没有一种算法能够成为IETF的标准，读者可注意这方面的进展。

## 九、TCP 的运输连接管理

TCP 的运输连接有三个阶段：连接建立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。

TCP 连接建立过程中要解决三个问题。

1. 使每一方能够确知对方的存在。
2. 允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。
3. 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。

TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫作**客户**（client），被动等待连接建立的应用进程叫作**服务器**（server）。

### 9.1 TCP 的连接建立

TCP 建立连接的过程叫作握手，握手需要在客户和服务器之间交换三个 TCP 报文段。

![用三报文握手建立 TCP 连接](/2025/assets/computer-network/a-three-packet-handshake-is-used-to-establish-a-tcp-connection.png)

1. 假定客户端（以下代指 A）和服务器（以下代指 B）最初都处于 **CLOSED**（关闭）状态，并分别创建传输控制块 TCB。之后，服务器处于 **LISTEN**（收听）状态，等待客户端的连接请求。

2. 客户端向服务器发出连接请求报文段，请求首部中的同步位 `SYN = 1`，初始序号 `seq = x`。客户端进入 **SYN-SENT**（同步已发送）状态。

3. 服务器收到连接请求报文段后，如同意建立连接，则向客户端发送确认。在确认报文段中 `SYN = 1`、`ACK = 1`，确认号是 `ack = x + 1`，同时设置自己的初始序号 `seq = y`。服务器进入 **SYN-RCVD**（同步收到）状态。

4. 客户端收到服务器的确认后，还要向服务器给出确认。确认报文段的 `ACK = 1`，确认号 `ack = y + 1`，而自己的序号 `seq = x + 1`。至此，TCP 连接建立，客户端进入 **ESTABLISHED** （已建立连接）状态。在这种情况下，下一个数据报文段的序号仍是 `seq = x + 1`。

5. 服务器收到客户端的确认后，也进入 **ESTABLISHED** 状态。

上面给出的连接建立过程叫作**三报文握手**。注意，上图中服务器发送给客户端的报文段，也可以拆成两个报文段。可以先发送一个确认报文段（`ACK = 1`，`ack = x + 1`），然后再发送一个同步报文段（`SYN = 1`，`seq = y`）。这样的过程就变成了四报文握手，但效果是一样的。

为什么客户端最后还要发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了服务器，因而产生错误。

所谓“已失效的连接请求报文段”是这样产生的。正常情况下，客户端发出连接请求，但因连接请求报文丢失而未收到确认。于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。客户端共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务器，没有“已失效的连接请求报文段”。

现假定出现一种异常情况，即客户端发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到达服务器。本来这是一个早已失效的报文段。但服务器收到此失效的连接请求报文段后，就误认为是客户端又发出一次新的连接请求。于是就向客户端发出确认报文段，同意建立连接。假定不采用报文握手，那么只要服务器发出确认，新的连接就建立了。

由于现在客户端并没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据。但服务器却以为新的运输连接已经建立了，并一直等待客户端发来数据。服务器的许多资源就这样白白浪费了。

采用三报文握手的办法，可以防止上述现象的发生。例如在刚才的异常情况下，客户端不会向服务器的确认发出确认。由于收不到确认，就知道客户端并没有要求建立连接。

注意，TCP 规定，`SYN` 报文段不能携带数据，但要消耗掉一个序号；`ACK` 报文段可以携带数据，但如果不携带数据则不消耗序号。

*传输控制块 TCB（Transmission Control Block）存储了每个连接中的一些重要信息，比如，TCP 连接表，指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等。*

### 9.2 TCP 的连接释放

![TCP 连接释放的过程](/2025/assets/computer-network/the-process-of-releasing-the-tcp-connection.png)

开始时客户端（以下代指 A）和服务器（以下代指 B）都处于 **ESTABLISHED** 状态。

1. 客户端发出连接释放报文段，首部的 `FIN = 1`，序号 `seq = u`，它等于前面已传送过的数据的最后一个字节的序号加 1。客户端进入 **FIN-WAIT-1**（终止等待 1）状态。

2. 服务器收到连接释放报文段后随即发出确认，确认报文段中 `ACK = 1`、`ack = u + 1`，自己的序号是 `seq = v`， 等于服务器前面已传送的数据的最后一个字节的序号加 1。服务器进入 **CLOSE-WAIT**（关闭等待）状态。服务器这时应通知高层应用进程，此时，从客户端到服务器这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即客户端已经没有数据要发送了，但服务器若发送数据，客户端仍要接收。也就是说，从服务器到客户端这个方向的连接并未关闭，这个状态可能会持续一段时间。

3. 客户端收到来自服务器的确认后，进入 **FIN-WAIT-2**（终止等待 2）状态，等待服务器发出的连接释放报文段。

4. 若服务器已经没有要向客户端发送的数据，服务器发出连接释放报文段，其中的 `FIN = 1`。现假定服务器的序号为 `w`（在半关闭状态服务器可能又发送了一些数据）。服务器还必须重复上次已发送过的确认号 `ack = u + 1`。服务器进入 **LAST-ACK**（最后确认）状态，等待客户端的确认。

5. 客户端收到服务器的连接释放报文段后，在确认报文段中把 `ACK = 1`，确认号 `ack = w + 1`，而自己的序号是 `seq = u + 1`。客户端进入 **TIME-WAIT**（时间等待）状态。

6. 现在 TCP 连接还没有释放掉。必须经过**时间等待计时器**（TIME-WAIT timer）设置的时间 2MSL 后，客户端才进入到 **CLOSED** 状态。时间 MSL 叫作**最长报文段寿命**（Maximum Segment Lifetime），一般建议设为 2 分钟。对于现在的网络，MSL = 2 分钟可能太长。因此 TCP 允许不同的实现，可根据具体情况使用更小的 MSL 值。因此，从客户端进入到 **TIME-WAIT** 状态后，要经过 4 分钟才能进入到 **CLOSED** 状态，之后才能开始建立下一个新的连接。当客户端撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。

上述的 TCP 连接释放过程是**四报文握手**。

注意，`FIN` 报文段即使不携带数据，它也消耗掉一个序号。

为什么客户端在 **TIME-WAIT** 状态必须等待 2MSL 的时间呢？这有两个理由。

- 为了保证客户端发送的最后一个 `ACK` 报文段能够到达服务器。这个 `ACK` 报文段有可能丢失，因而使处在 **LAST-ACK** 状态的服务器收不到对已发送的 `FIN` + `ACK` 报文段的确认。服务器会超时重传这个 `FIN` + `ACK` 报文段，而客户端就能在 2MSL 时间内收到这个重传的 `FIN` + `ACK` 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 **CLOSED** 状态。如果客户端在 **TIME-WAIT** 状态不等待一段时间，而是在发送完 `ACK` 报文段后立即释放连接，那么就无法收到服务器重传的 `FIN` + `ACK` 报文段，因而也不会再发送一次确认报文段。这样，服务器就无法按照正常步骤进入 **CLOSED** 状态。
- 防止“已失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个 `ACK` 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。服务器只要收到了客户端发出的确认，就进入 **CLOSED** 状态。同样，服务器在撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。注意，服务器结束 TCP 连接的时间要比客户端早一些。

除时间等待计时器外，TCP 还设有一个**保活计时器**（keepalive timer）。设想有这样的情况：客户主动与服务器建立了 TCP 连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。

### 9.3 TCP 的有限状态机

![TCP 的有限状态机](/2025/assets/computer-network/the-finite-state-machine-of-tcp.png)

为了更清晰地看出 TCP 连接的各种状态之间的关系，上给出了 TCP 的有限状态机。图中每个方框是 TCP 可能具有的状态。每个方框中
的大写英文字符串是TCP标准所使用的TCP连接状态名。状态之间的箭头表示可能发生的状态变迁。箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。请注意图中有三种不同的箭头。粗实线箭头表示对客户进程的正常变迁。粗虚线箭头表示对服务器进程的正常变迁。另一种细线箭头表示异常变迁。
